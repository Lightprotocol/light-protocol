//! Tests for the InstructionDecoder generated by the #[instruction_decoder] attribute macro.

use anchor_lang::InstructionData;
use light_instruction_decoder::InstructionDecoder;
use sdk_token_test::SdkTokenTestInstructionDecoder;
use solana_sdk::pubkey::Pubkey;

#[test]
fn test_decode_batch_compress_tokens() {
    let decoder = SdkTokenTestInstructionDecoder;
    let instruction_data = sdk_token_test::instruction::BatchCompressTokens {
        recipients: vec![],
        token_pool_index: 0,
        token_pool_bump: 255,
    }
    .data();

    let decoded = decoder
        .decode(&instruction_data, &[])
        .expect("Failed to decode BatchCompressTokens");

    assert_eq!(
        decoded.name, "BatchCompressTokens",
        "Instruction name should match"
    );
}

#[test]
fn test_decode_compress_tokens() {
    let decoder = SdkTokenTestInstructionDecoder;
    let instruction_data = sdk_token_test::instruction::CompressTokens {
        output_tree_index: 0,
        recipient: Pubkey::default(),
        mint: Pubkey::default(),
        amount: 1000,
    }
    .data();

    let decoded = decoder
        .decode(&instruction_data, &[])
        .expect("Failed to decode CompressTokens");

    assert_eq!(
        decoded.name, "CompressTokens",
        "Instruction name should match"
    );
}

#[test]
fn test_decode_transfer_tokens() {
    let decoder = SdkTokenTestInstructionDecoder;
    let instruction_data = sdk_token_test::instruction::TransferTokens {
        validity_proof: light_token::ValidityProof::default(),
        token_metas: vec![],
        output_tree_index: 0,
        mint: Pubkey::default(),
        recipient: Pubkey::default(),
    }
    .data();

    let decoded = decoder
        .decode(&instruction_data, &[])
        .expect("Failed to decode TransferTokens");

    assert_eq!(
        decoded.name, "TransferTokens",
        "Instruction name should match"
    );
}

#[test]
fn test_decode_decompress_tokens() {
    let decoder = SdkTokenTestInstructionDecoder;
    let instruction_data = sdk_token_test::instruction::DecompressTokens {
        validity_proof: light_token::ValidityProof::default(),
        token_data: vec![],
        output_tree_index: 0,
        mint: Pubkey::default(),
    }
    .data();

    let decoded = decoder
        .decode(&instruction_data, &[])
        .expect("Failed to decode DecompressTokens");

    assert_eq!(
        decoded.name, "DecompressTokens",
        "Instruction name should match"
    );
}

#[test]
fn test_decoder_program_id() {
    let decoder = SdkTokenTestInstructionDecoder;
    assert_eq!(
        decoder.program_id(),
        sdk_token_test::ID,
        "Program ID should match declared ID"
    );
}

#[test]
fn test_decoder_program_name() {
    let decoder = SdkTokenTestInstructionDecoder;
    assert_eq!(
        decoder.program_name(),
        "Sdk Token Test",
        "Program name should match module name in title case"
    );
}

#[test]
fn test_decode_unknown_discriminator_returns_none() {
    let decoder = SdkTokenTestInstructionDecoder;
    let invalid_data = [0u8; 8];

    assert!(
        decoder.decode(&invalid_data, &[]).is_none(),
        "Unknown discriminator should return None"
    );
}

#[test]
fn test_decode_insufficient_data_returns_none() {
    let decoder = SdkTokenTestInstructionDecoder;
    let short_data = [0u8; 4];

    assert!(
        decoder.decode(&short_data, &[]).is_none(),
        "Data shorter than 8 bytes should return None"
    );
}
