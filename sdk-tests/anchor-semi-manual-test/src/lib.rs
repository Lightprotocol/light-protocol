//! Test program for #[derive(LightProgram)] macro validation.
//!
//! Uses #[derive(LightProgram)] with plain #[program] (no #[light_program]).
//! Exercises all variant kinds: PDA, ATA, token, zero_copy.

#![allow(deprecated)]

use std::marker::PhantomData;

use anchor_lang::prelude::*;
use light_account::{derive_light_cpi_signer, CpiSigner, LightProgram};

pub mod instruction_accounts;
pub mod state;

pub use instruction_accounts::*;
pub use state::*;

declare_id!("DrvPda11111111111111111111111111111111111111");

pub const LIGHT_CPI_SIGNER: CpiSigner =
    derive_light_cpi_signer!("DrvPda11111111111111111111111111111111111111");

pub const VAULT_AUTH_SEED: &[u8] = b"vault_auth";
pub const VAULT_SEED: &[u8] = b"vault";
pub const RECORD_SEED: &[u8] = b"zero_copy_record";
pub const MINT_SIGNER_SEED_A: &[u8] = b"mint_signer_a";
pub const MINT_SIGNER_SEED_B: &[u8] = b"mint_signer_b";

#[derive(LightProgram)]
pub enum ProgramAccounts {
    #[light_account(pda::seeds = [b"minimal_record", ctx.owner])]
    MinimalRecord(MinimalRecord),

    #[light_account(associated_token)]
    Ata,

    #[light_account(token::seeds = [VAULT_SEED, ctx.mint], token::owner_seeds = [VAULT_AUTH_SEED])]
    Vault,

    #[light_account(pda::seeds = [RECORD_SEED, ctx.owner], pda::zero_copy)]
    ZeroCopyRecord(ZeroCopyRecord),
}

#[program]
pub mod anchor_semi_manual_test {
    use light_account::{light_err, LightFinalize, LightPreInit};

    use super::*;

    // =========================================================================
    // Compression infrastructure (generated by #[derive(LightProgram)])
    // =========================================================================

    pub fn compress_accounts_idempotent<'info>(
        ctx: Context<'_, '_, '_, 'info, EmptyAccounts<'info>>,
        params: light_account::CompressAndCloseParams,
    ) -> Result<()> {
        light_account::process_compress_pda_accounts_idempotent(
            ctx.remaining_accounts,
            &params,
            ProgramAccounts::compress_dispatch,
            LIGHT_CPI_SIGNER,
            &LIGHT_CPI_SIGNER.program_id,
        )
        .map_err(Into::into)
    }

    pub fn decompress_accounts_idempotent<'info>(
        ctx: Context<'_, '_, '_, 'info, EmptyAccounts<'info>>,
        params: light_account::DecompressIdempotentParams<PackedLightAccountVariant>,
    ) -> Result<()> {
        use solana_program::{clock::Clock, sysvar::Sysvar};
        let current_slot = Clock::get()?.slot;
        ProgramAccounts::decompress_dispatch(
            ctx.remaining_accounts,
            &params,
            LIGHT_CPI_SIGNER,
            &LIGHT_CPI_SIGNER.program_id,
            current_slot,
        )
        .map_err(Into::into)
    }

    pub fn initialize_compression_config<'info>(
        ctx: Context<'_, '_, '_, 'info, EmptyAccounts<'info>>,
        params: InitConfigParams,
    ) -> Result<()> {
        light_account::process_initialize_light_config(
            &ctx.remaining_accounts[1], // config
            &ctx.remaining_accounts[3], // authority
            &params.rent_sponsor.to_bytes(),
            &params.compression_authority.to_bytes(),
            params.rent_config,
            params.write_top_up,
            params.address_space.iter().map(|p| p.to_bytes()).collect(),
            0,                          // config_bump
            &ctx.remaining_accounts[0], // payer
            &ctx.remaining_accounts[4], // system_program
            &LIGHT_CPI_SIGNER.program_id,
        )
        .map_err(Into::into)
    }

    pub fn update_compression_config<'info>(
        ctx: Context<'_, '_, '_, 'info, EmptyAccounts<'info>>,
        instruction_data: Vec<u8>,
    ) -> Result<()> {
        light_account::process_update_light_config(
            ctx.remaining_accounts,
            &instruction_data,
            &LIGHT_CPI_SIGNER.program_id,
        )
        .map_err(Into::into)
    }

    // =========================================================================
    // Instruction handlers (manually written for #[derive(LightProgram)])
    // =========================================================================

    pub fn create_pda<'info>(
        ctx: Context<'_, '_, '_, 'info, CreatePda<'info>>,
        params: CreatePdaParams,
    ) -> Result<()> {
        let has_pre_init = ctx
            .accounts
            .light_pre_init(ctx.remaining_accounts, &params)
            .map_err(light_err)?;
        ctx.accounts.record.owner = params.owner;
        ctx.accounts
            .light_finalize(ctx.remaining_accounts, &params, has_pre_init)
            .map_err(light_err)?;
        Ok(())
    }

    pub fn create_ata<'info>(
        ctx: Context<'_, '_, '_, 'info, CreateAta<'info>>,
        params: CreateAtaParams,
    ) -> Result<()> {
        let has_pre_init = ctx
            .accounts
            .light_pre_init(ctx.remaining_accounts, &params)
            .map_err(light_err)?;
        ctx.accounts
            .light_finalize(ctx.remaining_accounts, &params, has_pre_init)
            .map_err(light_err)?;
        Ok(())
    }

    pub fn create_token_vault<'info>(
        ctx: Context<'_, '_, '_, 'info, CreateTokenVault<'info>>,
        params: CreateTokenVaultParams,
    ) -> Result<()> {
        let has_pre_init = ctx
            .accounts
            .light_pre_init(ctx.remaining_accounts, &params)
            .map_err(light_err)?;
        ctx.accounts
            .light_finalize(ctx.remaining_accounts, &params, has_pre_init)
            .map_err(light_err)?;
        Ok(())
    }

    pub fn create_zero_copy_record<'info>(
        ctx: Context<'_, '_, '_, 'info, CreateZeroCopyRecord<'info>>,
        params: CreateZeroCopyRecordParams,
    ) -> Result<()> {
        let has_pre_init = ctx
            .accounts
            .light_pre_init(ctx.remaining_accounts, &params)
            .map_err(light_err)?;
        {
            let mut record = ctx.accounts.record.load_init()?;
            record.owner = params.owner;
        }
        ctx.accounts
            .light_finalize(ctx.remaining_accounts, &params, has_pre_init)
            .map_err(light_err)?;
        Ok(())
    }

    pub fn create_mint<'info>(
        ctx: Context<'_, '_, '_, 'info, CreateMint<'info>>,
        params: CreateMintParams,
    ) -> Result<()> {
        let has_pre_init = ctx
            .accounts
            .light_pre_init(ctx.remaining_accounts, &params)
            .map_err(light_err)?;
        ctx.accounts
            .light_finalize(ctx.remaining_accounts, &params, has_pre_init)
            .map_err(light_err)?;
        Ok(())
    }

    pub fn create_two_mints<'info>(
        ctx: Context<'_, '_, '_, 'info, CreateTwoMints<'info>>,
        params: CreateTwoMintsParams,
    ) -> Result<()> {
        let has_pre_init = ctx
            .accounts
            .light_pre_init(ctx.remaining_accounts, &params)
            .map_err(light_err)?;
        ctx.accounts
            .light_finalize(ctx.remaining_accounts, &params, has_pre_init)
            .map_err(light_err)?;
        Ok(())
    }

    pub fn create_all<'info>(
        ctx: Context<'_, '_, '_, 'info, CreateAll<'info>>,
        params: CreateAllParams,
    ) -> Result<()> {
        let has_pre_init = ctx
            .accounts
            .light_pre_init(ctx.remaining_accounts, &params)
            .map_err(light_err)?;
        ctx.accounts.record.owner = params.owner;
        {
            let mut record = ctx.accounts.zero_copy_record.load_init()?;
            record.owner = params.owner;
        }
        ctx.accounts
            .light_finalize(ctx.remaining_accounts, &params, has_pre_init)
            .map_err(light_err)?;
        Ok(())
    }
}

/// Accounts struct for compress instruction.
/// Uses PhantomData for the `<'info>` lifetime so Anchor's CPI codegen works.
/// All accounts are passed via remaining_accounts.
pub struct EmptyAccounts<'info>(PhantomData<&'info ()>);

impl<'info> anchor_lang::Accounts<'info, EmptyAccountsBumps> for EmptyAccounts<'info> {
    fn try_accounts(
        _program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        _accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<'info>],
        _ix_data: &[u8],
        _bumps: &mut EmptyAccountsBumps,
        _reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        Ok(EmptyAccounts(PhantomData))
    }
}

#[derive(Debug, Default)]
pub struct EmptyAccountsBumps {}

impl<'info> anchor_lang::Bumps for EmptyAccounts<'info> {
    type Bumps = EmptyAccountsBumps;
}

impl<'info> anchor_lang::ToAccountInfos<'info> for EmptyAccounts<'info> {
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        Vec::new()
    }
}

impl<'info> anchor_lang::ToAccountMetas for EmptyAccounts<'info> {
    fn to_account_metas(
        &self,
        _is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        Vec::new()
    }
}

impl<'info> anchor_lang::AccountsExit<'info> for EmptyAccounts<'info> {
    fn exit(
        &self,
        _program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        Ok(())
    }
}

#[cfg(feature = "idl-build")]
impl<'info> EmptyAccounts<'info> {
    pub fn __anchor_private_gen_idl_accounts(
        _accounts: &mut std::collections::BTreeMap<String, anchor_lang::idl::types::IdlAccount>,
        _types: &mut std::collections::BTreeMap<String, anchor_lang::idl::types::IdlTypeDef>,
    ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
        Vec::new()
    }
}

pub(crate) mod __client_accounts_empty_accounts {
    use super::*;
    pub struct EmptyAccounts<'info>(PhantomData<&'info ()>);
    impl<'info> borsh::ser::BorshSerialize for EmptyAccounts<'info> {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            _writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl<'info> anchor_lang::ToAccountMetas for EmptyAccounts<'info> {
        fn to_account_metas(
            &self,
            _is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            Vec::new()
        }
    }
}

pub(crate) mod __cpi_client_accounts_empty_accounts {
    use super::*;
    #[allow(dead_code)]
    pub struct EmptyAccounts<'info>(PhantomData<&'info ()>);
    impl<'info> anchor_lang::ToAccountMetas for EmptyAccounts<'info> {
        fn to_account_metas(
            &self,
            _is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            Vec::new()
        }
    }
    impl<'info> anchor_lang::ToAccountInfos<'info> for EmptyAccounts<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            Vec::new()
        }
    }
}
