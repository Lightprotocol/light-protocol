//! Test program for #[derive(LightProgram)] macro validation.
//!
//! Uses #[derive(LightProgram)] with plain #[program] (no #[light_program]).
//! Exercises all variant kinds: PDA, ATA, token, zero_copy.

#![allow(deprecated)]

use std::marker::PhantomData;

use anchor_lang::prelude::*;
use light_sdk::derive_light_cpi_signer;
use light_sdk_macros::LightProgram;
use light_sdk_types::CpiSigner;

pub mod instruction_accounts;
pub mod state;

pub use instruction_accounts::*;
pub use state::*;

declare_id!("DrvPda11111111111111111111111111111111111111");

pub const LIGHT_CPI_SIGNER: CpiSigner =
    derive_light_cpi_signer!("DrvPda11111111111111111111111111111111111111");

pub const VAULT_AUTH_SEED: &[u8] = b"vault_auth";
pub const VAULT_SEED: &[u8] = b"vault";
pub const RECORD_SEED: &[u8] = b"zero_copy_record";
pub const MINT_SIGNER_SEED_A: &[u8] = b"mint_signer_a";
pub const MINT_SIGNER_SEED_B: &[u8] = b"mint_signer_b";

#[derive(LightProgram)]
pub enum ProgramAccounts {
    #[light_account(pda::seeds = [b"minimal_record", ctx.owner])]
    MinimalRecord(MinimalRecord),

    #[light_account(associated_token)]
    Ata,

    #[light_account(token::seeds = [VAULT_SEED, ctx.mint], token::owner_seeds = [VAULT_AUTH_SEED])]
    Vault,

    #[light_account(pda::seeds = [RECORD_SEED, ctx.owner], pda::zero_copy)]
    ZeroCopyRecord(ZeroCopyRecord),
}

#[program]
pub mod single_pda_derive_test {
    use super::*;

    // =========================================================================
    // Compression infrastructure (generated by #[derive(LightProgram)])
    // =========================================================================

    pub fn compress_accounts_idempotent<'info>(
        ctx: Context<'_, '_, '_, 'info, EmptyAccounts<'info>>,
        instruction_data: Vec<u8>,
    ) -> Result<()> {
        light_sdk_interface::program::compression::processor::process_compress_pda_accounts_idempotent(
            ctx.remaining_accounts,
            &instruction_data,
            ProgramAccounts::compress_dispatch,
            LIGHT_CPI_SIGNER,
            &LIGHT_CPI_SIGNER.program_id,
        ).map_err(|e| ProgramError::Custom(u64::from(e) as u32))
    }

    pub fn decompress_accounts_idempotent<'info>(
        ctx: Context<'_, '_, '_, 'info, EmptyAccounts<'info>>,
        instruction_data: Vec<u8>,
    ) -> Result<()> {
        ProgramAccounts::decompress_dispatch(
            ctx.remaining_accounts,
            &instruction_data,
            LIGHT_CPI_SIGNER,
            &crate::ID,
        )
        .map_err(Into::into)
    }

    pub fn initialize_compression_config<'info>(
        ctx: Context<'_, '_, '_, 'info, EmptyAccounts<'info>>,
        instruction_data: Vec<u8>,
    ) -> Result<()> {
        light_sdk_interface::program::config::process_initialize_light_config_checked(
            ctx.remaining_accounts,
            &instruction_data,
            &crate::ID,
        )
        .map_err(Into::into)
    }

    pub fn update_compression_config<'info>(
        ctx: Context<'_, '_, '_, 'info, EmptyAccounts<'info>>,
        instruction_data: Vec<u8>,
    ) -> Result<()> {
        light_sdk_interface::program::config::process_update_light_config(
            ctx.remaining_accounts,
            &instruction_data,
            &crate::ID,
        )
        .map_err(Into::into)
    }
}

/// Accounts struct for compress instruction.
/// Uses PhantomData for the `<'info>` lifetime so Anchor's CPI codegen works.
/// All accounts are passed via remaining_accounts.
pub struct EmptyAccounts<'info>(PhantomData<&'info ()>);

impl<'info> anchor_lang::Accounts<'info, EmptyAccountsBumps> for EmptyAccounts<'info> {
    fn try_accounts(
        _program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        _accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<'info>],
        _ix_data: &[u8],
        _bumps: &mut EmptyAccountsBumps,
        _reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        Ok(EmptyAccounts(PhantomData))
    }
}

#[derive(Debug, Default)]
pub struct EmptyAccountsBumps {}

impl<'info> anchor_lang::Bumps for EmptyAccounts<'info> {
    type Bumps = EmptyAccountsBumps;
}

impl<'info> anchor_lang::ToAccountInfos<'info> for EmptyAccounts<'info> {
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        Vec::new()
    }
}

impl<'info> anchor_lang::ToAccountMetas for EmptyAccounts<'info> {
    fn to_account_metas(
        &self,
        _is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        Vec::new()
    }
}

impl<'info> anchor_lang::AccountsExit<'info> for EmptyAccounts<'info> {
    fn exit(
        &self,
        _program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        Ok(())
    }
}

#[cfg(feature = "idl-build")]
impl<'info> EmptyAccounts<'info> {
    pub fn __anchor_private_gen_idl_accounts(
        _accounts: &mut std::collections::BTreeMap<String, anchor_lang::idl::types::IdlAccount>,
        _types: &mut std::collections::BTreeMap<String, anchor_lang::idl::types::IdlTypeDef>,
    ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
        Vec::new()
    }
}

pub(crate) mod __client_accounts_empty_accounts {
    use super::*;
    pub struct EmptyAccounts<'info>(PhantomData<&'info ()>);
    impl<'info> borsh::ser::BorshSerialize for EmptyAccounts<'info> {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            _writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl<'info> anchor_lang::ToAccountMetas for EmptyAccounts<'info> {
        fn to_account_metas(
            &self,
            _is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            Vec::new()
        }
    }
}

pub(crate) mod __cpi_client_accounts_empty_accounts {
    use super::*;
    pub struct EmptyAccounts<'info>(PhantomData<&'info ()>);
    impl<'info> anchor_lang::ToAccountMetas for EmptyAccounts<'info> {
        fn to_account_metas(
            &self,
            _is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            Vec::new()
        }
    }
    impl<'info> anchor_lang::ToAccountInfos<'info> for EmptyAccounts<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            Vec::new()
        }
    }
}
