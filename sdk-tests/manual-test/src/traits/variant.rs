//! LightAccountVariant traits for typed compressed account handling.
//!
//! These traits enable type-safe handling of compressed accounts with seeds,
//! supporting both unpacked (with Pubkeys) and packed (with u8 indices) representations.

use anchor_lang::prelude::*;
use light_sdk::instruction::PackedAccounts;

/// Trait for unpacked compressed account variants with seeds.
///
/// Implementations are generated by the `#[light_program]` macro for each
/// account type marked with `#[light_account(init)]`.
///
/// # Type Parameters
/// * `Seeds` - The seeds struct type (e.g., `UserRecordSeeds`)
/// * `Data` - The account data type (e.g., `UserRecord`)
/// * `Packed` - The packed variant type for serialization
pub trait LightAccountVariant: Sized + Clone + AnchorSerialize + AnchorDeserialize {
    /// The seeds struct type containing seed values.
    type Seeds;

    /// The account data type.
    type Data;

    /// The packed variant type for efficient serialization.
    type Packed: PackedLightAccountVariant<Unpacked = Self>;

    /// Number of seeds used for PDA derivation.
    const SEED_COUNT: usize;

    /// Get a reference to the seeds.
    fn seeds(&self) -> &Self::Seeds;

    /// Get a reference to the account data.
    fn data(&self) -> &Self::Data;

    /// Get a mutable reference to the account data.
    fn data_mut(&mut self) -> &mut Self::Data;

    /// Get seed references as byte slices for PDA derivation.
    fn seed_refs(&self) -> Vec<Vec<u8>>;

    /// Derive the PDA address and bump seed.
    fn derive_pda(&self, program_id: &Pubkey) -> (Pubkey, u8) {
        let seeds = self.seed_refs();
        let seed_slices: Vec<&[u8]> = seeds.iter().map(|s| s.as_slice()).collect();
        Pubkey::find_program_address(&seed_slices, program_id)
    }

    /// Pack this variant for efficient serialization.
    fn pack(
        &self,
        accounts: &mut PackedAccounts,
        program_id: &Pubkey,
    ) -> Result<Self::Packed>;
}

/// Trait for packed compressed account variants.
///
/// Packed variants use u8 indices instead of 32-byte Pubkeys for efficient
/// serialization. They can be unpacked back to full variants using account info.
pub trait PackedLightAccountVariant: Sized + Clone + AnchorSerialize + AnchorDeserialize {
    /// The unpacked variant type with full Pubkey values.
    type Unpacked: LightAccountVariant;

    /// Get the PDA bump seed.
    fn bump(&self) -> u8;

    /// Unpack this variant by resolving u8 indices to Pubkeys.
    fn unpack(&self, accounts: &[AccountInfo]) -> Result<Self::Unpacked>;
}
