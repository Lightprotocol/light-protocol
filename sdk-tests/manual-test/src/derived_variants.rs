//! Program-wide variant enums for compress/decompress dispatch.
//!
//! This module contains the code that would be generated by the `#[light_program]` macro.

use anchor_lang::prelude::*;
use light_sdk::interface::{
    error::LightPdaError, prepare_account_for_decompression, DecompressCtx, DecompressVariant,
};
use light_sdk_types::instruction::PackedStateTreeInfo;
use solana_account_info::AccountInfo;

use crate::{
    account_loader::derived_accounts::{
        PackedZeroCopyRecordSeeds, PackedZeroCopyRecordVariant, ZeroCopyRecordSeeds,
    },
    all::derived_accounts::{
        AllBorshSeeds, AllZeroCopySeeds, PackedAllBorshSeeds, PackedAllBorshVariant,
        PackedAllZeroCopySeeds, PackedAllZeroCopyVariant,
    },
    pda::derived_accounts::{
        MinimalRecordSeeds, PackedMinimalRecordSeeds, PackedMinimalRecordVariant,
    },
    MinimalRecord, PackedMinimalRecord, PackedZeroCopyRecord, ZeroCopyRecord,
};

// ============================================================================
// Program-wide Variant Enums (generated by #[light_program])
// ============================================================================

/// Unpacked variant enum for all account types in this program.
/// Each variant contains the full seeds + data.
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub enum LightAccountVariant {
    MinimalRecord {
        seeds: MinimalRecordSeeds,
        data: MinimalRecord,
    },
    ZeroCopyRecord {
        seeds: ZeroCopyRecordSeeds,
        data: ZeroCopyRecord,
    },
    AllBorsh {
        seeds: AllBorshSeeds,
        data: MinimalRecord,
    },
    AllZeroCopy {
        seeds: AllZeroCopySeeds,
        data: ZeroCopyRecord,
    },
}

/// Packed variant enum for efficient serialization.
/// Does NOT wrap CompressedAccountData - that wrapper is added by the client library.
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub enum PackedLightAccountVariant {
    MinimalRecord {
        seeds: PackedMinimalRecordSeeds,
        data: PackedMinimalRecord,
    },
    ZeroCopyRecord {
        seeds: PackedZeroCopyRecordSeeds,
        data: PackedZeroCopyRecord,
    },
    AllBorsh {
        seeds: PackedAllBorshSeeds,
        data: PackedMinimalRecord,
    },
    AllZeroCopy {
        seeds: PackedAllZeroCopySeeds,
        data: PackedZeroCopyRecord,
    },
}

// ============================================================================
// DecompressVariant Implementation (MACRO-GENERATED)
// ============================================================================

/// Implementation for PackedLightAccountVariant.
/// Implements on the inner variant type to satisfy orphan rules.
impl<'info> DecompressVariant<AccountInfo<'info>> for PackedLightAccountVariant {
    fn decompress(
        &self,
        tree_info: &PackedStateTreeInfo,
        pda_account: &AccountInfo<'info>,
        ctx: &mut DecompressCtx<'_, AccountInfo<'info>>,
    ) -> std::result::Result<(), LightPdaError> {
        let output_queue_index = ctx.output_queue_index;
        match self {
            PackedLightAccountVariant::MinimalRecord { seeds, data } => {
                let packed_data = PackedMinimalRecordVariant {
                    seeds: seeds.clone(),
                    data: data.clone(),
                };
                prepare_account_for_decompression::<4, PackedMinimalRecordVariant, AccountInfo<'info>>(
                    &packed_data,
                    tree_info,
                    output_queue_index,
                    pda_account,
                    ctx,
                )
            }
            PackedLightAccountVariant::ZeroCopyRecord { seeds, data } => {
                let packed_data = PackedZeroCopyRecordVariant {
                    seeds: seeds.clone(),
                    data: data.clone(),
                };
                prepare_account_for_decompression::<4, PackedZeroCopyRecordVariant, AccountInfo<'info>>(
                    &packed_data,
                    tree_info,
                    output_queue_index,
                    pda_account,
                    ctx,
                )
            }
            PackedLightAccountVariant::AllBorsh { seeds, data } => {
                let packed_data = PackedAllBorshVariant {
                    seeds: seeds.clone(),
                    data: data.clone(),
                };
                prepare_account_for_decompression::<3, PackedAllBorshVariant, AccountInfo<'info>>(
                    &packed_data,
                    tree_info,
                    output_queue_index,
                    pda_account,
                    ctx,
                )
            }
            PackedLightAccountVariant::AllZeroCopy { seeds, data } => {
                let packed_data = PackedAllZeroCopyVariant {
                    seeds: seeds.clone(),
                    data: data.clone(),
                };
                prepare_account_for_decompression::<3, PackedAllZeroCopyVariant, AccountInfo<'info>>(
                    &packed_data,
                    tree_info,
                    output_queue_index,
                    pda_account,
                    ctx,
                )
            }
        }
    }
}
