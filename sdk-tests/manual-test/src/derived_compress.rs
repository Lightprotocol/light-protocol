//! Macro-derived compress and close implementation.
//!
//! This module contains the code that would be generated by the `#[light_program]` macro.
//! The dispatch function handles type-specific deserialization and compression.

use std::marker::PhantomData;

use anchor_lang::prelude::*;
use light_sdk::{
    interface::{
        prepare_account_for_compression, process_compress_pda_accounts_idempotent, CompressCtx,
    },
    LightDiscriminator,
};
use light_sdk_types::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress;
use solana_program_error::ProgramError;

use crate::{account_loader::ZeroCopyRecord, pda::MinimalRecord};

/// Accounts struct for compress instruction.
/// Uses PhantomData for the `<'info>` lifetime so Anchor's CPI codegen works.
/// All accounts are passed via remaining_accounts.
pub struct CompressAndClose<'info>(PhantomData<&'info ()>);

impl<'info> anchor_lang::Accounts<'info, CompressAndCloseBumps> for CompressAndClose<'info> {
    fn try_accounts(
        _program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        _accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<'info>],
        _ix_data: &[u8],
        _bumps: &mut CompressAndCloseBumps,
        _reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        Ok(CompressAndClose(PhantomData))
    }
}

#[derive(Debug, Default)]
pub struct CompressAndCloseBumps {}

impl<'info> anchor_lang::Bumps for CompressAndClose<'info> {
    type Bumps = CompressAndCloseBumps;
}

impl<'info> anchor_lang::ToAccountInfos<'info> for CompressAndClose<'info> {
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        Vec::new()
    }
}

impl<'info> anchor_lang::ToAccountMetas for CompressAndClose<'info> {
    fn to_account_metas(
        &self,
        _is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        Vec::new()
    }
}

impl<'info> anchor_lang::AccountsExit<'info> for CompressAndClose<'info> {
    fn exit(
        &self,
        _program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        Ok(())
    }
}

#[cfg(feature = "idl-build")]
impl<'info> CompressAndClose<'info> {
    pub fn __anchor_private_gen_idl_accounts(
        _accounts: &mut std::collections::BTreeMap<String, anchor_lang::idl::types::IdlAccount>,
        _types: &mut std::collections::BTreeMap<String, anchor_lang::idl::types::IdlTypeDef>,
    ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
        Vec::new()
    }
}

pub(crate) mod __client_accounts_compress_and_close {
    use super::*;
    pub struct CompressAndClose<'info>(PhantomData<&'info ()>);
    impl<'info> borsh::ser::BorshSerialize for CompressAndClose<'info> {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            _writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl<'info> anchor_lang::ToAccountMetas for CompressAndClose<'info> {
        fn to_account_metas(
            &self,
            _is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            Vec::new()
        }
    }
}

pub(crate) mod __cpi_client_accounts_compress_and_close {
    use super::*;
    pub struct CompressAndClose<'info>(PhantomData<&'info ()>);
    impl<'info> anchor_lang::ToAccountMetas for CompressAndClose<'info> {
        fn to_account_metas(
            &self,
            _is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            Vec::new()
        }
    }
    impl<'info> anchor_lang::ToAccountInfos<'info> for CompressAndClose<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            Vec::new()
        }
    }
}

/// MACRO-GENERATED: Discriminator-based dispatch function.
///
/// For each account type, this function:
/// 1. Reads the discriminator from account data
/// 2. Deserializes the account based on discriminator
/// 3. Calls prepare_account_for_compression with the deserialized data
fn compress_dispatch<'info>(
    account_info: &AccountInfo<'info>,
    meta: &CompressedAccountMetaNoLamportsNoAddress,
    index: usize,
    ctx: &mut CompressCtx<'_, 'info>,
) -> std::result::Result<(), ProgramError> {
    let data = account_info.try_borrow_data()?;

    // Read discriminator from first 8 bytes
    let discriminator: [u8; 8] = data[..8]
        .try_into()
        .map_err(|_| ProgramError::InvalidAccountData)?;

    match discriminator {
        d if d == MinimalRecord::LIGHT_DISCRIMINATOR => {
            // Borsh path: deserialize using try_from_slice
            let mut account_data = MinimalRecord::try_from_slice(&data[8..])
                .map_err(|_| ProgramError::InvalidAccountData)?;
            drop(data);

            // Call prepare with deserialized data
            prepare_account_for_compression(account_info, &mut account_data, meta, index, ctx)
        }
        d if d == ZeroCopyRecord::LIGHT_DISCRIMINATOR => {
            // Pod/Zero-copy path: read using bytemuck
            // The data is in fixed Pod layout, so we can directly cast it
            let record_bytes = &data[8..8 + core::mem::size_of::<ZeroCopyRecord>()];
            let mut account_data: ZeroCopyRecord = *bytemuck::from_bytes(record_bytes);
            drop(data);

            // Same prepare function works - hashing uses try_to_vec() which ZeroCopyRecord supports
            // via its AnchorSerialize implementation
            prepare_account_for_compression(account_info, &mut account_data, meta, index, ctx)
        }
        // Unknown discriminator - skip (not an error, could be different account type)
        _ => Ok(()),
    }
}

/// MACRO-GENERATED: Process handler - just forwards to SDK function with dispatch.
pub fn process_compress_and_close<'info>(
    remaining_accounts: &[AccountInfo<'info>],
    instruction_data: &[u8],
) -> Result<()> {
    process_compress_pda_accounts_idempotent(
        remaining_accounts,
        instruction_data,
        compress_dispatch,
        crate::LIGHT_CPI_SIGNER,
        &crate::ID,
    )
    .map_err(Into::into)
}
