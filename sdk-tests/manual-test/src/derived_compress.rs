//! Macro-derived compress and close implementation.
//!
//! This module contains the code that would be generated by the `#[light_program]` macro.
//! The dispatch function handles type-specific deserialization and compression.

use anchor_lang::prelude::*;
use light_sdk::LightDiscriminator;
use light_sdk_types::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress;
use solana_program_error::ProgramError;

use crate::account_loader::ZeroCopyRecord;
use crate::pda::MinimalRecord;
use light_sdk::interface::{
    prepare_account_for_compression, process_compress_pda_accounts_idempotent, CompressCtx,
};

/// Empty Accounts struct - everything in remaining_accounts.
///
/// MACRO-GENERATED: This struct is the same for all programs.
#[derive(Accounts)]
pub struct CompressAndClose {}

/// MACRO-GENERATED: Discriminator-based dispatch function.
///
/// For each account type, this function:
/// 1. Reads the discriminator from account data
/// 2. Deserializes the account based on discriminator
/// 3. Calls prepare_account_for_compression with the deserialized data
fn compress_dispatch<'info>(
    account_info: &AccountInfo<'info>,
    meta: &CompressedAccountMetaNoLamportsNoAddress,
    index: usize,
    ctx: &mut CompressCtx<'_, 'info>,
) -> std::result::Result<(), ProgramError> {
    let data = account_info.try_borrow_data()?;

    // Read discriminator from first 8 bytes
    let discriminator: [u8; 8] = data[..8]
        .try_into()
        .map_err(|_| ProgramError::InvalidAccountData)?;

    match discriminator {
        d if d == MinimalRecord::LIGHT_DISCRIMINATOR => {
            // Borsh path: deserialize using try_from_slice
            let mut account_data = MinimalRecord::try_from_slice(&data[8..])
                .map_err(|_| ProgramError::InvalidAccountData)?;
            drop(data);

            // Call prepare with deserialized data
            prepare_account_for_compression(account_info, &mut account_data, meta, index, ctx)
        }
        d if d == ZeroCopyRecord::LIGHT_DISCRIMINATOR => {
            // Pod/Zero-copy path: read using bytemuck
            // The data is in fixed Pod layout, so we can directly cast it
            let record_bytes = &data[8..8 + core::mem::size_of::<ZeroCopyRecord>()];
            let mut account_data: ZeroCopyRecord = *bytemuck::from_bytes(record_bytes);
            drop(data);

            // Same prepare function works - hashing uses try_to_vec() which ZeroCopyRecord supports
            // via its AnchorSerialize implementation
            prepare_account_for_compression(account_info, &mut account_data, meta, index, ctx)
        }
        // Unknown discriminator - skip (not an error, could be different account type)
        _ => Ok(()),
    }
}

/// MACRO-GENERATED: Process handler - just forwards to SDK function with dispatch.
pub fn process_compress_and_close<'info>(
    remaining_accounts: &[AccountInfo<'info>],
    instruction_data: &[u8],
) -> Result<()> {
    process_compress_pda_accounts_idempotent(
        remaining_accounts,
        instruction_data,
        compress_dispatch,
        crate::LIGHT_CPI_SIGNER,
        &crate::ID,
    )
    .map_err(Into::into)
}
