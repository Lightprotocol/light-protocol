//! Macro-derived compress and close implementation.
//!
//! This module contains the code that would be generated by the `#[light_program]` macro.
//! The dispatch function handles type-specific deserialization and compression.

use anchor_lang::prelude::*;
use light_sdk::LightDiscriminator;
use light_sdk_types::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress;
use solana_program_error::ProgramError;

use crate::pda::MinimalRecord;
use crate::sdk_functions::compress::{
    prepare_account_for_compression, process_compress_pda_accounts_idempotent, CompressCtx,
};

/// Empty Accounts struct - everything in remaining_accounts.
///
/// MACRO-GENERATED: This struct is the same for all programs.
#[derive(Accounts)]
pub struct CompressAndClose {}

/// MACRO-GENERATED: Discriminator-based dispatch function.
///
/// For each account type, this function:
/// 1. Reads the discriminator from account data
/// 2. Deserializes the account based on discriminator
/// 3. Calls prepare_account_for_compression with the deserialized data
fn compress_dispatch<'info>(
    account_info: &AccountInfo<'info>,
    meta: &CompressedAccountMetaNoLamportsNoAddress,
    index: usize,
    ctx: &mut CompressCtx<'_, 'info>,
) -> std::result::Result<(), ProgramError> {
    let data = account_info.try_borrow_data()?;

    // Read discriminator from first 8 bytes
    let discriminator: [u8; 8] = data[..8]
        .try_into()
        .map_err(|_| ProgramError::InvalidAccountData)?;

    match discriminator {
        d if d == MinimalRecord::LIGHT_DISCRIMINATOR => {
            // 1. Deserialize account data
            let mut account_data = MinimalRecord::try_from_slice(&data[8..])
                .map_err(|_| ProgramError::InvalidAccountData)?;
            drop(data);

            // 2. Call prepare with deserialized data
            prepare_account_for_compression(account_info, &mut account_data, meta, index, ctx)
        }
        // MACRO-GENERATED: Additional arms for other account types would go here.
        // Example (if we had another type):
        //
        // d if d == OtherRecord::LIGHT_DISCRIMINATOR => {
        //     let mut account_data = OtherRecord::try_from_slice(&data[8..])
        //         .map_err(|_| ProgramError::InvalidAccountData)?;
        //     drop(data);
        //     prepare_account_for_compression(account_info, &mut account_data, meta, index, ctx)
        // }

        // Unknown discriminator - skip (not an error, could be different account type)
        _ => Ok(()),
    }
}

/// MACRO-GENERATED: Process handler - just forwards to SDK function with dispatch.
pub fn process_compress_and_close<'info>(
    remaining_accounts: &[AccountInfo<'info>],
    instruction_data: &[u8],
) -> Result<()> {
    process_compress_pda_accounts_idempotent(
        remaining_accounts,
        instruction_data,
        compress_dispatch,
        crate::LIGHT_CPI_SIGNER,
        &crate::ID,
    )
    .map_err(Into::into)
}
