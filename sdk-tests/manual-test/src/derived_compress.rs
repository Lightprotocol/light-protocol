//! Macro-derived compress and close implementation.
//!
//! This module contains the code that would be generated by the `#[light_program]` macro.
//! It includes:
//! - `CompressAndClose` accounts struct
//! - `CompressContext` trait implementation with discriminator matching
//! - `process_compress_and_close` handler

use anchor_lang::prelude::*;
use light_compressed_account::instruction_data::with_account_info::CompressedAccountInfo;
use light_sdk::{
    cpi::v2::CpiAccounts,
    interface::{
        compress_runtime::{process_compress_pda_accounts_idempotent, CompressContext},
        LightConfig,
    },
    LightDiscriminator,
};
use light_sdk_types::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress;
use solana_program_error::ProgramError;

use crate::pda::MinimalRecord;
use crate::sdk_functions::compress::{prepare_account_for_compression, CompressAndCloseParams};

/// Accounts for compress_and_close instruction.
///
/// MACRO-GENERATED: This struct is the same for all programs.
#[derive(Accounts)]
pub struct CompressAndClose<'info> {
    #[account(mut)]
    pub fee_payer: Signer<'info>,

    /// CHECK: Compression config PDA
    pub config: AccountInfo<'info>,

    /// CHECK: Rent sponsor from config
    #[account(mut)]
    pub rent_sponsor: AccountInfo<'info>,

    /// Compression authority (must match config)
    pub compression_authority: Signer<'info>,

    pub system_program: Program<'info, System>,
}

impl<'info> CompressContext<'info> for CompressAndClose<'info> {
    fn fee_payer(&self) -> &AccountInfo<'info> {
        &self.fee_payer
    }

    fn config(&self) -> &AccountInfo<'info> {
        &self.config
    }

    fn rent_sponsor(&self) -> &AccountInfo<'info> {
        &self.rent_sponsor
    }

    fn compression_authority(&self) -> &AccountInfo<'info> {
        &self.compression_authority
    }

    /// Compress a PDA account based on its discriminator.
    ///
    /// MACRO-GENERATED: This method dispatches to the correct deserialization
    /// logic based on the account's 8-byte discriminator. Each match arm is
    /// generated for types marked with `#[light_account]`.
    fn compress_pda_account(
        &self,
        account_info: &AccountInfo<'info>,
        meta: &CompressedAccountMetaNoLamportsNoAddress,
        cpi_accounts: &CpiAccounts<'_, 'info>,
        compression_config: &LightConfig,
        program_id: &Pubkey,
    ) -> std::result::Result<Option<CompressedAccountInfo>, ProgramError> {
        let data = account_info.try_borrow_data()?;

        // Read discriminator from first 8 bytes
        let discriminator: [u8; 8] = data[..8]
            .try_into()
            .map_err(|_| ProgramError::InvalidAccountData)?;

        // Match discriminator to determine account type and deserialize accordingly.
        // MACRO-GENERATED: One arm per #[light_account] type in the program.
        match discriminator {
            // MinimalRecord
            d if d == MinimalRecord::LIGHT_DISCRIMINATOR => {
                let mut account_data = MinimalRecord::try_from_slice(&data[8..])
                    .map_err(|_| ProgramError::InvalidAccountData)?;
                drop(data);

                prepare_account_for_compression(
                    program_id,
                    account_info,
                    &mut account_data,
                    meta,
                    cpi_accounts,
                    &compression_config.address_space,
                )
                .map(Some)
            }

            // MACRO-GENERATED: Additional match arms for other account types would go here.
            // Example (if we had another type):
            //
            // d if d == OtherRecord::LIGHT_DISCRIMINATOR => {
            //     let mut account_data = OtherRecord::try_from_slice(&data[8..])
            //         .map_err(|_| ProgramError::InvalidAccountData)?;
            //     drop(data);
            //
            //     prepare_account_for_compression(
            //         program_id,
            //         account_info,
            //         &mut account_data,
            //         meta,
            //         cpi_accounts,
            //         &compression_config.address_space,
            //     )
            //     .map(Some)
            // }

            // Unknown discriminator - skip this account (not a compressible type we know)
            _ => Ok(None),
        }
    }
}

/// Process compress_and_close instruction.
///
/// MACRO-GENERATED: This handler delegates to the SDK's runtime function.
pub fn process_compress_and_close<'info>(
    ctx: Context<'_, '_, '_, 'info, CompressAndClose<'info>>,
    params: CompressAndCloseParams,
) -> Result<()> {
    process_compress_pda_accounts_idempotent(
        ctx.accounts,
        ctx.remaining_accounts,
        params.compressed_accounts,
        params.system_accounts_offset,
        crate::LIGHT_CPI_SIGNER,
        &crate::ID,
    )
    .map_err(Into::into)
}
