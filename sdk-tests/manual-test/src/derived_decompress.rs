//! Macro-derived decompress implementation.
//!
//! This module contains the code that would be generated by the `#[light_program]` macro.
//! With the trait-based dispatch, this module is minimal - just specifies the variant type.

use std::marker::PhantomData;

use anchor_lang::prelude::*;
use light_sdk::interface::process_decompress_pda_accounts_idempotent;

use crate::derived_variants::PackedLightAccountVariant;

/// Accounts struct for decompress instruction.
/// Uses PhantomData for the `<'info>` lifetime so Anchor's CPI codegen works.
/// All accounts are passed via remaining_accounts.
pub struct DecompressIdempotent<'info>(PhantomData<&'info ()>);

impl<'info> anchor_lang::Accounts<'info, DecompressIdempotentBumps>
    for DecompressIdempotent<'info>
{
    fn try_accounts(
        _program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        _accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<'info>],
        _ix_data: &[u8],
        _bumps: &mut DecompressIdempotentBumps,
        _reallocs: &mut std::collections::BTreeSet<anchor_lang::solana_program::pubkey::Pubkey>,
    ) -> anchor_lang::Result<Self> {
        Ok(DecompressIdempotent(PhantomData))
    }
}

#[derive(Debug, Default)]
pub struct DecompressIdempotentBumps {}

impl<'info> anchor_lang::Bumps for DecompressIdempotent<'info> {
    type Bumps = DecompressIdempotentBumps;
}

impl<'info> anchor_lang::ToAccountInfos<'info> for DecompressIdempotent<'info> {
    fn to_account_infos(
        &self,
    ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
        Vec::new()
    }
}

impl<'info> anchor_lang::ToAccountMetas for DecompressIdempotent<'info> {
    fn to_account_metas(
        &self,
        _is_signer: Option<bool>,
    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
        Vec::new()
    }
}

impl<'info> anchor_lang::AccountsExit<'info> for DecompressIdempotent<'info> {
    fn exit(
        &self,
        _program_id: &anchor_lang::solana_program::pubkey::Pubkey,
    ) -> anchor_lang::Result<()> {
        Ok(())
    }
}

#[cfg(feature = "idl-build")]
impl<'info> DecompressIdempotent<'info> {
    pub fn __anchor_private_gen_idl_accounts(
        _accounts: &mut std::collections::BTreeMap<String, anchor_lang::idl::types::IdlAccount>,
        _types: &mut std::collections::BTreeMap<String, anchor_lang::idl::types::IdlTypeDef>,
    ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
        Vec::new()
    }
}

pub(crate) mod __client_accounts_decompress_idempotent {
    use super::*;
    pub struct DecompressIdempotent<'info>(PhantomData<&'info ()>);
    impl<'info> borsh::ser::BorshSerialize for DecompressIdempotent<'info> {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            _writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            Ok(())
        }
    }
    impl<'info> anchor_lang::ToAccountMetas for DecompressIdempotent<'info> {
        fn to_account_metas(
            &self,
            _is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            Vec::new()
        }
    }
}

pub(crate) mod __cpi_client_accounts_decompress_idempotent {
    use super::*;
    pub struct DecompressIdempotent<'info>(PhantomData<&'info ()>);
    impl<'info> anchor_lang::ToAccountMetas for DecompressIdempotent<'info> {
        fn to_account_metas(
            &self,
            _is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            Vec::new()
        }
    }
    impl<'info> anchor_lang::ToAccountInfos<'info> for DecompressIdempotent<'info> {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            Vec::new()
        }
    }
}

/// MACRO-GENERATED: Process handler - forwards to SDK function with program's variant type.
pub fn process_decompress_idempotent<'info>(
    remaining_accounts: &[AccountInfo<'info>],
    instruction_data: &[u8],
) -> Result<()> {
    process_decompress_pda_accounts_idempotent::<PackedLightAccountVariant>(
        remaining_accounts,
        instruction_data,
        crate::LIGHT_CPI_SIGNER,
        &crate::ID,
    )
    .map_err(Into::into)
}
