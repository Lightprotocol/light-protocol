//! Macro-derived decompress implementation.
//!
//! This module contains the code that would be generated by the `#[light_program]` macro.
//! The dispatch function handles type-specific variant unpacking and seed derivation.

use anchor_lang::prelude::*;
use light_sdk::LightDiscriminator;
use light_sdk_types::instruction::account_meta::CompressedAccountMeta;
use solana_program_error::ProgramError;

use crate::pda::derived_accounts::PackedMinimalRecordVariant;
use crate::pda::MinimalRecord;
use crate::sdk_functions::decompress::{
    prepare_account_for_decompression, process_decompress_pda_accounts_idempotent, DecompressCtx,
};
use crate::traits::PackedLightAccountVariant;

/// Empty Accounts struct - everything in remaining_accounts.
///
/// MACRO-GENERATED: This struct is the same for all programs.
#[derive(Accounts)]
pub struct DecompressIdempotent {}

/// MACRO-GENERATED: Discriminator-based dispatch function.
///
/// For each account type, this function:
/// 1. Deserializes the packed variant (seeds + data)
/// 2. Extracts signer seeds via variant.seed_refs_with_bump()
/// 3. Unpacks the data
/// 4. Calls prepare_account_for_decompression with the seeds
fn decompress_dispatch<'info>(
    discriminator: [u8; 8],
    packed_variant: &[u8],
    pda_account: &AccountInfo<'info>,
    meta: &CompressedAccountMeta,
    ctx: &mut DecompressCtx<'_, 'info>,
) -> std::result::Result<(), ProgramError> {
    match discriminator {
        d if d == MinimalRecord::LIGHT_DISCRIMINATOR => {
            // 1. Deserialize packed variant
            let variant = PackedMinimalRecordVariant::try_from_slice(packed_variant)
                .map_err(|_| ProgramError::InvalidAccountData)?;

            // 2. Get bump and prepare bump storage
            let bump = variant.bump();
            let bump_storage = [bump];

            // 3. Get signer seeds
            let seeds = variant.seed_refs_with_bump(ctx.remaining_accounts, &bump_storage)?;

            // 4. Unpack to get the data
            let unpacked = variant.unpack(ctx.remaining_accounts)?;

            // 5. Call prepare with unpacked data and seeds
            prepare_account_for_decompression::<MinimalRecord>(
                unpacked.data.clone(),
                pda_account,
                meta,
                &seeds,
                ctx,
            )
        }
        // MACRO-GENERATED: Additional arms for other account types would go here.
        // Example (if we had another type):
        //
        // d if d == OtherRecord::LIGHT_DISCRIMINATOR => {
        //     let variant = PackedOtherRecordVariant::try_from_slice(packed_variant)?;
        //     let bump_storage = [variant.bump()];
        //     let seeds = variant.seed_refs_with_bump(ctx.remaining_accounts, &bump_storage)?;
        //     let unpacked = variant.unpack(ctx.remaining_accounts)?;
        //     prepare_account_for_decompression::<OtherRecord>(
        //         unpacked.data.clone(), pda_account, meta, &seeds, ctx,
        //     )
        // }

        // Unknown discriminator - skip (not an error, could be different account type)
        _ => Ok(()),
    }
}

/// MACRO-GENERATED: Process handler - just forwards to SDK function with dispatch.
pub fn process_decompress_idempotent<'info>(
    remaining_accounts: &[AccountInfo<'info>],
    instruction_data: &[u8],
) -> Result<()> {
    process_decompress_pda_accounts_idempotent(
        remaining_accounts,
        instruction_data,
        decompress_dispatch,
        crate::LIGHT_CPI_SIGNER,
        &crate::ID,
    )
    .map_err(Into::into)
}
