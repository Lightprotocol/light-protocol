//! Macro-derived decompress implementation.
//!
//! This module contains the code that would be generated by the `#[light_program]` macro.
//! With the trait-based dispatch, this module is minimal - just specifies the variant type.

use light_account_pinocchio::process_decompress_pda_accounts_idempotent;
use pinocchio::{
    account_info::AccountInfo,
    program_error::ProgramError,
    sysvars::{clock::Clock, Sysvar},
};

use crate::derived_variants::PackedLightAccountVariant;

/// MACRO-GENERATED: Process handler - deserializes params and forwards to SDK function.
pub fn process_decompress_idempotent(
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> Result<(), ProgramError> {
    use borsh::BorshDeserialize;
    let params = light_account_pinocchio::DecompressIdempotentParams::<PackedLightAccountVariant>::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;
    let current_slot = Clock::get()
        .map_err(|_| ProgramError::UnsupportedSysvar)?
        .slot;
    process_decompress_pda_accounts_idempotent::<_, PackedLightAccountVariant>(
        accounts,
        &params,
        crate::LIGHT_CPI_SIGNER,
        &crate::ID,
        current_slot,
    )
    .map_err(|e| ProgramError::Custom(u32::from(e)))
}
