use anchor_lang::prelude::*;
use light_sdk::{
    compressible::{compress_account::prepare_account_for_compression, CompressibleConfig},
    cpi::{
        v2::{CpiAccounts, LightSystemProgramCpi},
        InvokeLightSystemProgram, LightCpiInstruction,
    },
    instruction::{account_meta::CompressedAccountMetaNoLamportsNoAddress, ValidityProof},
    LightDiscriminator,
};

/// Auto-generated by compressible_instructions macro.
use crate::{errors::ErrorCode, instruction_accounts::*, state::*, LIGHT_CPI_SIGNER};

pub fn compress_accounts_idempotent<'info>(
    ctx: Context<'_, '_, 'info, 'info, CompressAccountsIdempotent<'info>>,
    proof: ValidityProof,
    compressed_accounts: Vec<CompressedAccountMetaNoLamportsNoAddress>,
    system_accounts_offset: u8,
) -> Result<()> {
    let compression_config = CompressibleConfig::load_checked(&ctx.accounts.config, &crate::ID)?;
    if ctx.accounts.rent_sponsor.key() != compression_config.rent_sponsor {
        msg!(
            "rent recipient passed: {:?}",
            ctx.accounts.rent_sponsor.key()
        );
        msg!(
            "rent recipient config: {:?}",
            compression_config.rent_sponsor
        );
        return Err(ProgramError::from(ErrorCode::RentRecipientMismatch).into());
    }

    let cpi_accounts = CpiAccounts::new(
        ctx.accounts.fee_payer.as_ref(),
        &ctx.remaining_accounts[system_accounts_offset as usize..],
        LIGHT_CPI_SIGNER,
    );

    let system_accounts_end = cpi_accounts.system_accounts_end_offset();
    let solana_accounts = &cpi_accounts.to_account_infos()[system_accounts_end..];

    let mut compressed_pda_infos = Vec::new();
    let mut pda_indices_to_close: Vec<usize> = Vec::new();

    for (i, account_info) in solana_accounts.iter().enumerate() {
        if account_info.data_is_empty() {
            msg!("No data. Account already compressed or uninitialized. Skipping.");
            continue;
        }
        if account_info.owner == &crate::ID {
            let data = account_info.try_borrow_data()?;
            let discriminator = &data[0..8];
            let meta = compressed_accounts[i];

            // TODO: consider CHECKING seeds.
            match discriminator {
                d if d == UserRecord::LIGHT_DISCRIMINATOR => {
                    drop(data);
                    let data_borrow = account_info.try_borrow_data()?;
                    let mut account_data = UserRecord::try_deserialize(&mut &data_borrow[..])?;
                    drop(data_borrow);

                    let compressed_info = prepare_account_for_compression::<UserRecord>(
                        &crate::ID,
                        account_info,
                        &mut account_data,
                        &meta,
                        &cpi_accounts,
                        &compression_config.compression_delay,
                        &compression_config.address_space,
                    )?;

                    compressed_pda_infos.push(compressed_info);
                    pda_indices_to_close.push(i);
                }
                d if d == GameSession::LIGHT_DISCRIMINATOR => {
                    drop(data);
                    let data_borrow = account_info.try_borrow_data()?;
                    let mut account_data = GameSession::try_deserialize(&mut &data_borrow[..])?;
                    drop(data_borrow);

                    let compressed_info = prepare_account_for_compression::<GameSession>(
                        &crate::ID,
                        account_info,
                        &mut account_data,
                        &meta,
                        &cpi_accounts,
                        &compression_config.compression_delay,
                        &compression_config.address_space,
                    )?;

                    compressed_pda_infos.push(compressed_info);
                    pda_indices_to_close.push(i);
                }
                d if d == PlaceholderRecord::LIGHT_DISCRIMINATOR => {
                    drop(data);
                    let data_borrow = account_info.try_borrow_data()?;
                    let mut account_data =
                        PlaceholderRecord::try_deserialize(&mut &data_borrow[..])?;
                    drop(data_borrow);

                    let compressed_info = prepare_account_for_compression::<PlaceholderRecord>(
                        &crate::ID,
                        account_info,
                        &mut account_data,
                        &meta,
                        &cpi_accounts,
                        &compression_config.compression_delay,
                        &compression_config.address_space,
                    )?;

                    compressed_pda_infos.push(compressed_info);
                    pda_indices_to_close.push(i);
                }
                _ => {
                    return Err(ProgramError::from(ErrorCode::InvalidAccountDiscriminator).into());
                }
            }
        }
    }
    let has_pdas = !compressed_pda_infos.is_empty();
    if has_pdas {
        LightSystemProgramCpi::new_cpi(LIGHT_CPI_SIGNER, proof)
            .with_account_infos(&compressed_pda_infos)
            .invoke(cpi_accounts)?;

        // Close
        for idx in pda_indices_to_close.into_iter() {
            let mut info = solana_accounts[idx].clone();
            light_sdk::compressible::close::close(&mut info, ctx.accounts.rent_sponsor.clone())
                .map_err(anchor_lang::prelude::ProgramError::from)?;
        }
    }
    Ok(())
}
