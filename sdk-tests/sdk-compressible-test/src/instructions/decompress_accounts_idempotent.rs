// Auto-generated by compressible_instructions macro.
use anchor_lang::prelude::*;
use light_compressed_token_sdk::ctoken::create_token_account::create_ctoken_account_signed;
use light_sdk::{
    compressible::{
        decompress_idempotent::{
            into_compressed_meta_with_address, prepare_account_for_decompression_idempotent,
        },
        Unpack,
    },
    cpi::{
        v2::{CpiAccounts, LightSystemProgramCpi},
        InvokeLightSystemProgram, LightCpiInstruction,
    },
};
use light_sdk_types::cpi_accounts::CpiAccountsConfig;
use solana_program::program_error::ProgramError;

use crate::{constants::*, errors::ErrorCode, instruction_accounts::*, state::*, LIGHT_CPI_SIGNER};
pub fn decompress_accounts_idempotent<'info>(
    ctx: Context<'_, '_, '_, 'info, DecompressAccountsIdempotent<'info>>,
    proof: light_sdk::instruction::ValidityProof,
    compressed_accounts: Vec<CompressedAccountData>,
    system_accounts_offset: u8,
) -> Result<()> {
    // Helper functions to handle each account type - kept out of main frame
    #[inline(never)]
    #[allow(clippy::too_many_arguments)]
    fn handle_user_record<'b, 'info>(
        data: UserRecord,
        meta: &light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
        solana_accounts: &[AccountInfo<'info>],
        i: usize,
        address_space: Pubkey,
        cpi_accounts: &CpiAccounts<'b, 'info>,
        rent_sponsor: &AccountInfo<'info>,
        out: &mut Vec<
            light_compressed_account::instruction_data::with_account_info::CompressedAccountInfo,
        >,
    ) -> Result<()> {
        let seeds_vec = {
            let seeds: &[&[u8]] = &[USER_RECORD_SEED.as_bytes(), (data.owner).as_ref()];
            let (_pda, bump) = Pubkey::find_program_address(seeds, &crate::ID);
            vec![seeds[0].to_vec(), seeds[1].to_vec(), vec![bump]]
        };
        let seed_refs: Vec<&[u8]> = seeds_vec.iter().map(|v: &Vec<u8>| v.as_slice()).collect();
        let infos = prepare_account_for_decompression_idempotent::<UserRecord>(
            &crate::ID,
            data,
            into_compressed_meta_with_address(meta, &solana_accounts[i], address_space, &crate::ID),
            &solana_accounts[i],
            rent_sponsor,
            cpi_accounts,
            seed_refs.as_slice(),
        )
        .map_err(ProgramError::from)?;
        out.extend(infos);
        Ok(())
    }

    #[inline(never)]
    #[allow(clippy::too_many_arguments)]
    fn handle_game_session<'b, 'info>(
        data: GameSession,
        meta: &light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
        solana_accounts: &[AccountInfo<'info>],
        i: usize,
        address_space: Pubkey,
        cpi_accounts: &CpiAccounts<'b, 'info>,
        rent_sponsor: &AccountInfo<'info>,
        out: &mut Vec<
            light_compressed_account::instruction_data::with_account_info::CompressedAccountInfo,
        >,
    ) -> Result<()> {
        let seed_binding_1 = data.session_id.to_le_bytes();
        let seeds_vec = {
            let seeds: &[&[u8]] = &["game_session".as_bytes(), seed_binding_1.as_ref()];
            let (_pda, bump) = Pubkey::find_program_address(seeds, &crate::ID);
            vec![seeds[0].to_vec(), seeds[1].to_vec(), vec![bump]]
        };
        let seed_refs: Vec<&[u8]> = seeds_vec.iter().map(|v: &Vec<u8>| v.as_slice()).collect();
        let infos = prepare_account_for_decompression_idempotent::<GameSession>(
            &crate::ID,
            data,
            into_compressed_meta_with_address(meta, &solana_accounts[i], address_space, &crate::ID),
            &solana_accounts[i],
            rent_sponsor,
            cpi_accounts,
            seed_refs.as_slice(),
        )
        .map_err(ProgramError::from)?;
        out.extend(infos);
        Ok(())
    }

    #[inline(never)]
    #[allow(clippy::too_many_arguments)]
    fn handle_placeholder_record<'b, 'info>(
        data: PlaceholderRecord,
        meta: &light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
        solana_accounts: &[AccountInfo<'info>],
        i: usize,
        address_space: Pubkey,
        cpi_accounts: &CpiAccounts<'b, 'info>,
        rent_sponsor: &AccountInfo<'info>,
        out: &mut Vec<
            light_compressed_account::instruction_data::with_account_info::CompressedAccountInfo,
        >,
    ) -> Result<()> {
        let seed_binding_1 = data.placeholder_id.to_le_bytes();
        let seeds_vec = {
            let seeds: &[&[u8]] = &["placeholder_record".as_bytes(), seed_binding_1.as_ref()];
            let (_pda, bump) = Pubkey::find_program_address(seeds, &crate::ID);
            vec![seeds[0].to_vec(), seeds[1].to_vec(), vec![bump]]
        };
        let seed_refs: Vec<&[u8]> = seeds_vec.iter().map(|v: &Vec<u8>| v.as_slice()).collect();
        let infos = prepare_account_for_decompression_idempotent::<PlaceholderRecord>(
            &crate::ID,
            data,
            into_compressed_meta_with_address(meta, &solana_accounts[i], address_space, &crate::ID),
            &solana_accounts[i],
            rent_sponsor,
            cpi_accounts,
            seed_refs.as_slice(),
        )
        .map_err(ProgramError::from)?;
        out.extend(infos);
        Ok(())
    }

    #[inline(never)]
    fn check_account_types(compressed_accounts: &[CompressedAccountData]) -> (bool, bool) {
        let (mut has_tokens, mut has_pdas) = (false, false);
        for c in compressed_accounts {
            match c.data {
                CompressedAccountVariant::PackedCTokenData(_) => {
                    has_tokens = true;
                }
                _ => has_pdas = true,
            }
            if has_tokens && has_pdas {
                break;
            }
        }
        (has_tokens, has_pdas)
    }
    /// Helper function to process token decompression - separated to avoid stack overflow
    #[inline(never)]
    #[allow(clippy::too_many_arguments, clippy::extra_unused_lifetimes)]
    fn process_tokens<'a, 'b, 'info>(
        accounts: &DecompressAccountsIdempotent<'info>,
        remaining_accounts: &[anchor_lang::prelude::AccountInfo<'info>],
        fee_payer: &anchor_lang::prelude::AccountInfo<'info>,
        ctoken_program: &anchor_lang::prelude::UncheckedAccount<'info>,
        ctoken_rent_sponsor: &anchor_lang::prelude::AccountInfo<'info>,
        ctoken_cpi_authority: &anchor_lang::prelude::UncheckedAccount<'info>,
        ctoken_config: &anchor_lang::prelude::AccountInfo<'info>,
        config: &anchor_lang::prelude::AccountInfo<'info>,
        ctoken_accounts: Vec<(
            light_compressed_token_sdk::compat::PackedCTokenData<CTokenAccountVariant>,
            light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
        )>,
        proof: light_sdk::instruction::ValidityProof,
        cpi_accounts: &CpiAccounts<'b, 'info>,
        post_system_accounts: &[anchor_lang::prelude::AccountInfo<'info>],
        has_pdas: bool,
    ) -> Result<()> {
        let mut token_decompress_indices: Box<
            Vec<light_compressed_token_sdk::compressed_token::decompress_full::DecompressFullIndices>,
        > = Box::new(Vec::with_capacity(ctoken_accounts.len()));
        // Collect per-owner signer seed groups; invoke_signed requires one seed group per PDA signer
        let mut token_signers_seed_groups: Vec<Vec<Vec<u8>>> =
            Vec::with_capacity(ctoken_accounts.len());
        let packed_accounts = post_system_accounts;
        use crate::seeds::ctoken_seed_system::{CTokenSeedContext, CTokenSeedProvider};
        let seed_context = CTokenSeedContext {
            accounts,
            remaining_accounts,
        };
        let authority = cpi_accounts
            .authority()
            .map_err(|_| anchor_lang::prelude::ProgramError::from(ErrorCode::MissingAuthority))?;
        let cpi_context = cpi_accounts
            .cpi_context()
            .map_err(|_| anchor_lang::prelude::ProgramError::from(ErrorCode::MissingCpiContext))?;

        for (token_data, meta) in ctoken_accounts.into_iter() {
            let owner_index: u8 = token_data.token_data.owner;
            let mint_index: u8 = token_data.token_data.mint;
            let mint_info = packed_accounts[mint_index as usize].to_account_info();
            let owner_info = packed_accounts[owner_index as usize].to_account_info();
            let (ctoken_signer_seeds, derived_token_account_address) =
                token_data.variant.get_seeds(&seed_context);
            {
                if derived_token_account_address != *owner_info.key {
                    msg!(
                        "derived_token_account_address: {:?}",
                        derived_token_account_address
                    );
                    msg!("owner_info.key: {:?}", owner_info.key);
                    return Err(ProgramError::from(ErrorCode::DerivedTokenAccountMismatch).into());
                }

                // Convert Vec<Vec<u8>> to &[&[&[u8]]]
                let seed_refs: Vec<&[u8]> =
                    ctoken_signer_seeds.iter().map(|s| s.as_slice()).collect();
                let seeds_slice: &[&[u8]] = &seed_refs;

                create_ctoken_account_signed(
                    crate::ID,
                    fee_payer.clone().to_account_info(),
                    owner_info.clone(),
                    mint_info.clone(),
                    *authority.clone().to_account_info().key,
                    seeds_slice,
                    ctoken_rent_sponsor.clone().to_account_info(),
                    ctoken_config.to_account_info(),
                    Some(2), // TODO: make this configurable
                    None,    // TODO: make this configurable
                )?;
            }

            // Construct MultiInputTokenDataWithContext from token data and meta
            let source =
                light_ctoken_types::instructions::transfer2::MultiInputTokenDataWithContext {
                    owner: token_data.token_data.owner,
                    amount: token_data.token_data.amount,
                    has_delegate: token_data.token_data.has_delegate,
                    delegate: token_data.token_data.delegate,
                    mint: token_data.token_data.mint,
                    version: token_data.token_data.version,
                    merkle_context: meta.tree_info.into(),
                    root_index: meta.tree_info.root_index,
                };
            let decompress_index =
                light_compressed_token_sdk::compressed_token::decompress_full::DecompressFullIndices {
                    source,
                    destination_index: owner_index,
                };
            token_decompress_indices.push(decompress_index);
            token_signers_seed_groups.push(ctoken_signer_seeds);
        }

        let ctoken_ix =
            light_compressed_token_sdk::compressed_token::decompress_full::decompress_full_ctoken_accounts_with_indices(
                fee_payer.key(),
                proof,
                if has_pdas {
                    Some(cpi_context.key())
                } else {
                    None
                },
                &token_decompress_indices,
                packed_accounts,
            )
            .map_err(anchor_lang::prelude::ProgramError::from)?;
        {
            let mut all_account_infos = <[_]>::into_vec(Box::new([fee_payer.to_account_info()]));
            all_account_infos.extend(ctoken_cpi_authority.to_account_infos());
            all_account_infos.extend(ctoken_program.to_account_infos());
            all_account_infos.extend(ctoken_rent_sponsor.to_account_infos());
            all_account_infos.extend(config.to_account_infos());
            all_account_infos.extend(cpi_accounts.to_account_infos());
            // Build &[&[&[u8]]] where each inner slice is a distinct PDA seed group
            let signer_seed_refs: Vec<Vec<&[u8]>> = token_signers_seed_groups
                .iter()
                .map(|group| group.iter().map(|s| s.as_slice()).collect())
                .collect();
            let signer_seed_slices: Vec<&[&[u8]]> =
                signer_seed_refs.iter().map(|g| g.as_slice()).collect();

            anchor_lang::solana_program::program::invoke_signed(
                &ctoken_ix,
                all_account_infos.as_slice(),
                signer_seed_slices.as_slice(),
            )?;
        }
        Ok(())
    }

    let compression_config = light_sdk::compressible::CompressibleConfig::load_checked(
        &ctx.accounts.config,
        &crate::ID,
    )?;
    let address_space = compression_config.address_space[0];

    let (has_tokens, has_pdas) = check_account_types(&compressed_accounts);
    if !has_tokens && !has_pdas {
        return Ok(());
    }

    // Pre-count for exact alloc.
    let (mut token_count, mut pda_count) = (0usize, 0usize);
    for c in &compressed_accounts {
        match c.data {
            CompressedAccountVariant::PackedCTokenData(_) => token_count += 1,
            _ => pda_count += 1,
        }
    }

    let mut ctoken_accounts: Vec<(
        light_compressed_token_sdk::compat::PackedCTokenData<CTokenAccountVariant>,
        light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
    )> = Vec::with_capacity(token_count);
    let mut compressed_pda_infos = Vec::with_capacity(pda_count);

    let cpi_accounts = if has_tokens {
        CpiAccounts::new_with_config(
            ctx.accounts.fee_payer.as_ref(),
            &ctx.remaining_accounts[system_accounts_offset as usize..],
            CpiAccountsConfig::new_with_cpi_context(LIGHT_CPI_SIGNER),
        )
    } else {
        CpiAccounts::new(
            ctx.accounts.fee_payer.as_ref(),
            &ctx.remaining_accounts[system_accounts_offset as usize..],
            LIGHT_CPI_SIGNER,
        )
    };

    let pda_accounts_start = ctx.remaining_accounts.len() - compressed_accounts.len();
    let solana_accounts = &ctx.remaining_accounts[pda_accounts_start..];
    let post_system_offset = cpi_accounts.system_accounts_end_offset();
    let all_infos = cpi_accounts.account_infos();
    let post_system_accounts = &all_infos[post_system_offset..];
    for (i, compressed_data) in compressed_accounts.into_iter().enumerate() {
        let unpacked_data = compressed_data.data.unpack(post_system_accounts)?;
        match unpacked_data {
            CompressedAccountVariant::UserRecord(data) => {
                handle_user_record(
                    data,
                    &compressed_data.meta,
                    solana_accounts,
                    i,
                    address_space,
                    &cpi_accounts,
                    &ctx.accounts.rent_sponsor,
                    &mut compressed_pda_infos,
                )?;
            }
            CompressedAccountVariant::GameSession(data) => {
                handle_game_session(
                    data,
                    &compressed_data.meta,
                    solana_accounts,
                    i,
                    address_space,
                    &cpi_accounts,
                    &ctx.accounts.rent_sponsor,
                    &mut compressed_pda_infos,
                )?;
            }
            CompressedAccountVariant::PlaceholderRecord(data) => {
                handle_placeholder_record(
                    data,
                    &compressed_data.meta,
                    solana_accounts,
                    i,
                    address_space,
                    &cpi_accounts,
                    &ctx.accounts.rent_sponsor,
                    &mut compressed_pda_infos,
                )?;
            }
            CompressedAccountVariant::PackedCTokenData(data) => {
                ctoken_accounts.push((data, compressed_data.meta));
            }
            CompressedAccountVariant::PackedUserRecord(_)
            | CompressedAccountVariant::PackedGameSession(_)
            | CompressedAccountVariant::PackedPlaceholderRecord(_)
            | CompressedAccountVariant::CTokenData(_) => {
                panic!("internal error: entered unreachable code");
            }
        }
    }
    // return if no uninitialized accounts.
    let has_pdas = !compressed_pda_infos.is_empty();
    let has_tokens = !ctoken_accounts.is_empty();
    if !has_pdas && !has_tokens {
        return Ok(());
    }
    let fee_payer = ctx.accounts.fee_payer.as_ref();

    // init PDAs.
    if has_pdas && has_tokens {
        let authority = cpi_accounts
            .authority()
            .map_err(|_| anchor_lang::prelude::ProgramError::from(ErrorCode::MissingAuthority))?;
        let cpi_context = cpi_accounts
            .cpi_context()
            .map_err(|_| anchor_lang::prelude::ProgramError::from(ErrorCode::MissingCpiContext))?;
        let system_cpi_accounts = light_sdk_types::cpi_context_write::CpiContextWriteAccounts {
            fee_payer,
            authority,
            cpi_context,
            cpi_signer: LIGHT_CPI_SIGNER,
        };
        LightSystemProgramCpi::new_cpi(LIGHT_CPI_SIGNER, proof)
            .with_account_infos(&compressed_pda_infos)
            .write_to_cpi_context_first()
            .invoke_write_to_cpi_context_first(system_cpi_accounts)?;
    } else if has_pdas {
        LightSystemProgramCpi::new_cpi(cpi_accounts.config().cpi_signer, proof)
            .with_account_infos(&compressed_pda_infos)
            .invoke(cpi_accounts.clone())?;
    }

    // init tokens.
    if has_tokens {
        let ctoken_program = ctx
            .accounts
            .ctoken_program
            .as_ref()
            .ok_or(ProgramError::NotEnoughAccountKeys)?;
        let ctoken_rent_sponsor = ctx
            .accounts
            .ctoken_rent_sponsor
            .as_ref()
            .ok_or(ProgramError::NotEnoughAccountKeys)?;
        let ctoken_cpi_authority = ctx
            .accounts
            .ctoken_cpi_authority
            .as_ref()
            .ok_or(ProgramError::NotEnoughAccountKeys)?;
        let ctoken_config = ctx
            .accounts
            .ctoken_config
            .as_ref()
            .ok_or(ProgramError::NotEnoughAccountKeys)?;

        process_tokens(
            ctx.accounts,
            ctx.remaining_accounts,
            fee_payer,
            ctoken_program,
            ctoken_rent_sponsor,
            ctoken_cpi_authority,
            ctoken_config,
            &ctx.accounts.config,
            ctoken_accounts,
            proof,
            &cpi_accounts,
            post_system_accounts,
            has_pdas,
        )?;
    }
    Ok(())
}
