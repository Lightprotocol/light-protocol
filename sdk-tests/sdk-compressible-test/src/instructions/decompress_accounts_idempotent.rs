// Auto-generated by compressible_instructions macro.
use anchor_lang::prelude::*;
use light_ctoken_sdk::ctoken::{
    CompressibleParamsCpi, CreateCTokenAccountCpi, DecompressCMintCpiWithContext,
    SystemAccountInfos, create_decompress_mint_cpi_context_first,
    create_decompress_mint_cpi_context_set, create_decompress_mint_cpi_context_execute,
    find_cmint_address,
};
use light_ctoken_sdk::constants::CPI_AUTHORITY_PDA;
use light_sdk::{
    compressible::{
        decompress_idempotent::{
            into_compressed_meta_with_address, prepare_account_for_decompression_idempotent,
        },
        Unpack,
    },
    cpi::{
        v2::{CpiAccounts, LightSystemProgramCpi},
        InvokeLightSystemProgram, LightCpiInstruction,
    },
};
use light_sdk_types::cpi_accounts::CpiAccountsConfig;
use solana_program::program_error::ProgramError;

use crate::{constants::*, errors::ErrorCode, instruction_accounts::*, state::*, LIGHT_CPI_SIGNER};
pub fn decompress_accounts_idempotent<'info>(
    ctx: Context<'_, '_, '_, 'info, DecompressAccountsIdempotent<'info>>,
    proof: light_sdk::instruction::ValidityProof,
    compressed_accounts: Vec<CompressedAccountData>,
    system_accounts_offset: u8,
) -> Result<()> {
    // Helper functions to handle each account type - kept out of main frame
    #[inline(never)]
    #[allow(clippy::too_many_arguments)]
    fn handle_user_record<'b, 'info>(
        data: UserRecord,
        meta: &light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
        solana_accounts: &[AccountInfo<'info>],
        i: usize,
        address_space: Pubkey,
        cpi_accounts: &CpiAccounts<'b, 'info>,
        rent_sponsor: &AccountInfo<'info>,
        out: &mut Vec<
            light_compressed_account::instruction_data::with_account_info::CompressedAccountInfo,
        >,
    ) -> Result<()> {
        let seeds_vec = {
            let seeds: &[&[u8]] = &[USER_RECORD_SEED.as_bytes(), (data.owner).as_ref()];
            let (_pda, bump) = Pubkey::find_program_address(seeds, &crate::ID);
            vec![seeds[0].to_vec(), seeds[1].to_vec(), vec![bump]]
        };
        let seed_refs: Vec<&[u8]> = seeds_vec.iter().map(|v: &Vec<u8>| v.as_slice()).collect();
        let infos = prepare_account_for_decompression_idempotent::<UserRecord>(
            &crate::ID,
            data,
            into_compressed_meta_with_address(meta, &solana_accounts[i], address_space, &crate::ID),
            &solana_accounts[i],
            rent_sponsor,
            cpi_accounts,
            seed_refs.as_slice(),
        )
        .map_err(ProgramError::from)?;
        out.extend(infos);
        Ok(())
    }

    #[inline(never)]
    #[allow(clippy::too_many_arguments)]
    fn handle_game_session<'b, 'info>(
        data: GameSession,
        meta: &light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
        solana_accounts: &[AccountInfo<'info>],
        i: usize,
        address_space: Pubkey,
        cpi_accounts: &CpiAccounts<'b, 'info>,
        rent_sponsor: &AccountInfo<'info>,
        out: &mut Vec<
            light_compressed_account::instruction_data::with_account_info::CompressedAccountInfo,
        >,
    ) -> Result<()> {
        let seed_binding_1 = data.session_id.to_le_bytes();
        let seeds_vec = {
            let seeds: &[&[u8]] = &["game_session".as_bytes(), seed_binding_1.as_ref()];
            let (_pda, bump) = Pubkey::find_program_address(seeds, &crate::ID);
            vec![seeds[0].to_vec(), seeds[1].to_vec(), vec![bump]]
        };
        let seed_refs: Vec<&[u8]> = seeds_vec.iter().map(|v: &Vec<u8>| v.as_slice()).collect();
        let infos = prepare_account_for_decompression_idempotent::<GameSession>(
            &crate::ID,
            data,
            into_compressed_meta_with_address(meta, &solana_accounts[i], address_space, &crate::ID),
            &solana_accounts[i],
            rent_sponsor,
            cpi_accounts,
            seed_refs.as_slice(),
        )
        .map_err(ProgramError::from)?;
        out.extend(infos);
        Ok(())
    }

    #[inline(never)]
    #[allow(clippy::too_many_arguments)]
    fn handle_placeholder_record<'b, 'info>(
        data: PlaceholderRecord,
        meta: &light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
        solana_accounts: &[AccountInfo<'info>],
        i: usize,
        address_space: Pubkey,
        cpi_accounts: &CpiAccounts<'b, 'info>,
        rent_sponsor: &AccountInfo<'info>,
        out: &mut Vec<
            light_compressed_account::instruction_data::with_account_info::CompressedAccountInfo,
        >,
    ) -> Result<()> {
        let seed_binding_1 = data.placeholder_id.to_le_bytes();
        let seeds_vec = {
            let seeds: &[&[u8]] = &["placeholder_record".as_bytes(), seed_binding_1.as_ref()];
            let (_pda, bump) = Pubkey::find_program_address(seeds, &crate::ID);
            vec![seeds[0].to_vec(), seeds[1].to_vec(), vec![bump]]
        };
        let seed_refs: Vec<&[u8]> = seeds_vec.iter().map(|v: &Vec<u8>| v.as_slice()).collect();
        let infos = prepare_account_for_decompression_idempotent::<PlaceholderRecord>(
            &crate::ID,
            data,
            into_compressed_meta_with_address(meta, &solana_accounts[i], address_space, &crate::ID),
            &solana_accounts[i],
            rent_sponsor,
            cpi_accounts,
            seed_refs.as_slice(),
        )
        .map_err(ProgramError::from)?;
        out.extend(infos);
        Ok(())
    }

    #[inline(never)]
    fn check_account_types(compressed_accounts: &[CompressedAccountData]) -> (bool, bool, bool) {
        let (mut has_tokens, mut has_pdas, mut has_mints) = (false, false, false);
        for c in compressed_accounts {
            match c.data {
                CompressedAccountVariant::PackedCTokenData(_) => {
                    has_tokens = true;
                }
                CompressedAccountVariant::CompressedMint(_) => {
                    has_mints = true;
                }
                _ => has_pdas = true,
            }
            if has_tokens && has_pdas && has_mints {
                break;
            }
        }
        (has_tokens, has_pdas, has_mints)
    }
    /// Helper function to process token decompression - separated to avoid stack overflow
    #[inline(never)]
    #[allow(clippy::too_many_arguments, clippy::extra_unused_lifetimes)]
    fn process_tokens<'a, 'b, 'info>(
        accounts: &DecompressAccountsIdempotent<'info>,
        remaining_accounts: &[anchor_lang::prelude::AccountInfo<'info>],
        fee_payer: &anchor_lang::prelude::AccountInfo<'info>,
        ctoken_program: &anchor_lang::prelude::UncheckedAccount<'info>,
        ctoken_rent_sponsor: &anchor_lang::prelude::AccountInfo<'info>,
        ctoken_cpi_authority: &anchor_lang::prelude::UncheckedAccount<'info>,
        ctoken_config: &anchor_lang::prelude::AccountInfo<'info>,
        config: &anchor_lang::prelude::AccountInfo<'info>,
        ctoken_accounts: Vec<(
            light_ctoken_sdk::compat::PackedCTokenData<CTokenAccountVariant>,
            light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
        )>,
        proof: light_sdk::instruction::ValidityProof,
        cpi_accounts: &CpiAccounts<'b, 'info>,
        post_system_accounts: &[anchor_lang::prelude::AccountInfo<'info>],
        has_prior_context: bool, // true if PDAs or Mints already wrote to CPI context
    ) -> Result<()> {
        let mut token_decompress_indices: Box<
            Vec<light_ctoken_sdk::compressed_token::decompress_full::DecompressFullIndices>,
        > = Box::new(Vec::with_capacity(ctoken_accounts.len()));
        // Collect per-owner signer seed groups; invoke_signed requires one seed group per PDA signer
        let mut token_signers_seed_groups: Vec<Vec<Vec<u8>>> =
            Vec::with_capacity(ctoken_accounts.len());
        let packed_accounts = post_system_accounts;
        use crate::seeds::ctoken_seed_system::{CTokenSeedContext, CTokenSeedProvider};
        let seed_context = CTokenSeedContext {
            accounts,
            remaining_accounts,
        };
        let authority = cpi_accounts
            .authority()
            .map_err(|_| anchor_lang::prelude::ProgramError::from(ErrorCode::MissingAuthority))?;
        let cpi_context = cpi_accounts
            .cpi_context()
            .map_err(|_| anchor_lang::prelude::ProgramError::from(ErrorCode::MissingCpiContext))?;

        for (token_data, meta) in ctoken_accounts.into_iter() {
            let owner_index: u8 = token_data.token_data.owner;
            let mint_index: u8 = token_data.token_data.mint;
            let mint_info = packed_accounts[mint_index as usize].to_account_info();
            let owner_info = packed_accounts[owner_index as usize].to_account_info();
            let (ctoken_signer_seeds, derived_token_account_address) =
                token_data.variant.get_seeds(&seed_context);
            {
                if derived_token_account_address != *owner_info.key {
                    msg!(
                        "derived_token_account_address: {:?}",
                        derived_token_account_address
                    );
                    msg!("owner_info.key: {:?}", owner_info.key);
                    return Err(ProgramError::from(ErrorCode::DerivedTokenAccountMismatch).into());
                }

                let seed_refs: Vec<&[u8]> =
                    ctoken_signer_seeds.iter().map(|s| s.as_slice()).collect();
                let seeds_slice: &[&[u8]] = &seed_refs;

                // Build CompressToPubkey from the signer seeds
                // The last element is the bump, all preceding elements are the seeds
                let bump = ctoken_signer_seeds
                    .last()
                    .and_then(|b| b.first().copied())
                    .unwrap_or(0);
                let seeds_without_bump: Vec<Vec<u8>> = ctoken_signer_seeds
                    .iter()
                    .take(ctoken_signer_seeds.len().saturating_sub(1))
                    .cloned()
                    .collect();
                let compress_to_pubkey =
                    light_ctoken_interface::instructions::extensions::CompressToPubkey {
                        bump,
                        program_id: crate::ID.to_bytes(),
                        seeds: seeds_without_bump,
                    };

                CreateCTokenAccountCpi {
                    payer: fee_payer.clone().to_account_info(),
                    account: owner_info.clone(),
                    mint: mint_info.clone(),
                    owner: *authority.clone().to_account_info().key,
                    compressible: CompressibleParamsCpi {
                        compressible_config: ctoken_config.to_account_info(),
                        rent_sponsor: ctoken_rent_sponsor.clone().to_account_info(),
                        system_program: accounts.system_program.to_account_info(),
                        pre_pay_num_epochs: 2,
                        lamports_per_write: None,
                        compress_to_account_pubkey: Some(compress_to_pubkey),
                        token_account_version:
                            light_ctoken_interface::state::TokenDataVersion::ShaFlat,
                        compression_only: false,
                    },
                }
                .invoke_signed(&[seeds_slice])?;
            }

            // Construct MultiInputTokenDataWithContext from token data and meta
            let source =
                light_ctoken_interface::instructions::transfer2::MultiInputTokenDataWithContext {
                    owner: token_data.token_data.owner,
                    amount: token_data.token_data.amount,
                    has_delegate: token_data.token_data.has_delegate,
                    delegate: token_data.token_data.delegate,
                    mint: token_data.token_data.mint,
                    version: token_data.token_data.version,
                    merkle_context: meta.tree_info.into(),
                    root_index: meta.tree_info.root_index,
                };
            let decompress_index =
                light_ctoken_sdk::compressed_token::decompress_full::DecompressFullIndices {
                    source,
                    destination_index: owner_index,
                    tlv: None,
                    is_ata: false, // Program-owned token accounts, not user ATAs
                };
            token_decompress_indices.push(decompress_index);
            token_signers_seed_groups.push(ctoken_signer_seeds);
        }

        let ctoken_ix =
            light_ctoken_sdk::compressed_token::decompress_full::decompress_full_ctoken_accounts_with_indices(
                fee_payer.key(),
                proof,
                if has_prior_context {
                    Some(cpi_context.key())
                } else {
                    None
                },
                &token_decompress_indices,
                packed_accounts,
            )
            .map_err(anchor_lang::prelude::ProgramError::from)?;
        {
            let mut all_account_infos = <[_]>::into_vec(Box::new([fee_payer.to_account_info()]));
            all_account_infos.extend(ctoken_cpi_authority.to_account_infos());
            all_account_infos.extend(ctoken_program.to_account_infos());
            all_account_infos.extend(ctoken_rent_sponsor.to_account_infos());
            all_account_infos.extend(config.to_account_infos());
            all_account_infos.extend(cpi_accounts.to_account_infos());
            // Build &[&[&[u8]]] where each inner slice is a distinct PDA seed group
            let signer_seed_refs: Vec<Vec<&[u8]>> = token_signers_seed_groups
                .iter()
                .map(|group| group.iter().map(|s| s.as_slice()).collect())
                .collect();
            let signer_seed_slices: Vec<&[&[u8]]> =
                signer_seed_refs.iter().map(|g| g.as_slice()).collect();

            anchor_lang::solana_program::program::invoke_signed(
                &ctoken_ix,
                all_account_infos.as_slice(),
                signer_seed_slices.as_slice(),
            )?;
        }
        Ok(())
    }

    let compression_config = light_sdk::compressible::CompressibleConfig::load_checked(
        &ctx.accounts.config,
        &crate::ID,
    )?;
    let address_space = compression_config.address_space[0];

    let (has_tokens, has_pdas, has_mints) = check_account_types(&compressed_accounts);
    if !has_tokens && !has_pdas && !has_mints {
        return Ok(());
    }

    // Pre-count for exact alloc.
    let (mut token_count, mut pda_count, mut mint_count) = (0usize, 0usize, 0usize);
    for c in &compressed_accounts {
        match c.data {
            CompressedAccountVariant::PackedCTokenData(_) => token_count += 1,
            CompressedAccountVariant::CompressedMint(_) => mint_count += 1,
            _ => pda_count += 1,
        }
    }

    let mut ctoken_accounts: Vec<(
        light_ctoken_sdk::compat::PackedCTokenData<CTokenAccountVariant>,
        light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
    )> = Vec::with_capacity(token_count);
    let mut cmint_accounts: Vec<(
        CompressedMintData,
        light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
    )> = Vec::with_capacity(mint_count);
    let mut compressed_pda_infos = Vec::with_capacity(pda_count);

    // Use CPI context only if we have 2+ different types (need batching)
    let type_count = has_tokens as u8 + has_pdas as u8 + has_mints as u8;
    let needs_cpi_context = type_count >= 2;
    let cpi_accounts = if needs_cpi_context {
        CpiAccounts::new_with_config(
            ctx.accounts.fee_payer.as_ref(),
            &ctx.remaining_accounts[system_accounts_offset as usize..],
            CpiAccountsConfig::new_with_cpi_context(LIGHT_CPI_SIGNER),
        )
    } else {
        CpiAccounts::new(
            ctx.accounts.fee_payer.as_ref(),
            &ctx.remaining_accounts[system_accounts_offset as usize..],
            LIGHT_CPI_SIGNER,
        )
    };

    let pda_accounts_start = ctx.remaining_accounts.len() - compressed_accounts.len();
    let solana_accounts = &ctx.remaining_accounts[pda_accounts_start..];
    let post_system_offset = cpi_accounts.system_accounts_end_offset();
    let all_infos = cpi_accounts.account_infos();
    let post_system_accounts = &all_infos[post_system_offset..];
    for (i, compressed_data) in compressed_accounts.into_iter().enumerate() {
        let unpacked_data = compressed_data.data.unpack(post_system_accounts)?;
        match unpacked_data {
            CompressedAccountVariant::UserRecord(data) => {
                handle_user_record(
                    data,
                    &compressed_data.meta,
                    solana_accounts,
                    i,
                    address_space,
                    &cpi_accounts,
                    &ctx.accounts.rent_sponsor,
                    &mut compressed_pda_infos,
                )?;
            }
            CompressedAccountVariant::GameSession(data) => {
                handle_game_session(
                    data,
                    &compressed_data.meta,
                    solana_accounts,
                    i,
                    address_space,
                    &cpi_accounts,
                    &ctx.accounts.rent_sponsor,
                    &mut compressed_pda_infos,
                )?;
            }
            CompressedAccountVariant::PlaceholderRecord(data) => {
                handle_placeholder_record(
                    data,
                    &compressed_data.meta,
                    solana_accounts,
                    i,
                    address_space,
                    &cpi_accounts,
                    &ctx.accounts.rent_sponsor,
                    &mut compressed_pda_infos,
                )?;
            }
            CompressedAccountVariant::PackedCTokenData(data) => {
                ctoken_accounts.push((data, compressed_data.meta));
            }
            CompressedAccountVariant::CompressedMint(data) => {
                cmint_accounts.push((data, compressed_data.meta));
            }
            CompressedAccountVariant::PackedUserRecord(_)
            | CompressedAccountVariant::PackedGameSession(_)
            | CompressedAccountVariant::PackedPlaceholderRecord(_)
            | CompressedAccountVariant::CTokenData(_) => {
                panic!("internal error: entered unreachable code");
            }
        }
    }
    // return if no uninitialized accounts.
    let has_pdas = !compressed_pda_infos.is_empty();
    let has_tokens = !ctoken_accounts.is_empty();
    let has_mints = !cmint_accounts.is_empty();
    if !has_pdas && !has_tokens && !has_mints {
        return Ok(());
    }
    let fee_payer = ctx.accounts.fee_payer.as_ref();

    // Determine what will execute last (to consume CPI context)
    let has_subsequent = has_tokens || has_mints;

    // Step 1: Write PDAs to CPI context (if there are subsequent operations)
    if has_pdas && has_subsequent {
        let authority = cpi_accounts
            .authority()
            .map_err(|_| anchor_lang::prelude::ProgramError::from(ErrorCode::MissingAuthority))?;
        let cpi_context = cpi_accounts
            .cpi_context()
            .map_err(|_| anchor_lang::prelude::ProgramError::from(ErrorCode::MissingCpiContext))?;
        let system_cpi_accounts = light_sdk_types::cpi_context_write::CpiContextWriteAccounts {
            fee_payer,
            authority,
            cpi_context,
            cpi_signer: LIGHT_CPI_SIGNER,
        };
        LightSystemProgramCpi::new_cpi(LIGHT_CPI_SIGNER, proof)
            .with_account_infos(&compressed_pda_infos)
            .write_to_cpi_context_first()
            .invoke_write_to_cpi_context_first(system_cpi_accounts)?;
    } else if has_pdas {
        // PDAs only - execute directly
        LightSystemProgramCpi::new_cpi(cpi_accounts.config().cpi_signer, proof)
            .with_account_infos(&compressed_pda_infos)
            .invoke(cpi_accounts.clone())?;
    }

    // Step 2: Process mints
    if has_mints {
        process_mints(
            &ctx.accounts,
            fee_payer,
            cmint_accounts,
            proof,
            &cpi_accounts,
            has_pdas,     // indicates if PDAs already wrote to context
            has_tokens,   // indicates if tokens will execute after
        )?;
    }

    // Step 3: Process tokens (always executes last if present)
    if has_tokens {
        let ctoken_program = ctx
            .accounts
            .ctoken_program
            .as_ref()
            .ok_or(ProgramError::NotEnoughAccountKeys)?;
        let ctoken_rent_sponsor = ctx
            .accounts
            .ctoken_rent_sponsor
            .as_ref()
            .ok_or(ProgramError::NotEnoughAccountKeys)?;
        let ctoken_cpi_authority = ctx
            .accounts
            .ctoken_cpi_authority
            .as_ref()
            .ok_or(ProgramError::NotEnoughAccountKeys)?;
        let ctoken_config = ctx
            .accounts
            .ctoken_config
            .as_ref()
            .ok_or(ProgramError::NotEnoughAccountKeys)?;

        process_tokens(
            ctx.accounts,
            ctx.remaining_accounts,
            fee_payer,
            ctoken_program,
            ctoken_rent_sponsor,
            ctoken_cpi_authority,
            ctoken_config,
            &ctx.accounts.config,
            ctoken_accounts,
            proof,
            &cpi_accounts,
            post_system_accounts,
            has_pdas || has_mints, // CPI context was used if PDAs or mints wrote
        )?;
    }
    Ok(())
}

/// Helper function to process mint decompression
#[inline(never)]
#[allow(clippy::too_many_arguments)]
fn process_mints<'b, 'info>(
    accounts: &DecompressAccountsIdempotent<'info>,
    fee_payer: &AccountInfo<'info>,
    cmint_accounts: Vec<(
        CompressedMintData,
        light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
    )>,
    proof: light_sdk::instruction::ValidityProof,
    cpi_accounts: &CpiAccounts<'b, 'info>,
    has_prior_context: bool, // true if PDAs already wrote to context
    has_tokens: bool,        // true if tokens will execute after
) -> Result<()> {
    let cpi_context_account = cpi_accounts
        .cpi_context()
        .map_err(|_| anchor_lang::prelude::ProgramError::from(ErrorCode::MissingCpiContext))?;

    let mint_count = cmint_accounts.len();
    let last_mint_idx = mint_count.saturating_sub(1);

    for (idx, (mint_data, _meta)) in cmint_accounts.into_iter().enumerate() {
        let is_first_operation = !has_prior_context && idx == 0;
        let is_last_mint = idx == last_mint_idx;
        let should_execute = is_last_mint && !has_tokens; // Execute if last mint and no tokens after

        // Determine CPI context flags
        let cpi_ctx = if should_execute {
            // Execute: consume CPI context
            create_decompress_mint_cpi_context_execute(
                [0; 32], // address_tree_pubkey - filled by ctoken program
                0,
                0,
            )
        } else if is_first_operation {
            // First write to CPI context
            create_decompress_mint_cpi_context_first([0; 32], 0, 0)
        } else {
            // Subsequent write to CPI context
            create_decompress_mint_cpi_context_set([0; 32], 0, 0)
        };

        // Get tree accounts - use unwrap_or_else for cleaner error handling
        let state_tree = cpi_accounts.get_tree_account_info(0)
            .map_err(|_| ProgramError::NotEnoughAccountKeys)?;
        let input_queue = cpi_accounts.get_tree_account_info(1)
            .map_err(|_| ProgramError::NotEnoughAccountKeys)?;
        let output_queue = cpi_accounts.get_tree_account_info(2)
            .map_err(|_| ProgramError::NotEnoughAccountKeys)?;

        // Derive CMint PDA
        let (cmint_pda, _) = find_cmint_address(&mint_data.mint_seed_pubkey);

        // Get mint_seed AccountInfo from remaining accounts
        // The mint_seed pubkey is in mint_data, we need to find it
        let mint_seed_info = cpi_accounts
            .account_infos()
            .iter()
            .find(|a| *a.key == mint_data.mint_seed_pubkey)
            .cloned()
            .ok_or(ProgramError::NotEnoughAccountKeys)?;

        // Get CMint AccountInfo
        let cmint_info = cpi_accounts
            .account_infos()
            .iter()
            .find(|a| *a.key == cmint_pda)
            .cloned()
            .ok_or(ProgramError::NotEnoughAccountKeys)?;

        // Get ctoken CPI authority AccountInfo
        let ctoken_cpi_authority = cpi_accounts
            .account_infos()
            .iter()
            .find(|a| *a.key == CPI_AUTHORITY_PDA)
            .cloned()
            .ok_or(ProgramError::NotEnoughAccountKeys)?;

        // Build SystemAccountInfos for each mint (avoid Clone requirement)
        let system_accounts = SystemAccountInfos {
            light_system_program: cpi_accounts.get_account_info(0)
                .map_err(|_| ProgramError::NotEnoughAccountKeys)?.clone(),
            cpi_authority_pda: cpi_accounts.authority()
                .map_err(|_| ProgramError::NotEnoughAccountKeys)?.clone(),
            registered_program_pda: cpi_accounts.registered_program_pda()
                .map_err(|_| ProgramError::NotEnoughAccountKeys)?.clone(),
            account_compression_authority: cpi_accounts.account_compression_authority()
                .map_err(|_| ProgramError::NotEnoughAccountKeys)?.clone(),
            account_compression_program: cpi_accounts.account_compression_program()
                .map_err(|_| ProgramError::NotEnoughAccountKeys)?.clone(),
            system_program: cpi_accounts.system_program()
                .map_err(|_| ProgramError::NotEnoughAccountKeys)?.clone(),
        };

        DecompressCMintCpiWithContext {
            mint_seed: mint_seed_info,
            authority: accounts.fee_payer.to_account_info(), // Authority is fee_payer for decompress
            payer: fee_payer.clone(),
            cmint: cmint_info,
            compressible_config: accounts.config.to_account_info(),
            rent_sponsor: accounts.rent_sponsor.to_account_info(),
            state_tree: state_tree.clone(),
            input_queue: input_queue.clone(),
            output_queue: output_queue.clone(),
            cpi_context_account: cpi_context_account.clone(),
            system_accounts,
            ctoken_cpi_authority,
            compressed_mint_with_context: mint_data.compressed_mint_with_context,
            proof: light_compressed_account::instruction_data::compressed_proof::ValidityProof(
                proof.0.clone(),
            ),
            rent_payment: mint_data.rent_payment,
            write_top_up: mint_data.write_top_up,
            cpi_context: cpi_ctx,
        }
        .invoke()?;
    }

    Ok(())
}
