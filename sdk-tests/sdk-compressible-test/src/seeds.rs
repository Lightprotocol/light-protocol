// Auto-generated by macro. Seed getter implementations.

use anchor_lang::prelude::Pubkey;

use crate::constants::{CTOKEN_SIGNER_SEED, POOL_VAULT_SEED, USER_RECORD_SEED};

pub fn get_userrecord_seeds(owner: &Pubkey) -> (Vec<Vec<u8>>, Pubkey) {
    let mut seed_values = Vec::with_capacity(2usize + 1);
    seed_values.push((USER_RECORD_SEED.as_bytes()).to_vec());
    seed_values.push((owner.as_ref()).to_vec());
    let seed_slices: Vec<&[u8]> = seed_values.iter().map(|v| v.as_slice()).collect();
    let (pda, bump) = Pubkey::find_program_address(&seed_slices, &crate::ID);
    seed_values.push(<[_]>::into_vec(Box::new([bump])));
    (seed_values, pda)
}

pub fn get_gamesession_seeds(session_id: u64) -> (Vec<Vec<u8>>, Pubkey) {
    let mut seed_values = Vec::with_capacity(2usize + 1);
    seed_values.push(("game_session".as_bytes()).to_vec());
    seed_values.push((session_id.to_le_bytes().as_ref()).to_vec());
    let seed_slices: Vec<&[u8]> = seed_values.iter().map(|v| v.as_slice()).collect();
    let (pda, bump) = Pubkey::find_program_address(&seed_slices, &crate::ID);
    seed_values.push(<[_]>::into_vec(Box::new([bump])));
    (seed_values, pda)
}

pub fn get_placeholderrecord_seeds(placeholder_id: u64) -> (Vec<Vec<u8>>, Pubkey) {
    let mut seed_values = Vec::with_capacity(2usize + 1);
    seed_values.push(("placeholder_record".as_bytes()).to_vec());
    seed_values.push((placeholder_id.to_le_bytes().as_ref()).to_vec());
    let seed_slices: Vec<&[u8]> = seed_values.iter().map(|v| v.as_slice()).collect();
    let (pda, bump) = Pubkey::find_program_address(&seed_slices, &crate::ID);
    seed_values.push(<[_]>::into_vec(Box::new([bump])));
    (seed_values, pda)
}

pub fn get_ctokensigner_seeds(fee_payer: &Pubkey, some_mint: &Pubkey) -> (Vec<Vec<u8>>, Pubkey) {
    let mut seed_values = Vec::with_capacity(3usize + 1);
    seed_values.push((CTOKEN_SIGNER_SEED.as_bytes()).to_vec());
    seed_values.push((fee_payer.as_ref()).to_vec());
    seed_values.push((some_mint.as_ref()).to_vec());
    let seed_slices: Vec<&[u8]> = seed_values.iter().map(|v| v.as_slice()).collect();
    let (pda, bump) = Pubkey::find_program_address(&seed_slices, &crate::ID);
    seed_values.push(<[_]>::into_vec(Box::new([bump])));
    (seed_values, pda)
}

pub fn get_ctoken_signer_seeds<'a>(user: &'a Pubkey, mint: &'a Pubkey) -> (Vec<Vec<u8>>, Pubkey) {
    let mut seeds = vec![
        b"ctoken_signer".to_vec(),
        user.to_bytes().to_vec(),
        mint.to_bytes().to_vec(),
    ];
    let seeds_slice = seeds.iter().map(|s| s.as_slice()).collect::<Vec<_>>();
    let (pda, bump) = Pubkey::find_program_address(seeds_slice.as_slice(), &crate::ID);
    seeds.push(vec![bump]);
    (seeds, pda)
}

pub fn get_ctoken_signer2_seeds(user: &Pubkey) -> (Vec<Vec<u8>>, Pubkey) {
    let mut seeds = vec![b"user_vault".to_vec(), user.to_bytes().to_vec()];
    let seeds_slice = seeds.iter().map(|s| s.as_slice()).collect::<Vec<_>>();
    let (pda, bump) = Pubkey::find_program_address(seeds_slice.as_slice(), &crate::ID);
    seeds.push(vec![bump]);
    (seeds, pda)
}

pub fn get_ctoken_signer3_seeds(user: &Pubkey) -> (Vec<Vec<u8>>, Pubkey) {
    let mut seeds = vec![
        POOL_VAULT_SEED.as_bytes().to_vec(),
        user.to_bytes().to_vec(),
        b"liquidity".to_vec(),
    ];
    let seeds_slice = seeds.iter().map(|s| s.as_slice()).collect::<Vec<_>>();
    let (pda, bump) = Pubkey::find_program_address(seeds_slice.as_slice(), &crate::ID);
    seeds.push(vec![bump]);
    (seeds, pda)
}

pub fn get_ctokensigner_authority_seeds() -> (Vec<Vec<u8>>, Pubkey) {
    let mut seeds = vec![b"cpi_authority".to_vec()];
    let seeds_slice = seeds.iter().map(|s| s.as_slice()).collect::<Vec<_>>();
    let (pda, bump) = Pubkey::find_program_address(seeds_slice.as_slice(), &crate::ID);
    seeds.push(vec![bump]);
    (seeds, pda)
}

pub fn get_ctokensigner2_authority_seeds() -> (Vec<Vec<u8>>, Pubkey) {
    get_ctokensigner_authority_seeds()
}

pub fn get_ctokensigner3_authority_seeds() -> (Vec<Vec<u8>>, Pubkey) {
    get_ctokensigner_authority_seeds()
}

pub fn get_ctoken_signer4_seeds<'a>(
    user: &'a Pubkey,
    fee_payer: &'a Pubkey,
) -> (Vec<Vec<u8>>, Pubkey) {
    let mut seeds = vec![
        b"multi_account".to_vec(),
        user.to_bytes().to_vec(),
        fee_payer.to_bytes().to_vec(),
        crate::ID.to_bytes().to_vec(),
    ];
    let seeds_slice = seeds.iter().map(|s| s.as_slice()).collect::<Vec<_>>();
    let (pda, bump) = Pubkey::find_program_address(seeds_slice.as_slice(), &crate::ID);
    seeds.push(vec![bump]);
    (seeds, pda)
}

pub fn get_ctoken_signer5_seeds<'a>(
    user: &'a Pubkey,
    mint: &'a Pubkey,
    index: u64,
) -> (Vec<Vec<u8>>, Pubkey) {
    let mut seeds = vec![
        b"indexed_vault".to_vec(),
        user.to_bytes().to_vec(),
        mint.to_bytes().to_vec(),
        index.to_le_bytes().to_vec(),
        b"final".to_vec(),
    ];
    let seeds_slice = seeds.iter().map(|s| s.as_slice()).collect::<Vec<_>>();
    let (pda, bump) = Pubkey::find_program_address(seeds_slice.as_slice(), &crate::ID);
    seeds.push(vec![bump]);
    (seeds, pda)
}

pub fn get_ctokensigner4_authority_seeds() -> (Vec<Vec<u8>>, Pubkey) {
    get_ctokensigner_authority_seeds()
}

pub fn get_ctokensigner5_authority_seeds() -> (Vec<Vec<u8>>, Pubkey) {
    get_ctokensigner_authority_seeds()
}

pub mod ctoken_seed_system {
    use anchor_lang::prelude::{AccountInfo, Pubkey};

    use super::super::{
        constants::{CTOKEN_SIGNER_SEED, POOL_VAULT_SEED},
        instruction_accounts::DecompressAccountsIdempotent,
        state::CTokenAccountVariant,
    };

    pub struct CTokenSeedContext<'a, 'info> {
        pub accounts: &'a DecompressAccountsIdempotent<'info>,
        pub remaining_accounts: &'a [AccountInfo<'info>],
    }

    pub trait CTokenSeedProvider {
        fn get_seeds<'a, 'info>(
            &self,
            ctx: &CTokenSeedContext<'a, 'info>,
        ) -> (Vec<Vec<u8>>, Pubkey);
    }

    impl CTokenSeedProvider for CTokenAccountVariant {
        fn get_seeds<'a, 'info>(
            &self,
            ctx: &CTokenSeedContext<'a, 'info>,
        ) -> (Vec<Vec<u8>>, Pubkey) {
            match self {
                CTokenAccountVariant::CTokenSigner => {
                    let seed_1 = ctx.accounts.fee_payer.key.to_bytes();
                    let seed_2 = ctx.accounts.some_mint.key.to_bytes();
                    let seeds: &[&[u8]] = &[CTOKEN_SIGNER_SEED.as_bytes(), &seed_1, &seed_2];
                    let (pda, bump) = Pubkey::find_program_address(seeds, &crate::ID);
                    let mut seeds_vec = Vec::with_capacity(seeds.len() + 1);
                    seeds_vec.extend(seeds.iter().map(|s| s.to_vec()));
                    seeds_vec.push(<[_]>::into_vec(Box::new([bump])));
                    (seeds_vec, pda)
                }
                CTokenAccountVariant::CTokenSigner2 => {
                    let seed_1 = ctx.accounts.fee_payer.key.to_bytes();
                    let seeds: &[&[u8]] = &[b"user_vault", &seed_1];
                    let (pda, bump) = Pubkey::find_program_address(seeds, &crate::ID);
                    let mut seeds_vec = Vec::with_capacity(seeds.len() + 1);
                    seeds_vec.extend(seeds.iter().map(|s| s.to_vec()));
                    seeds_vec.push(<[_]>::into_vec(Box::new([bump])));
                    (seeds_vec, pda)
                }
                CTokenAccountVariant::CTokenSigner3 => {
                    let seed_1 = ctx.accounts.fee_payer.key.to_bytes();
                    let seeds: &[&[u8]] = &[POOL_VAULT_SEED.as_bytes(), &seed_1, b"liquidity"];
                    let (pda, bump) = Pubkey::find_program_address(seeds, &crate::ID);
                    let mut seeds_vec = Vec::with_capacity(seeds.len() + 1);
                    seeds_vec.extend(seeds.iter().map(|s| s.to_vec()));
                    seeds_vec.push(<[_]>::into_vec(Box::new([bump])));
                    (seeds_vec, pda)
                }
                CTokenAccountVariant::CTokenSigner4 => {
                    let seed_1 = ctx.accounts.fee_payer.key.to_bytes();
                    let seed_2 = ctx.accounts.fee_payer.key.to_bytes();
                    let program_id_bytes = crate::ID.to_bytes();
                    let seeds: &[&[u8]] = &[b"multi_account", &seed_1, &seed_2, &program_id_bytes];
                    let (pda, bump) = Pubkey::find_program_address(seeds, &crate::ID);
                    let mut seeds_vec = Vec::with_capacity(seeds.len() + 1);
                    seeds_vec.extend(seeds.iter().map(|s| s.to_vec()));
                    seeds_vec.push(<[_]>::into_vec(Box::new([bump])));
                    (seeds_vec, pda)
                }
                CTokenAccountVariant::CTokenSigner5 => {
                    let seed_1 = ctx.accounts.fee_payer.key.to_bytes();
                    let seed_2 = ctx.accounts.some_mint.key.to_bytes();
                    let index_bytes = 42u64.to_le_bytes();
                    let seeds: &[&[u8]] =
                        &[b"indexed_vault", &seed_1, &seed_2, &index_bytes, b"final"];
                    let (pda, bump) = Pubkey::find_program_address(seeds, &crate::ID);
                    let mut seeds_vec = Vec::with_capacity(seeds.len() + 1);
                    seeds_vec.extend(seeds.iter().map(|s| s.to_vec()));
                    seeds_vec.push(<[_]>::into_vec(Box::new([bump])));
                    (seeds_vec, pda)
                }
            }
        }
    }
}
