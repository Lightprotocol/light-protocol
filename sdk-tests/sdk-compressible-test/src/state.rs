// Only CompressionParams is custom to the caller program. All other structs are
// auto-generated by macro. Compressed account variant, pack, unpack,
// hasCompressionInfo implementions.

use anchor_lang::prelude::*;
use light_compressed_token_sdk::Pack as _TokenPack;
use light_ctoken_interface::instructions::mint_action::CompressedMintWithContext;
use light_sdk::{
    account::Size,
    compressible::{
        CompressAs, CompressedInitSpace, CompressionInfo, HasCompressionInfo, Pack as SdkPack,
        Unpack as SdkUnpack,
    },
    instruction::{
        account_meta::CompressedAccountMetaNoLamportsNoAddress, PackedAccounts,
        PackedAddressTreeInfo, ValidityProof,
    },
    LightDiscriminator, LightHasher,
};

#[derive(AnchorSerialize, AnchorDeserialize, Debug, Clone, Copy)]
#[repr(u8)]
pub enum CTokenAccountVariant {
    CTokenSigner = 0,
    CTokenSigner2 = 1,
    CTokenSigner3 = 2,
    CTokenSigner4 = 3,
    CTokenSigner5 = 4,
}

#[derive(Clone, Debug, AnchorSerialize, AnchorDeserialize)]
pub enum CompressedAccountVariant {
    UserRecord(UserRecord),
    PackedUserRecord(PackedUserRecord),
    GameSession(GameSession),
    PackedGameSession(PackedGameSession),
    PlaceholderRecord(PlaceholderRecord),
    PackedPlaceholderRecord(PackedPlaceholderRecord),
    PackedCTokenData(light_compressed_token_sdk::compat::PackedCTokenData<CTokenAccountVariant>),
    CTokenData(light_compressed_token_sdk::compat::CTokenData<CTokenAccountVariant>),
}

impl Default for CompressedAccountVariant {
    fn default() -> Self {
        Self::UserRecord(UserRecord::default())
    }
}

impl LightDiscriminator for CompressedAccountVariant {
    const LIGHT_DISCRIMINATOR: [u8; 8] = [0; 8]; // This won't be used directly
    const LIGHT_DISCRIMINATOR_SLICE: &'static [u8] = &Self::LIGHT_DISCRIMINATOR;
}

impl HasCompressionInfo for CompressedAccountVariant {
    fn compression_info(&self) -> &CompressionInfo {
        match self {
            Self::UserRecord(data) => data.compression_info(),
            Self::PackedUserRecord(_) => unreachable!(),
            Self::GameSession(data) => data.compression_info(),
            Self::PlaceholderRecord(data) => data.compression_info(),
            Self::PackedCTokenData(_) => unreachable!(),
            Self::CTokenData(_) => unreachable!(),
            Self::PackedGameSession(_) => unreachable!(),
            Self::PackedPlaceholderRecord(_) => unreachable!(),
        }
    }

    fn compression_info_mut(&mut self) -> &mut CompressionInfo {
        match self {
            Self::UserRecord(data) => data.compression_info_mut(),
            Self::PackedUserRecord(_) => unreachable!(),
            Self::GameSession(data) => data.compression_info_mut(),
            Self::PlaceholderRecord(data) => data.compression_info_mut(),
            Self::PackedCTokenData(_) => unreachable!(),
            Self::CTokenData(_) => unreachable!(),
            Self::PackedGameSession(_) => unreachable!(),
            Self::PackedPlaceholderRecord(_) => unreachable!(),
        }
    }

    fn compression_info_mut_opt(&mut self) -> &mut Option<CompressionInfo> {
        match self {
            Self::UserRecord(data) => data.compression_info_mut_opt(),
            Self::PackedUserRecord(_) => unreachable!(),
            Self::GameSession(data) => data.compression_info_mut_opt(),
            Self::PlaceholderRecord(data) => data.compression_info_mut_opt(),
            Self::PackedCTokenData(_) => unreachable!(),
            Self::CTokenData(_) => unreachable!(),
            Self::PackedGameSession(_) => unreachable!(),
            Self::PackedPlaceholderRecord(_) => unreachable!(),
        }
    }

    fn set_compression_info_none(&mut self) {
        match self {
            Self::UserRecord(data) => data.set_compression_info_none(),
            Self::PackedUserRecord(_) => unreachable!(),
            Self::GameSession(data) => data.set_compression_info_none(),
            Self::PlaceholderRecord(data) => data.set_compression_info_none(),
            Self::PackedCTokenData(_) => unreachable!(),
            Self::CTokenData(_) => unreachable!(),
            Self::PackedGameSession(_) => unreachable!(),
            Self::PackedPlaceholderRecord(_) => unreachable!(),
        }
    }
}

impl Size for CompressedAccountVariant {
    fn size(&self) -> usize {
        match self {
            Self::UserRecord(data) => data.size(),
            Self::PackedUserRecord(_) => unreachable!(),
            Self::GameSession(data) => data.size(),
            Self::PlaceholderRecord(data) => data.size(),
            Self::PackedCTokenData(_) => unreachable!(),
            Self::CTokenData(_) => unreachable!(),
            Self::PackedGameSession(_) => unreachable!(),
            Self::PackedPlaceholderRecord(_) => unreachable!(),
        }
    }
}

// Pack implementation for CompressedAccountVariant
// This delegates to the underlying type's Pack implementation
impl SdkPack for CompressedAccountVariant {
    type Packed = Self;

    fn pack(&self, remaining_accounts: &mut PackedAccounts) -> Self::Packed {
        match self {
            Self::PackedUserRecord(_) => unreachable!(),
            Self::UserRecord(data) => Self::PackedUserRecord(data.pack(remaining_accounts)),
            Self::GameSession(data) => Self::GameSession(data.pack(remaining_accounts)),
            Self::PlaceholderRecord(data) => Self::PlaceholderRecord(data.pack(remaining_accounts)),
            Self::PackedCTokenData(_) => {
                unreachable!()
            }
            Self::CTokenData(data) => Self::PackedCTokenData(data.pack(remaining_accounts)),
            Self::PackedGameSession(_) => unreachable!(),
            Self::PackedPlaceholderRecord(_) => unreachable!(),
        }
    }
}

// Unpack implementation for CompressedAccountVariant
// This delegates to the underlying type's Unpack implementation
impl SdkUnpack for CompressedAccountVariant {
    type Unpacked = Self;

    fn unpack(
        &self,
        remaining_accounts: &[AccountInfo],
    ) -> std::result::Result<Self::Unpacked, ProgramError> {
        match self {
            Self::PackedUserRecord(data) => Ok(Self::UserRecord(data.unpack(remaining_accounts)?)),
            Self::UserRecord(_) => unreachable!(),
            Self::GameSession(data) => Ok(Self::GameSession(data.unpack(remaining_accounts)?)),
            Self::PlaceholderRecord(data) => {
                Ok(Self::PlaceholderRecord(data.unpack(remaining_accounts)?))
            }
            Self::PackedCTokenData(_data) => Ok(self.clone()), // as-is
            Self::CTokenData(_data) => unreachable!(),         // as-is
            Self::PackedGameSession(_data) => unreachable!(),
            Self::PackedPlaceholderRecord(_data) => unreachable!(),
        }
    }
}

// Auto-derived via macro. Ix data implemented for Variant.
#[derive(Clone, Debug, AnchorDeserialize, AnchorSerialize)]
pub struct CompressedAccountData {
    pub meta: CompressedAccountMetaNoLamportsNoAddress,
    pub data: CompressedAccountVariant,
}

#[derive(Default, Debug, LightHasher, LightDiscriminator, InitSpace)]
#[account]
pub struct UserRecord {
    #[skip]
    pub compression_info: Option<CompressionInfo>,
    #[hash]
    pub owner: Pubkey,
    #[max_len(32)]
    pub name: String,
    pub score: u64,
}

// Auto-derived via macro.
impl HasCompressionInfo for UserRecord {
    fn compression_info(&self) -> &CompressionInfo {
        self.compression_info
            .as_ref()
            .expect("CompressionInfo must be Some on-chain")
    }

    fn compression_info_mut(&mut self) -> &mut CompressionInfo {
        self.compression_info
            .as_mut()
            .expect("CompressionInfo must be Some on-chain")
    }

    fn compression_info_mut_opt(&mut self) -> &mut Option<CompressionInfo> {
        &mut self.compression_info
    }

    fn set_compression_info_none(&mut self) {
        self.compression_info = None;
    }
}

impl CompressedInitSpace for UserRecord {
    const COMPRESSED_INIT_SPACE: usize = Self::LIGHT_DISCRIMINATOR.len() + Self::INIT_SPACE;
}

impl CompressedInitSpace for GameSession {
    const COMPRESSED_INIT_SPACE: usize = Self::LIGHT_DISCRIMINATOR.len() + Self::INIT_SPACE;
}

impl CompressedInitSpace for PlaceholderRecord {
    const COMPRESSED_INIT_SPACE: usize = Self::LIGHT_DISCRIMINATOR.len() + Self::INIT_SPACE;
}

impl Size for UserRecord {
    fn size(&self) -> usize {
        Self::LIGHT_DISCRIMINATOR.len() + Self::INIT_SPACE
    }
}

impl CompressAs for UserRecord {
    type Output = Self;

    fn compress_as(&self) -> std::borrow::Cow<'_, Self::Output> {
        // Simple case: return owned data with compression_info = None
        // We can't return Cow::Borrowed because compression_info must always be None for compressed storage
        std::borrow::Cow::Owned(Self {
            compression_info: None, // ALWAYS None for compressed storage
            owner: self.owner,
            name: self.name.clone(),
            score: self.score,
        })
    }
}

#[derive(Debug, Clone, AnchorSerialize, AnchorDeserialize)]
pub struct PackedUserRecord {
    pub compression_info: Option<CompressionInfo>,
    pub owner: u8,
    pub name: String,
    pub score: u64,
}

// Identity Pack implementation - no custom packing needed for PDA types
impl SdkPack for UserRecord {
    type Packed = PackedUserRecord;

    fn pack(&self, remaining_accounts: &mut PackedAccounts) -> Self::Packed {
        PackedUserRecord {
            compression_info: None,
            owner: remaining_accounts.insert_or_get(self.owner),
            name: self.name.clone(),
            score: self.score,
        }
    }
}

// Identity Unpack implementation - PDA types are sent unpacked
impl SdkUnpack for UserRecord {
    type Unpacked = Self;

    fn unpack(
        &self,
        _remaining_accounts: &[AccountInfo],
    ) -> std::result::Result<Self::Unpacked, ProgramError> {
        Ok(self.clone())
    }
}

// Identity Pack implementation - no custom packing needed for PDA types
impl SdkPack for PackedUserRecord {
    type Packed = Self;

    fn pack(&self, _remaining_accounts: &mut PackedAccounts) -> Self::Packed {
        self.clone()
    }
}

// Identity Unpack implementation - PDA types are sent unpacked
impl SdkUnpack for PackedUserRecord {
    type Unpacked = UserRecord;

    fn unpack(
        &self,
        remaining_accounts: &[AccountInfo],
    ) -> std::result::Result<Self::Unpacked, ProgramError> {
        Ok(UserRecord {
            compression_info: None,
            owner: *remaining_accounts[self.owner as usize].key,
            name: self.name.clone(),
            score: self.score,
        })
    }
}

// Your existing account structs must be manually extended:
// 1. Add compression_info field to the struct, with type
//    Option<CompressionInfo>.
// 2. add a #[skip] field for the compression_info field.
// 3. Add LightHasher, LightDiscriminator.
// 4. Add #[hash] attribute to ALL fields that can be >31 bytes. (eg Pubkeys,
//    Strings)
#[derive(Default, Debug, LightHasher, LightDiscriminator, InitSpace)]
#[account]
pub struct GameSession {
    #[skip]
    pub compression_info: Option<CompressionInfo>,
    pub session_id: u64,
    #[hash]
    pub player: Pubkey,
    #[max_len(32)]
    pub game_type: String,
    pub start_time: u64,
    pub end_time: Option<u64>,
    pub score: u64,
}

// Auto-derived via macro.
impl HasCompressionInfo for GameSession {
    fn compression_info(&self) -> &CompressionInfo {
        self.compression_info
            .as_ref()
            .expect("CompressionInfo must be Some on-chain")
    }

    fn compression_info_mut(&mut self) -> &mut CompressionInfo {
        self.compression_info
            .as_mut()
            .expect("CompressionInfo must be Some on-chain")
    }

    fn compression_info_mut_opt(&mut self) -> &mut Option<CompressionInfo> {
        &mut self.compression_info
    }

    fn set_compression_info_none(&mut self) {
        self.compression_info = None;
    }
}

impl Size for GameSession {
    fn size(&self) -> usize {
        Self::LIGHT_DISCRIMINATOR.len() + Self::INIT_SPACE
    }
}

impl CompressAs for GameSession {
    type Output = Self;

    fn compress_as(&self) -> std::borrow::Cow<'_, Self::Output> {
        // Custom compression: return owned data with modified fields
        std::borrow::Cow::Owned(Self {
            compression_info: None,            // ALWAYS None for compressed storage
            session_id: self.session_id,       // KEEP - identifier
            player: self.player,               // KEEP - identifier
            game_type: self.game_type.clone(), // KEEP - core property
            start_time: 0,                     // RESET - clear timing
            end_time: None,                    // RESET - clear timing
            score: 0,                          // RESET - clear progress
        })
    }
}

// Identity Pack implementation - no custom packing needed for PDA types
impl SdkPack for GameSession {
    type Packed = Self;

    fn pack(&self, _remaining_accounts: &mut PackedAccounts) -> Self::Packed {
        self.clone()
    }
}

// Identity Unpack implementation - PDA types are sent unpacked
impl SdkUnpack for GameSession {
    type Unpacked = Self;

    fn unpack(
        &self,
        _remaining_accounts: &[AccountInfo],
    ) -> std::result::Result<Self::Unpacked, ProgramError> {
        Ok(self.clone())
    }
}

// PlaceholderRecord - demonstrates empty compressed account creation
// The PDA remains intact while an empty compressed account is created
#[derive(Default, Debug, LightHasher, LightDiscriminator, InitSpace)]
#[account]
pub struct PlaceholderRecord {
    #[skip]
    pub compression_info: Option<CompressionInfo>,
    #[hash]
    pub owner: Pubkey,
    #[max_len(32)]
    pub name: String,
    pub placeholder_id: u64,
}

impl HasCompressionInfo for PlaceholderRecord {
    fn compression_info(&self) -> &CompressionInfo {
        self.compression_info
            .as_ref()
            .expect("CompressionInfo must be Some on-chain")
    }

    fn compression_info_mut(&mut self) -> &mut CompressionInfo {
        self.compression_info
            .as_mut()
            .expect("CompressionInfo must be Some on-chain")
    }

    fn compression_info_mut_opt(&mut self) -> &mut Option<CompressionInfo> {
        &mut self.compression_info
    }

    fn set_compression_info_none(&mut self) {
        self.compression_info = None;
    }
}

impl Size for PlaceholderRecord {
    fn size(&self) -> usize {
        Self::LIGHT_DISCRIMINATOR.len() + Self::INIT_SPACE
    }
}

impl CompressAs for PlaceholderRecord {
    type Output = Self;

    fn compress_as(&self) -> std::borrow::Cow<'_, Self::Output> {
        std::borrow::Cow::Owned(Self {
            compression_info: None,
            owner: self.owner,
            name: self.name.clone(),
            placeholder_id: self.placeholder_id,
        })
    }
}

// Identity Pack implementation - no custom packing needed for PDA types
impl SdkPack for PlaceholderRecord {
    type Packed = Self;

    fn pack(&self, _remaining_accounts: &mut PackedAccounts) -> Self::Packed {
        self.clone()
    }
}

// Identity Unpack implementation - PDA types are sent unpacked
impl SdkUnpack for PlaceholderRecord {
    type Unpacked = Self;

    fn unpack(
        &self,
        _remaining_accounts: &[AccountInfo],
    ) -> std::result::Result<Self::Unpacked, ProgramError> {
        Ok(self.clone())
    }
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct PackedGameSession {
    pub compression_info: Option<CompressionInfo>,
    pub session_id: u64,
    pub player: u8,
    pub game_type: String,
    pub start_time: u64,
    pub end_time: Option<u64>,
    pub score: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct PackedPlaceholderRecord {
    pub compression_info: Option<CompressionInfo>,
    pub owner: u8,
    pub name: String,
    pub placeholder_id: u64,
}

// Add these struct definitions before the program module
#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct AccountCreationData {
    pub user_name: String,
    pub session_id: u64,
    pub game_type: String,
    // TODO: Add mint metadata fields when implementing mint functionality
    pub mint_name: String,
    pub mint_symbol: String,
    pub mint_uri: String,
    pub mint_decimals: u8,
    pub mint_supply: u64,
    pub mint_update_authority: Option<Pubkey>,
    pub mint_freeze_authority: Option<Pubkey>,
    pub additional_metadata: Option<Vec<(String, String)>>,
}

/// Information about a token account to compress
#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct TokenAccountInfo {
    pub user: Pubkey,
    pub mint: Pubkey,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct CompressionParams {
    pub proof: ValidityProof,
    pub user_compressed_address: [u8; 32],
    pub user_address_tree_info: PackedAddressTreeInfo,
    pub user_output_state_tree_index: u8,
    pub game_compressed_address: [u8; 32],
    pub game_address_tree_info: PackedAddressTreeInfo,
    pub game_output_state_tree_index: u8,
    pub mint_bump: u8,
    pub mint_with_context: CompressedMintWithContext,
}
