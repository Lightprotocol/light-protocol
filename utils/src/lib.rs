use std::{
    env,
    io::{self, prelude::*},
    process::{Command, Stdio},
    thread::spawn,
};

use thiserror::Error;

pub mod bigint;

const CHUNK_SIZE: usize = 32;

#[derive(Debug, Error)]
pub enum UtilsError {
    #[error("Invalid input size, expected {0}, got {1}")]
    InvalidInputSize(usize, usize),
    #[error("Invalid chunk size")]
    InvalidChunkSize,
}

pub fn change_endianness<const SIZE: usize>(bytes: &[u8; SIZE]) -> [u8; SIZE] {
    let mut arr = [0u8; SIZE];
    for (i, b) in bytes.chunks(CHUNK_SIZE).enumerate() {
        for (j, byte) in b.iter().rev().enumerate() {
            arr[i * CHUNK_SIZE + j] = *byte;
        }
    }
    arr
}

/// Truncates the given 32-byte array, replacing the least important element
/// with 0, making it fit into Fr modulo field.
///
/// # Safety
///
/// This function is used mostly for truncating hashes (i.e. SHA-256) which are
/// not constrainted by any modulo space. At the same time, we can't (yet) use
/// any ZK-friendly function in one transaction. Truncating hashes to 31 should
/// be generally safe, but please make sure that it's appropriate in your case.
///
/// # Examples
///
/// ```
/// use light_utils::truncate_to_circuit;
///
/// let original: [u8; 32] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
///                            16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
///                            29, 30, 31, 32];
/// let truncated: [u8; 32] = truncate_to_circuit(&original);
/// assert_eq!(truncated, [0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
///                        18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]);
/// ```
pub fn truncate_to_circuit(bytes: &[u8; 32]) -> [u8; 32] {
    let mut truncated = [0; 32];
    truncated[1..].copy_from_slice(&bytes[1..]);
    truncated
}

/// Applies `rustfmt` on the given string containing Rust code. The purpose of
/// this function is to be able to format autogenerated code (e.g. with `quote`
/// macro).
pub fn rustfmt(code: String) -> Result<Vec<u8>, anyhow::Error> {
    let mut cmd = match env::var_os("RUSTFMT") {
        Some(r) => Command::new(r),
        None => Command::new("rustfmt"),
    };

    let mut cmd = cmd
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()?;

    let mut stdin = cmd.stdin.take().unwrap();
    let mut stdout = cmd.stdout.take().unwrap();

    let stdin_handle = spawn(move || {
        stdin.write_all(code.as_bytes()).unwrap();
    });

    let mut formatted_code = vec![];
    io::copy(&mut stdout, &mut formatted_code)?;

    let _ = cmd.wait();
    stdin_handle.join().unwrap();

    Ok(formatted_code)
}
