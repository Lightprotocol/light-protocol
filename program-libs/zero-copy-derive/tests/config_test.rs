#![cfg(feature = "mut")]

use borsh::{BorshDeserialize, BorshSerialize};
use light_zero_copy::borsh_mut::DeserializeMut;
use light_zero_copy_derive::{ByteLen, ZeroCopy, ZeroCopyConfig, ZeroCopyEq, ZeroCopyMut};

/// Simple struct with just a Vec field to test basic config functionality
#[repr(C)]
#[derive(
    Debug,
    PartialEq,
    BorshSerialize,
    BorshDeserialize,
    ZeroCopy,
    ZeroCopyMut,
    ZeroCopyEq,
    ByteLen,
    ZeroCopyConfig,
)]
pub struct SimpleVecStruct {
    pub a: u8,
    pub vec: Vec<u8>,
    pub b: u16,
}

#[test]
fn test_simple_config_generation() {
    // This test verifies that the ZeroCopyConfig derive macro generates the expected config struct
    // and ZeroCopyInitMut implementation

    // The config should have been generated as SimpleVecStructConfig
    let config = SimpleVecStructConfig {
        vec: 10, // Vec<u8> should have u32 config (length)
    };

    // Test that we can create a configuration
    assert_eq!(config.vec, 10);

    println!("Config generation test passed!");
}

#[test]
fn test_simple_vec_struct_new_zero_copy() {
    use light_zero_copy::init_mut::ZeroCopyInitMut;
    
    // Test the new_zero_copy method generated by ZeroCopyConfig
    let mut bytes = vec![0u8; 100]; // Allocate sufficient buffer
    let config = SimpleVecStructConfig {
        vec: 5, // Vec<u8> with capacity 5
    };

    // Use the generated new_zero_copy method
    let result = SimpleVecStruct::new_zero_copy(&mut bytes, config);
    assert!(result.is_ok());
    let (mut simple_struct, _remaining) = result.unwrap();

    // Test that we can set meta fields
    simple_struct.__meta.a = 42;

    // Test that we can write to the vec slice
    simple_struct.vec[0] = 10;
    simple_struct.vec[1] = 20;
    simple_struct.vec[2] = 30;

    // Test that we can set the b field
    *simple_struct.b = 12345u16.into();

    // Verify the values we set
    assert_eq!(simple_struct.__meta.a, 42);
    assert_eq!(simple_struct.vec[0], 10);
    assert_eq!(simple_struct.vec[1], 20);
    assert_eq!(simple_struct.vec[2], 30);
    assert_eq!(u16::from(*simple_struct.b), 12345);

    // Test deserializing the initialized bytes with zero_copy_at_mut
    let deserialize_result = SimpleVecStruct::zero_copy_at_mut(&mut bytes);
    assert!(deserialize_result.is_ok());
    let (deserialized, _remaining) = deserialize_result.unwrap();

    // Verify the deserialized data matches what we set
    assert_eq!(u8::from(deserialized.__meta.a), 42);
    assert_eq!(deserialized.vec[0], 10);
    assert_eq!(deserialized.vec[1], 20);
    assert_eq!(deserialized.vec[2], 30);
    assert_eq!(u16::from(*deserialized.b), 12345);

    println!("new_zero_copy initialization test passed!");
}

/// Struct with Option field to test Option config
#[repr(C)]
#[derive(
    Debug,
    PartialEq,
    BorshSerialize,
    BorshDeserialize,
    ZeroCopy,
    ZeroCopyMut,
    ByteLen,
    ZeroCopyConfig,
)]
pub struct SimpleOptionStruct {
    pub a: u8,
    pub option: Option<u64>,
}

#[test]
fn test_simple_option_struct_new_zero_copy() {
    use light_zero_copy::init_mut::ZeroCopyInitMut;
    
    // Test with option enabled
    let mut bytes = vec![0u8; 100];
    let config = SimpleOptionStructConfig {
        option: true, // Option<u64> should have bool config (enabled/disabled)
    };

    let result = SimpleOptionStruct::new_zero_copy(&mut bytes, config);
    assert!(result.is_ok());
    let (mut simple_struct, _remaining) = result.unwrap();

    // Test that we can set meta field
    simple_struct.__meta.a = 123;

    // Test that option is Some and we can set its value
    assert!(simple_struct.option.is_some());
    if let Some(ref mut opt_val) = simple_struct.option {
        **opt_val = 98765u64.into();
    }

    // Verify the values
    assert_eq!(simple_struct.__meta.a, 123);
    if let Some(ref opt_val) = simple_struct.option {
        assert_eq!(u64::from(**opt_val), 98765);
    }

    // Test deserializing
    let (deserialized, _) = SimpleOptionStruct::zero_copy_at_mut(&mut bytes).unwrap();
    assert_eq!(u8::from(deserialized.__meta.a), 123);
    assert!(deserialized.option.is_some());
    if let Some(ref opt_val) = deserialized.option {
        assert_eq!(u64::from(**opt_val), 98765);
    }

    println!("Option new_zero_copy test passed!");
}

#[test]
fn test_simple_option_struct_disabled() {
    use light_zero_copy::init_mut::ZeroCopyInitMut;
    
    // Test with option disabled
    let mut bytes = vec![0u8; 100];
    let config = SimpleOptionStructConfig {
        option: false, // Option disabled
    };

    let result = SimpleOptionStruct::new_zero_copy(&mut bytes, config);
    assert!(result.is_ok());
    let (mut simple_struct, _remaining) = result.unwrap();

    // Set meta field
    simple_struct.__meta.a = 200;

    // Test that option is None
    assert!(simple_struct.option.is_none());

    // Test deserializing
    let (deserialized, _) = SimpleOptionStruct::zero_copy_at_mut(&mut bytes).unwrap();
    assert_eq!(u8::from(deserialized.__meta.a), 200);
    assert!(deserialized.option.is_none());

    println!("Option disabled new_zero_copy test passed!");
}

/// Test both Vec and Option in one struct
#[repr(C)]
#[derive(
    Debug,
    PartialEq,
    BorshSerialize,
    BorshDeserialize,
    ZeroCopy,
    ZeroCopyMut,
    ByteLen,
    ZeroCopyConfig,
)]
pub struct MixedStruct {
    pub a: u8,
    pub vec: Vec<u8>,
    pub option: Option<u64>,
    pub b: u16,
}

#[test]
fn test_mixed_struct_new_zero_copy() {
    use light_zero_copy::init_mut::ZeroCopyInitMut;
    
    // Test with both vec and option enabled
    let mut bytes = vec![0u8; 200];
    let config = MixedStructConfig {
        vec: 8,       // Vec<u8> -> u32 length
        option: true, // Option<u64> -> bool enabled
    };

    let result = MixedStruct::new_zero_copy(&mut bytes, config);
    assert!(result.is_ok());
    let (mut mixed_struct, _remaining) = result.unwrap();

    // Set meta field
    mixed_struct.__meta.a = 77;

    // Set vec data
    mixed_struct.vec[0] = 11;
    mixed_struct.vec[3] = 44;
    mixed_struct.vec[7] = 88;

    // Set option value
    assert!(mixed_struct.option.is_some());
    if let Some(ref mut opt_val) = mixed_struct.option {
        **opt_val = 123456789u64.into();
    }

    // Set b field
    *mixed_struct.b = 54321u16.into();

    // Verify all values
    assert_eq!(mixed_struct.__meta.a, 77);
    assert_eq!(mixed_struct.vec[0], 11);
    assert_eq!(mixed_struct.vec[3], 44);
    assert_eq!(mixed_struct.vec[7], 88);
    if let Some(ref opt_val) = mixed_struct.option {
        assert_eq!(u64::from(**opt_val), 123456789);
    }
    assert_eq!(u16::from(*mixed_struct.b), 54321);

    // Test deserializing
    let (deserialized, _) = MixedStruct::zero_copy_at_mut(&mut bytes).unwrap();
    assert_eq!(u8::from(deserialized.__meta.a), 77);
    assert_eq!(deserialized.vec[0], 11);
    assert_eq!(deserialized.vec[3], 44);
    assert_eq!(deserialized.vec[7], 88);
    assert!(deserialized.option.is_some());
    if let Some(ref opt_val) = deserialized.option {
        assert_eq!(u64::from(**opt_val), 123456789);
    }
    assert_eq!(u16::from(*deserialized.b), 54321);

    println!("Mixed struct new_zero_copy test passed!");
}

#[test]
fn test_mixed_struct_option_disabled() {
    use light_zero_copy::init_mut::ZeroCopyInitMut;
    
    // Test with vec enabled but option disabled
    let mut bytes = vec![0u8; 200];
    let config = MixedStructConfig {
        vec: 3,        // Vec<u8> -> u32 length
        option: false, // Option<u64> -> bool disabled
    };

    let result = MixedStruct::new_zero_copy(&mut bytes, config);
    assert!(result.is_ok());
    let (mut mixed_struct, _remaining) = result.unwrap();

    // Set values
    mixed_struct.__meta.a = 99;
    mixed_struct.vec[0] = 255;
    mixed_struct.vec[2] = 128;
    *mixed_struct.b = 9999u16.into();

    // Verify option is None
    assert!(mixed_struct.option.is_none());

    // Test deserializing
    let (deserialized, _) = MixedStruct::zero_copy_at_mut(&mut bytes).unwrap();
    assert_eq!(u8::from(deserialized.__meta.a), 99);
    assert_eq!(deserialized.vec[0], 255);
    assert_eq!(deserialized.vec[2], 128);
    assert!(deserialized.option.is_none());
    assert_eq!(u16::from(*deserialized.b), 9999);

    println!("Mixed struct option disabled test passed!");
}
