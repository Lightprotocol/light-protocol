#![cfg(feature = "mut")]

use borsh::{BorshDeserialize, BorshSerialize};
use light_zero_copy::ZeroCopyInitMut;
use light_zero_copy_derive::{ByteLen, ZeroCopy, ZeroCopyConfig, ZeroCopyEq, ZeroCopyMut};

/// Simple struct with just a Vec field to test basic config functionality
#[repr(C)]
#[derive(
    Debug,
    PartialEq,
    BorshSerialize,
    BorshDeserialize,
    ZeroCopy,
    ZeroCopyMut,
    ZeroCopyEq,
    ByteLen,
    ZeroCopyConfig,
)]
pub struct SimpleVecStruct {
    pub a: u8,
    pub vec: Vec<u8>,
    pub b: u16,
}

#[test]
fn test_simple_config_generation() {
    // This test verifies that the ZeroCopyConfig derive macro generates the expected config struct
    // and ZeroCopyInitMut implementation

    // The config should have been generated as SimpleVecStructConfig
    let config = SimpleVecStructConfig {
        vec: 10, // Vec<u8> should have u32 config (length)
    };

    // Test that we can create a configuration
    assert_eq!(config.vec, 10);

    println!("Config generation test passed!");
}

#[test]
fn test_new_zero_copy_initialization() {
    // Test the new_zero_copy method generated by ZeroCopyConfig
    let config = SimpleVecStructConfig {
        vec: 5, // Vec<u8> with capacity 5
    };

    // Calculate required size and allocate buffer
    let size = std::mem::size_of::<SimpleVecStructMeta>() 
        + light_zero_copy::ZeroCopySliceMut::<u8, u8, false>::required_size_for_capacity(config.vec);
    let mut bytes = vec![0u8; size];

    // Use the generated new_zero_copy method
    let result = SimpleVecStruct::new_zero_copy(&mut bytes, config);
    
    match result {
        Ok((mut simple_struct, remaining_bytes)) => {
            // Test that we got a valid struct
            assert_eq!(simple_struct.vec.len(), 0); // Should start empty but with capacity
            assert_eq!(simple_struct.vec.capacity(), 5);
            
            // Test that we can write to the vec
            for i in 0..5 {
                simple_struct.vec.push(i as u8);
            }
            
            println!("new_zero_copy initialization test passed!");
        }
        Err(e) => {
            panic!("new_zero_copy failed: {:?}", e);
        }
    }
}

/// Struct with Option field to test Option config
#[repr(C)]
#[derive(
    Debug,
    PartialEq,
    BorshSerialize,
    BorshDeserialize,
    ZeroCopy,
    ZeroCopyMut,
    ByteLen,
    ZeroCopyConfig,
)]
pub struct SimpleOptionStruct {
    pub a: u8,
    pub option: Option<u64>,
}

#[test]
fn test_option_config_generation() {
    // Test Option<u64> config generation - should be Option<()> since u64 has Config = ()
    let config = SimpleOptionStructConfig {
        option: Some(()), // Option<u64> should have Option<()> config
    };

    println!("Option config generation test passed!");
}

// /// Test both Vec and Option in one struct
// #[repr(C)]
// #[derive(
//     Debug,
//     PartialEq,
//     BorshSerialize,
//     BorshDeserialize,
//     ZeroCopy,
//     ZeroCopyMut,
//     ByteLen,
//     ZeroCopyConfig,
// )]
// pub struct MixedStruct {
//     pub a: u8,
//     pub vec: Vec<u8>,
//     pub option: Option<u64>,
//     pub b: u16,
// }

// #[test]
// fn test_mixed_config_generation() {
//     let config = MixedStructConfig {
//         vec: 5,           // Vec<u8> -> u32
//         option: Some(()), // Option<u64> -> Option<()>
//     };

//     println!("Mixed config generation test passed!");
// }
