#![cfg(feature = "mut")]

use borsh::{BorshDeserialize, BorshSerialize};
use light_zero_copy::borsh_mut::DeserializeMut;
use light_zero_copy_derive::{ZeroCopy, ZeroCopyConfig, ZeroCopyEq, ZeroCopyMut};

/// Simple struct with just a Vec field to test basic config functionality
#[repr(C)]
#[derive(
    Debug,
    PartialEq,
    BorshSerialize,
    BorshDeserialize,
    ZeroCopy,
    ZeroCopyMut,
    ZeroCopyEq,
    ZeroCopyConfig,
)]
pub struct SimpleVecStruct {
    pub a: u8,
    pub vec: Vec<u8>,
    pub b: u16,
}

#[test]
fn test_simple_config_generation() {
    // This test verifies that the ZeroCopyConfig derive macro generates the expected config struct
    // and ZeroCopyNew implementation

    // The config should have been generated as SimpleVecStructConfig
    let config = SimpleVecStructConfig {
        vec: 10, // Vec<u8> should have u32 config (length)
    };

    // Test that we can create a configuration
    assert_eq!(config.vec, 10);

    println!("Config generation test passed!");
}

#[test]
fn test_simple_vec_struct_new_zero_copy() {
    use light_zero_copy::init_mut::ZeroCopyNew;

    // Test the new_zero_copy method generated by ZeroCopyConfig
    let config = SimpleVecStructConfig {
        vec: 5, // Vec<u8> with capacity 5
    };

    // Calculate exact buffer size needed and allocate
    let buffer_size = SimpleVecStruct::byte_len(&config);
    let mut bytes = vec![0u8; buffer_size];

    // Use the generated new_zero_copy method
    let result = SimpleVecStruct::new_zero_copy(&mut bytes, config);
    assert!(result.is_ok());
    let (mut simple_struct, remaining) = result.unwrap();

    // Verify we used exactly the calculated number of bytes
    assert_eq!(
        remaining.len(),
        0,
        "Should have used exactly {} bytes",
        buffer_size
    );

    // Test that we can set meta fields
    simple_struct.__meta.a = 42;

    // Test that we can write to the vec slice
    simple_struct.vec[0] = 10;
    simple_struct.vec[1] = 20;
    simple_struct.vec[2] = 30;

    // Test that we can set the b field
    *simple_struct.b = 12345u16.into();

    // Verify the values we set
    assert_eq!(simple_struct.__meta.a, 42);
    assert_eq!(simple_struct.vec[0], 10);
    assert_eq!(simple_struct.vec[1], 20);
    assert_eq!(simple_struct.vec[2], 30);
    assert_eq!(u16::from(*simple_struct.b), 12345);

    // Test deserializing the initialized bytes with zero_copy_at_mut
    let deserialize_result = SimpleVecStruct::zero_copy_at_mut(&mut bytes);
    assert!(deserialize_result.is_ok());
    let (deserialized, _remaining) = deserialize_result.unwrap();

    // Verify the deserialized data matches what we set
    assert_eq!(u8::from(deserialized.__meta.a), 42);
    assert_eq!(deserialized.vec[0], 10);
    assert_eq!(deserialized.vec[1], 20);
    assert_eq!(deserialized.vec[2], 30);
    assert_eq!(u16::from(*deserialized.b), 12345);

    println!("new_zero_copy initialization test passed!");
}

/// Struct with Option field to test Option config
#[repr(C)]
#[derive(
    Debug, PartialEq, BorshSerialize, BorshDeserialize, ZeroCopy, ZeroCopyMut, ZeroCopyConfig,
)]
pub struct SimpleOptionStruct {
    pub a: u8,
    pub option: Option<u64>,
}

#[test]
fn test_simple_option_struct_new_zero_copy() {
    use light_zero_copy::init_mut::ZeroCopyNew;

    // Test with option enabled
    let config = SimpleOptionStructConfig {
        option: true, // Option<u64> should have bool config (enabled/disabled)
    };

    // Calculate exact buffer size needed and allocate
    let buffer_size = SimpleOptionStruct::byte_len(&config);
    let mut bytes = vec![0u8; buffer_size];

    let result = SimpleOptionStruct::new_zero_copy(&mut bytes, config);
    assert!(result.is_ok());
    let (mut simple_struct, remaining) = result.unwrap();

    // Verify we used exactly the calculated number of bytes
    assert_eq!(
        remaining.len(),
        0,
        "Should have used exactly {} bytes",
        buffer_size
    );

    // Test that we can set meta field
    simple_struct.__meta.a = 123;

    // Test that option is Some and we can set its value
    assert!(simple_struct.option.is_some());
    if let Some(ref mut opt_val) = simple_struct.option {
        **opt_val = 98765u64.into();
    }

    // Verify the values
    assert_eq!(simple_struct.__meta.a, 123);
    if let Some(ref opt_val) = simple_struct.option {
        assert_eq!(u64::from(**opt_val), 98765);
    }

    // Test deserializing
    let (deserialized, _) = SimpleOptionStruct::zero_copy_at_mut(&mut bytes).unwrap();
    assert_eq!(u8::from(deserialized.__meta.a), 123);
    assert!(deserialized.option.is_some());
    if let Some(ref opt_val) = deserialized.option {
        assert_eq!(u64::from(**opt_val), 98765);
    }

    println!("Option new_zero_copy test passed!");
}

#[test]
fn test_simple_option_struct_disabled() {
    use light_zero_copy::init_mut::ZeroCopyNew;

    // Test with option disabled
    let config = SimpleOptionStructConfig {
        option: false, // Option disabled
    };

    // Calculate exact buffer size needed and allocate
    let buffer_size = SimpleOptionStruct::byte_len(&config);
    let mut bytes = vec![0u8; buffer_size];

    let result = SimpleOptionStruct::new_zero_copy(&mut bytes, config);
    assert!(result.is_ok());
    let (mut simple_struct, remaining) = result.unwrap();

    // Verify we used exactly the calculated number of bytes
    assert_eq!(
        remaining.len(),
        0,
        "Should have used exactly {} bytes",
        buffer_size
    );

    // Set meta field
    simple_struct.__meta.a = 200;

    // Test that option is None
    assert!(simple_struct.option.is_none());

    // Test deserializing
    let (deserialized, _) = SimpleOptionStruct::zero_copy_at_mut(&mut bytes).unwrap();
    assert_eq!(u8::from(deserialized.__meta.a), 200);
    assert!(deserialized.option.is_none());

    println!("Option disabled new_zero_copy test passed!");
}

/// Test both Vec and Option in one struct
#[repr(C)]
#[derive(
    Debug, PartialEq, BorshSerialize, BorshDeserialize, ZeroCopy, ZeroCopyMut, ZeroCopyConfig,
)]
pub struct MixedStruct {
    pub a: u8,
    pub vec: Vec<u8>,
    pub option: Option<u64>,
    pub b: u16,
}

#[test]
fn test_mixed_struct_new_zero_copy() {
    use light_zero_copy::init_mut::ZeroCopyNew;

    // Test with both vec and option enabled
    let config = MixedStructConfig {
        vec: 8,       // Vec<u8> -> u32 length
        option: true, // Option<u64> -> bool enabled
    };

    // Calculate exact buffer size needed and allocate
    let buffer_size = MixedStruct::byte_len(&config);
    let mut bytes = vec![0u8; buffer_size];

    let result = MixedStruct::new_zero_copy(&mut bytes, config);
    assert!(result.is_ok());
    let (mut mixed_struct, remaining) = result.unwrap();

    // Verify we used exactly the calculated number of bytes
    assert_eq!(
        remaining.len(),
        0,
        "Should have used exactly {} bytes",
        buffer_size
    );

    // Set meta field
    mixed_struct.__meta.a = 77;

    // Set vec data
    mixed_struct.vec[0] = 11;
    mixed_struct.vec[3] = 44;
    mixed_struct.vec[7] = 88;

    // Set option value
    assert!(mixed_struct.option.is_some());
    if let Some(ref mut opt_val) = mixed_struct.option {
        **opt_val = 123456789u64.into();
    }

    // Set b field
    *mixed_struct.b = 54321u16.into();

    // Verify all values
    assert_eq!(mixed_struct.__meta.a, 77);
    assert_eq!(mixed_struct.vec[0], 11);
    assert_eq!(mixed_struct.vec[3], 44);
    assert_eq!(mixed_struct.vec[7], 88);
    if let Some(ref opt_val) = mixed_struct.option {
        assert_eq!(u64::from(**opt_val), 123456789);
    }
    assert_eq!(u16::from(*mixed_struct.b), 54321);

    // Test deserializing
    let (deserialized, _) = MixedStruct::zero_copy_at_mut(&mut bytes).unwrap();
    assert_eq!(u8::from(deserialized.__meta.a), 77);
    assert_eq!(deserialized.vec[0], 11);
    assert_eq!(deserialized.vec[3], 44);
    assert_eq!(deserialized.vec[7], 88);
    assert!(deserialized.option.is_some());
    if let Some(ref opt_val) = deserialized.option {
        assert_eq!(u64::from(**opt_val), 123456789);
    }
    assert_eq!(u16::from(*deserialized.b), 54321);

    println!("Mixed struct new_zero_copy test passed!");
}

#[test]
fn test_mixed_struct_option_disabled() {
    use light_zero_copy::init_mut::ZeroCopyNew;

    // Test with vec enabled but option disabled
    let config = MixedStructConfig {
        vec: 3,        // Vec<u8> -> u32 length
        option: false, // Option<u64> -> bool disabled
    };

    // Calculate exact buffer size needed and allocate
    let buffer_size = MixedStruct::byte_len(&config);
    let mut bytes = vec![0u8; buffer_size];

    let result = MixedStruct::new_zero_copy(&mut bytes, config);
    assert!(result.is_ok());
    let (mut mixed_struct, remaining) = result.unwrap();

    // Verify we used exactly the calculated number of bytes
    assert_eq!(
        remaining.len(),
        0,
        "Should have used exactly {} bytes",
        buffer_size
    );

    // Set values
    mixed_struct.__meta.a = 99;
    mixed_struct.vec[0] = 255;
    mixed_struct.vec[2] = 128;
    *mixed_struct.b = 9999u16.into();

    // Verify option is None
    assert!(mixed_struct.option.is_none());

    // Test deserializing
    let (deserialized, _) = MixedStruct::zero_copy_at_mut(&mut bytes).unwrap();
    assert_eq!(u8::from(deserialized.__meta.a), 99);
    assert_eq!(deserialized.vec[0], 255);
    assert_eq!(deserialized.vec[2], 128);
    assert!(deserialized.option.is_none());
    assert_eq!(u16::from(*deserialized.b), 9999);

    println!("Mixed struct option disabled test passed!");
}

#[test]
fn test_byte_len_calculation() {
    use light_zero_copy::init_mut::ZeroCopyNew;

    // Test SimpleVecStruct byte_len calculation
    let config = SimpleVecStructConfig {
        vec: 10, // Vec<u8> with capacity 10
    };

    let expected_size = 1 +  // a: u8 (meta field)
        4 + 10 + // vec: 4 bytes length + 10 bytes data
        2; // b: u16

    let calculated_size = SimpleVecStruct::byte_len(&config);
    assert_eq!(calculated_size, expected_size);
    println!(
        "SimpleVecStruct byte_len: calculated={}, expected={}",
        calculated_size, expected_size
    );

    // Test SimpleOptionStruct byte_len calculation
    let config_some = SimpleOptionStructConfig {
        option: true, // Option<u64> enabled
    };

    let expected_size_some = 1 +  // a: u8 (meta field)
        1 + 8; // option: 1 byte discriminant + 8 bytes u64

    let calculated_size_some = SimpleOptionStruct::byte_len(&config_some);
    assert_eq!(calculated_size_some, expected_size_some);
    println!(
        "SimpleOptionStruct (Some) byte_len: calculated={}, expected={}",
        calculated_size_some, expected_size_some
    );

    let config_none = SimpleOptionStructConfig {
        option: false, // Option<u64> disabled
    };

    let expected_size_none = 1 +  // a: u8 (meta field)
        1; // option: 1 byte discriminant for None

    let calculated_size_none = SimpleOptionStruct::byte_len(&config_none);
    assert_eq!(calculated_size_none, expected_size_none);
    println!(
        "SimpleOptionStruct (None) byte_len: calculated={}, expected={}",
        calculated_size_none, expected_size_none
    );

    // Test MixedStruct byte_len calculation
    let config_mixed = MixedStructConfig {
        vec: 5,       // Vec<u8> with capacity 5
        option: true, // Option<u64> enabled
    };

    let expected_size_mixed = 1 +      // a: u8 (meta field)
        4 + 5 +  // vec: 4 bytes length + 5 bytes data
        1 + 8 +  // option: 1 byte discriminant + 8 bytes u64
        2; // b: u16

    let calculated_size_mixed = MixedStruct::byte_len(&config_mixed);
    assert_eq!(calculated_size_mixed, expected_size_mixed);
    println!(
        "MixedStruct byte_len: calculated={}, expected={}",
        calculated_size_mixed, expected_size_mixed
    );

    println!("All byte_len calculation tests passed!");
}

#[test]
fn test_dynamic_buffer_allocation_with_byte_len() {
    use light_zero_copy::init_mut::ZeroCopyNew;

    // Example of how to use byte_len for dynamic buffer allocation
    let config = MixedStructConfig {
        vec: 12,      // Vec<u8> with capacity 12
        option: true, // Option<u64> enabled
    };

    // Calculate the exact buffer size needed
    let required_size = MixedStruct::byte_len(&config);
    println!("Required buffer size: {} bytes", required_size);

    // Allocate exactly the right amount of memory
    let mut bytes = vec![0u8; required_size];

    // Initialize the structure
    let result = MixedStruct::new_zero_copy(&mut bytes, config);
    assert!(result.is_ok());
    let (mut mixed_struct, remaining) = result.unwrap();

    // Verify we used exactly the right amount of bytes (no remaining bytes)
    assert_eq!(
        remaining.len(),
        0,
        "Should have used exactly the calculated number of bytes"
    );

    // Set some values to verify it works
    mixed_struct.__meta.a = 42;
    mixed_struct.vec[5] = 123;
    if let Some(ref mut opt_val) = mixed_struct.option {
        **opt_val = 9999u64.into();
    }
    *mixed_struct.b = 7777u16.into();

    // Verify round-trip works
    let (deserialized, _) = MixedStruct::zero_copy_at_mut(&mut bytes).unwrap();
    assert_eq!(u8::from(deserialized.__meta.a), 42);
    assert_eq!(deserialized.vec[5], 123);
    if let Some(ref opt_val) = deserialized.option {
        assert_eq!(u64::from(**opt_val), 9999);
    }
    assert_eq!(u16::from(*deserialized.b), 7777);

    println!("Dynamic buffer allocation test passed!");
}
