#![cfg(feature = "mut")]
use std::assert_eq;

use borsh::BorshDeserialize;
use light_zero_copy::{borsh::Deserialize, init_mut::ZeroCopyNew};
use rand::{
    rngs::{StdRng, ThreadRng},
    Rng,
};

mod instruction_data;
use instruction_data::{
    CompressedAccount,
    CompressedAccountConfig,
    CompressedAccountData,
    CompressedAccountDataConfig,
    CompressedCpiContext,
    CompressedCpiContextConfig,
    CompressedProof,
    CompressedProofConfig,
    InstructionDataInvoke,
    // Config types (generated by ZeroCopyNew derive)
    InstructionDataInvokeConfig,
    InstructionDataInvokeCpi,
    InstructionDataInvokeCpiConfig,
    NewAddressParamsPacked,
    NewAddressParamsPackedConfig,
    OutputCompressedAccountWithPackedContext,
    OutputCompressedAccountWithPackedContextConfig,
    PackedCompressedAccountWithMerkleContext,
    PackedCompressedAccountWithMerkleContextConfig,
    PackedMerkleContext,
    PackedMerkleContextConfig,
    Pubkey,
    // Zero-copy mutable types
    ZInstructionDataInvokeCpiMut,
    ZInstructionDataInvokeMut,
};

// Function to populate mutable zero-copy structure with data from InstructionDataInvokeCpi
fn populate_invoke_cpi_zero_copy(
    src: &InstructionDataInvokeCpi,
    dst: &mut ZInstructionDataInvokeCpiMut,
) {
    *dst.is_compress = if src.is_compress { 1 } else { 0 };

    // Copy proof if present
    if let (Some(src_proof), Some(dst_proof)) = (&src.proof, &mut dst.proof) {
        dst_proof.a.copy_from_slice(&src_proof.a);
        dst_proof.b.copy_from_slice(&src_proof.b);
        dst_proof.c.copy_from_slice(&src_proof.c);
    }

    // Copy new_address_params
    for (src_param, dst_param) in src
        .new_address_params
        .iter()
        .zip(dst.new_address_params.iter_mut())
    {
        dst_param.seed.copy_from_slice(&src_param.seed);
        dst_param.address_queue_account_index = src_param.address_queue_account_index;
        dst_param.address_merkle_tree_account_index = src_param.address_merkle_tree_account_index;
        dst_param.address_merkle_tree_root_index = src_param.address_merkle_tree_root_index.into();
    }

    // Copy input_compressed_accounts_with_merkle_context
    for (src_input, dst_input) in src
        .input_compressed_accounts_with_merkle_context
        .iter()
        .zip(dst.input_compressed_accounts_with_merkle_context.iter_mut())
    {
        // Copy compressed account
        dst_input
            .compressed_account
            .owner
            .copy_from_slice(&src_input.compressed_account.owner);
        dst_input.compressed_account.lamports = src_input.compressed_account.lamports.into();

        // Copy address if present
        if let (Some(src_addr), Some(dst_addr)) = (
            &src_input.compressed_account.address,
            &mut dst_input.compressed_account.address,
        ) {
            dst_addr.copy_from_slice(src_addr);
        }

        // Copy data if present
        if let (Some(src_data), Some(dst_data)) = (
            &src_input.compressed_account.data,
            &mut dst_input.compressed_account.data,
        ) {
            dst_data
                .discriminator
                .copy_from_slice(&src_data.discriminator);
            dst_data.data_hash.copy_from_slice(&src_data.data_hash);
            for (src_byte, dst_byte) in src_data.data.iter().zip(dst_data.data.iter_mut()) {
                *dst_byte = *src_byte;
            }
        }

        // Copy merkle context
        dst_input.merkle_context.merkle_tree_pubkey_index =
            src_input.merkle_context.merkle_tree_pubkey_index;
        dst_input.merkle_context.nullifier_queue_pubkey_index =
            src_input.merkle_context.nullifier_queue_pubkey_index;
        dst_input.merkle_context.leaf_index = src_input.merkle_context.leaf_index.into();
        dst_input.merkle_context.prove_by_index = if src_input.merkle_context.prove_by_index {
            1
        } else {
            0
        };

        *dst_input.root_index = src_input.root_index.into();
        *dst_input.read_only = if src_input.read_only { 1 } else { 0 };
    }

    // Copy output_compressed_accounts
    for (src_output, dst_output) in src
        .output_compressed_accounts
        .iter()
        .zip(dst.output_compressed_accounts.iter_mut())
    {
        // Copy compressed account
        dst_output
            .compressed_account
            .owner
            .copy_from_slice(&src_output.compressed_account.owner);
        dst_output.compressed_account.lamports = src_output.compressed_account.lamports.into();

        // Copy address if present
        if let (Some(src_addr), Some(dst_addr)) = (
            &src_output.compressed_account.address,
            &mut dst_output.compressed_account.address,
        ) {
            dst_addr.copy_from_slice(src_addr);
        }

        // Copy data if present
        if let (Some(src_data), Some(dst_data)) = (
            &src_output.compressed_account.data,
            &mut dst_output.compressed_account.data,
        ) {
            dst_data
                .discriminator
                .copy_from_slice(&src_data.discriminator);
            dst_data.data_hash.copy_from_slice(&src_data.data_hash);
            for (src_byte, dst_byte) in src_data.data.iter().zip(dst_data.data.iter_mut()) {
                *dst_byte = *src_byte;
            }
        }

        *dst_output.merkle_tree_index = src_output.merkle_tree_index;
    }

    // Copy relay_fee if present
    if let (Some(src_fee), Some(dst_fee)) = (&src.relay_fee, &mut dst.relay_fee) {
        **dst_fee = (*src_fee).into();
    }

    // Copy compress_or_decompress_lamports if present
    if let (Some(src_lamports), Some(dst_lamports)) = (
        &src.compress_or_decompress_lamports,
        &mut dst.compress_or_decompress_lamports,
    ) {
        **dst_lamports = (*src_lamports).into();
    }

    // Copy cpi_context if present
    if let (Some(src_ctx), Some(dst_ctx)) = (&src.cpi_context, &mut dst.cpi_context) {
        dst_ctx.set_context = if src_ctx.set_context { 1 } else { 0 };
        dst_ctx.first_set_context = if src_ctx.first_set_context { 1 } else { 0 };
        dst_ctx.cpi_context_account_index = src_ctx.cpi_context_account_index;
    }
}

// Function to populate mutable zero-copy structure with data from InstructionDataInvoke
fn populate_invoke_zero_copy(src: &InstructionDataInvoke, dst: &mut ZInstructionDataInvokeMut) {
    *dst.is_compress = if src.is_compress { 1 } else { 0 };

    // Copy proof if present
    if let (Some(src_proof), Some(dst_proof)) = (&src.proof, &mut dst.proof) {
        dst_proof.a.copy_from_slice(&src_proof.a);
        dst_proof.b.copy_from_slice(&src_proof.b);
        dst_proof.c.copy_from_slice(&src_proof.c);
    }

    // Copy new_address_params
    for (src_param, dst_param) in src
        .new_address_params
        .iter()
        .zip(dst.new_address_params.iter_mut())
    {
        dst_param.seed.copy_from_slice(&src_param.seed);
        dst_param.address_queue_account_index = src_param.address_queue_account_index;
        dst_param.address_merkle_tree_account_index = src_param.address_merkle_tree_account_index;
        dst_param.address_merkle_tree_root_index = src_param.address_merkle_tree_root_index.into();
    }

    // Copy input_compressed_accounts_with_merkle_context
    for (src_input, dst_input) in src
        .input_compressed_accounts_with_merkle_context
        .iter()
        .zip(dst.input_compressed_accounts_with_merkle_context.iter_mut())
    {
        // Copy compressed account
        dst_input
            .compressed_account
            .owner
            .copy_from_slice(&src_input.compressed_account.owner);
        dst_input.compressed_account.lamports = src_input.compressed_account.lamports.into();

        // Copy address if present
        if let (Some(src_addr), Some(dst_addr)) = (
            &src_input.compressed_account.address,
            &mut dst_input.compressed_account.address,
        ) {
            dst_addr.copy_from_slice(src_addr);
        }

        // Copy data if present
        if let (Some(src_data), Some(dst_data)) = (
            &src_input.compressed_account.data,
            &mut dst_input.compressed_account.data,
        ) {
            dst_data
                .discriminator
                .copy_from_slice(&src_data.discriminator);
            dst_data.data_hash.copy_from_slice(&src_data.data_hash);
            for (src_byte, dst_byte) in src_data.data.iter().zip(dst_data.data.iter_mut()) {
                *dst_byte = *src_byte;
            }
        }

        // Copy merkle context
        dst_input.merkle_context.merkle_tree_pubkey_index =
            src_input.merkle_context.merkle_tree_pubkey_index;
        dst_input.merkle_context.nullifier_queue_pubkey_index =
            src_input.merkle_context.nullifier_queue_pubkey_index;
        dst_input.merkle_context.leaf_index = src_input.merkle_context.leaf_index.into();
        dst_input.merkle_context.prove_by_index = if src_input.merkle_context.prove_by_index {
            1
        } else {
            0
        };

        *dst_input.root_index = src_input.root_index.into();
        *dst_input.read_only = if src_input.read_only { 1 } else { 0 };
    }

    // Copy output_compressed_accounts
    for (src_output, dst_output) in src
        .output_compressed_accounts
        .iter()
        .zip(dst.output_compressed_accounts.iter_mut())
    {
        // Copy compressed account
        dst_output
            .compressed_account
            .owner
            .copy_from_slice(&src_output.compressed_account.owner);
        dst_output.compressed_account.lamports = src_output.compressed_account.lamports.into();

        // Copy address if present
        if let (Some(src_addr), Some(dst_addr)) = (
            &src_output.compressed_account.address,
            &mut dst_output.compressed_account.address,
        ) {
            dst_addr.copy_from_slice(src_addr);
        }

        // Copy data if present
        if let (Some(src_data), Some(dst_data)) = (
            &src_output.compressed_account.data,
            &mut dst_output.compressed_account.data,
        ) {
            dst_data
                .discriminator
                .copy_from_slice(&src_data.discriminator);
            dst_data.data_hash.copy_from_slice(&src_data.data_hash);
            for (src_byte, dst_byte) in src_data.data.iter().zip(dst_data.data.iter_mut()) {
                *dst_byte = *src_byte;
            }
        }

        *dst_output.merkle_tree_index = src_output.merkle_tree_index;
    }

    // Copy relay_fee if present
    if let (Some(src_fee), Some(dst_fee)) = (&src.relay_fee, &mut dst.relay_fee) {
        **dst_fee = (*src_fee).into();
    }

    // Copy compress_or_decompress_lamports if present
    if let (Some(src_lamports), Some(dst_lamports)) = (
        &src.compress_or_decompress_lamports,
        &mut dst.compress_or_decompress_lamports,
    ) {
        **dst_lamports = (*src_lamports).into();
    }
}

fn get_rnd_instruction_data_invoke_cpi(rng: &mut StdRng) -> InstructionDataInvokeCpi {
    InstructionDataInvokeCpi {
        proof: Some(CompressedProof {
            a: rng.gen(),
            b: (0..64)
                .map(|_| rng.gen())
                .collect::<Vec<u8>>()
                .try_into()
                .unwrap(),
            c: rng.gen(),
        }),
        new_address_params: vec![get_rnd_new_address_params(rng); rng.gen_range(0..10)],
        input_compressed_accounts_with_merkle_context: vec![
            get_rnd_test_input_account(rng);
            rng.gen_range(0..10)
        ],
        output_compressed_accounts: vec![get_rnd_test_output_account(rng); rng.gen_range(0..10)],
        relay_fee: None,
        compress_or_decompress_lamports: rng.gen(),
        is_compress: rng.gen(),
        cpi_context: Some(get_rnd_cpi_context(rng)),
    }
}

fn get_rnd_cpi_context(rng: &mut StdRng) -> CompressedCpiContext {
    CompressedCpiContext {
        first_set_context: rng.gen(),
        set_context: rng.gen(),
        cpi_context_account_index: rng.gen(),
    }
}

fn get_rnd_test_account_data(rng: &mut StdRng) -> CompressedAccountData {
    CompressedAccountData {
        discriminator: rng.gen(),
        data: (0..100).map(|_| rng.gen()).collect::<Vec<u8>>(),
        data_hash: rng.gen(),
    }
}

fn get_rnd_test_account(rng: &mut StdRng) -> CompressedAccount {
    CompressedAccount {
        owner: Pubkey::new_unique().to_bytes(),
        lamports: rng.gen(),
        address: Some(Pubkey::new_unique().to_bytes()),
        data: Some(get_rnd_test_account_data(rng)),
    }
}

fn get_rnd_test_output_account(rng: &mut StdRng) -> OutputCompressedAccountWithPackedContext {
    OutputCompressedAccountWithPackedContext {
        compressed_account: get_rnd_test_account(rng),
        merkle_tree_index: rng.gen(),
    }
}

fn get_rnd_test_input_account(rng: &mut StdRng) -> PackedCompressedAccountWithMerkleContext {
    PackedCompressedAccountWithMerkleContext {
        compressed_account: CompressedAccount {
            owner: Pubkey::new_unique().to_bytes(),
            lamports: 100,
            address: Some(Pubkey::new_unique().to_bytes()),
            data: Some(get_rnd_test_account_data(rng)),
        },
        merkle_context: PackedMerkleContext {
            merkle_tree_pubkey_index: rng.gen(),
            nullifier_queue_pubkey_index: rng.gen(),
            leaf_index: rng.gen(),
            prove_by_index: rng.gen(),
        },
        root_index: rng.gen(),
        read_only: false,
    }
}

fn get_rnd_new_address_params(rng: &mut StdRng) -> NewAddressParamsPacked {
    NewAddressParamsPacked {
        seed: rng.gen(),
        address_queue_account_index: rng.gen(),
        address_merkle_tree_account_index: rng.gen(),
        address_merkle_tree_root_index: rng.gen(),
    }
}

// Generate config for InstructionDataInvoke based on the actual data
fn generate_random_invoke_config(
    invoke_ref: &InstructionDataInvoke,
) -> InstructionDataInvokeConfig {
    InstructionDataInvokeConfig {
        proof: (invoke_ref.proof.is_some(), CompressedProofConfig {}),
        input_compressed_accounts_with_merkle_context: invoke_ref
            .input_compressed_accounts_with_merkle_context
            .iter()
            .map(|account| PackedCompressedAccountWithMerkleContextConfig {
                compressed_account: CompressedAccountConfig {
                    address: (account.compressed_account.address.is_some(), ()),
                    data: (
                        account.compressed_account.data.is_some(),
                        CompressedAccountDataConfig {
                            data: account
                                .compressed_account
                                .data
                                .as_ref()
                                .map(|d| d.data.len() as u32)
                                .unwrap_or(0),
                        },
                    ),
                },
                merkle_context: PackedMerkleContextConfig {},
            })
            .collect(),
        output_compressed_accounts: invoke_ref
            .output_compressed_accounts
            .iter()
            .map(|account| OutputCompressedAccountWithPackedContextConfig {
                compressed_account: CompressedAccountConfig {
                    address: (account.compressed_account.address.is_some(), ()),
                    data: (
                        account.compressed_account.data.is_some(),
                        CompressedAccountDataConfig {
                            data: account
                                .compressed_account
                                .data
                                .as_ref()
                                .map(|d| d.data.len() as u32)
                                .unwrap_or(0),
                        },
                    ),
                },
            })
            .collect(),
        relay_fee: invoke_ref.relay_fee.is_some(),
        new_address_params: invoke_ref
            .new_address_params
            .iter()
            .map(|_| NewAddressParamsPackedConfig {})
            .collect(),
        compress_or_decompress_lamports: invoke_ref.compress_or_decompress_lamports.is_some(),
    }
}

// Generate config for InstructionDataInvokeCpi based on the actual data
fn generate_random_invoke_cpi_config(
    invoke_cpi_ref: &InstructionDataInvokeCpi,
) -> InstructionDataInvokeCpiConfig {
    InstructionDataInvokeCpiConfig {
        proof: (invoke_cpi_ref.proof.is_some(), CompressedProofConfig {}),
        new_address_params: invoke_cpi_ref
            .new_address_params
            .iter()
            .map(|_| NewAddressParamsPackedConfig {})
            .collect(),
        input_compressed_accounts_with_merkle_context: invoke_cpi_ref
            .input_compressed_accounts_with_merkle_context
            .iter()
            .map(|account| PackedCompressedAccountWithMerkleContextConfig {
                compressed_account: CompressedAccountConfig {
                    address: (account.compressed_account.address.is_some(), ()),
                    data: (
                        account.compressed_account.data.is_some(),
                        CompressedAccountDataConfig {
                            data: account
                                .compressed_account
                                .data
                                .as_ref()
                                .map(|d| d.data.len() as u32)
                                .unwrap_or(0),
                        },
                    ),
                },
                merkle_context: PackedMerkleContextConfig {},
            })
            .collect(),
        output_compressed_accounts: invoke_cpi_ref
            .output_compressed_accounts
            .iter()
            .map(|account| OutputCompressedAccountWithPackedContextConfig {
                compressed_account: CompressedAccountConfig {
                    address: (account.compressed_account.address.is_some(), ()),
                    data: (
                        account.compressed_account.data.is_some(),
                        CompressedAccountDataConfig {
                            data: account
                                .compressed_account
                                .data
                                .as_ref()
                                .map(|d| d.data.len() as u32)
                                .unwrap_or(0),
                        },
                    ),
                },
            })
            .collect(),
        relay_fee: invoke_cpi_ref.relay_fee.is_some(),
        compress_or_decompress_lamports: invoke_cpi_ref.compress_or_decompress_lamports.is_some(),
        cpi_context: (
            invoke_cpi_ref.cpi_context.is_some(),
            CompressedCpiContextConfig {},
        ),
    }
}

#[test]
fn test_invoke_ix_data_deserialize_rnd() {
    use rand::{rngs::StdRng, Rng, SeedableRng};
    let mut thread_rng = ThreadRng::default();
    let seed = thread_rng.gen();
    // Keep this print so that in case the test fails
    // we can use the seed to reproduce the error.
    println!("\n\ne2e test seed for invoke_ix_data {}\n\n", seed);
    let mut rng = StdRng::seed_from_u64(seed);

    let num_iters = 1000;
    for i in 0..num_iters {
        // Create randomized instruction data
        let invoke_ref = InstructionDataInvoke {
            proof: if rng.gen() {
                Some(CompressedProof {
                    a: rng.gen(),
                    b: (0..64)
                        .map(|_| rng.gen())
                        .collect::<Vec<u8>>()
                        .try_into()
                        .unwrap(),
                    c: rng.gen(),
                })
            } else {
                None
            },
            input_compressed_accounts_with_merkle_context: if i % 5 == 0 {
                // Only add inputs occasionally to keep test manageable
                vec![get_rnd_test_input_account(&mut rng); rng.gen_range(1..3)]
            } else {
                vec![]
            },
            output_compressed_accounts: if i % 4 == 0 {
                vec![get_rnd_test_output_account(&mut rng); rng.gen_range(1..3)]
            } else {
                vec![]
            },
            relay_fee: None, // Relay fee is currently not supported
            new_address_params: if i % 3 == 0 {
                vec![get_rnd_new_address_params(&mut rng); rng.gen_range(1..3)]
            } else {
                vec![]
            },
            compress_or_decompress_lamports: if rng.gen() { Some(rng.gen()) } else { None },
            is_compress: rng.gen(),
        };

        // 1. Generate config based on the random data
        let config = generate_random_invoke_config(&invoke_ref);

        // 2. Calculate exact buffer size and allocate
        let buffer_size = InstructionDataInvoke::byte_len(&config);
        let mut bytes = vec![0u8; buffer_size];

        // 3. Create mutable zero-copy structure and verify exact allocation
        {
            let result = InstructionDataInvoke::new_zero_copy(&mut bytes, config);
            assert!(result.is_ok(), "Failed to create zero-copy structure");
            let (mut zero_copy_mut, remaining) = result.unwrap();

            // 4. Verify exact buffer allocation
            assert_eq!(
                remaining.len(),
                0,
                "Should have used exactly {} bytes",
                buffer_size
            );

            // 5. Populate the mutable zero-copy structure with random data
            populate_invoke_zero_copy(&invoke_ref, &mut zero_copy_mut);
        }; // Mutable borrow ends here

        let borsh_ref = InstructionDataInvoke::deserialize(&mut bytes.as_slice()).unwrap();
        // 6. Test immutable deserialization to verify round-trip functionality
        let result_immut = InstructionDataInvoke::zero_copy_at(&bytes);
        assert!(
            result_immut.is_ok(),
            "Immutable deserialization should succeed"
        );
        assert_eq!(invoke_ref, borsh_ref);

        // 7. Test that basic zero-copy deserialization works without crashing
        // The main goal is to verify the zero-copy derive macro functionality
        println!("✓ Successfully tested InstructionDataInvoke with {} inputs, {} outputs, {} new_addresses",
                 invoke_ref.input_compressed_accounts_with_merkle_context.len(),
                 invoke_ref.output_compressed_accounts.len(),
                 invoke_ref.new_address_params.len());
    }
}

#[test]
fn test_instruction_data_invoke_cpi_rnd() {
    use rand::{rngs::StdRng, Rng, SeedableRng};
    let mut thread_rng = ThreadRng::default();
    let seed = thread_rng.gen();
    // Keep this print so that in case the test fails
    // we can use the seed to reproduce the error.
    println!("\n\ne2e test seed {}\n\n", seed);
    let mut rng = StdRng::seed_from_u64(seed);

    let num_iters = 10_000;
    for _ in 0..num_iters {
        // 1. Generate random CPI instruction data
        let invoke_cpi_ref = get_rnd_instruction_data_invoke_cpi(&mut rng);

        // 2. Generate config based on the random data
        let config = generate_random_invoke_cpi_config(&invoke_cpi_ref);

        // 3. Calculate exact buffer size and allocate
        let buffer_size = InstructionDataInvokeCpi::byte_len(&config);
        let mut bytes = vec![0u8; buffer_size];

        // 4. Create mutable zero-copy structure and verify exact allocation
        {
            let result = InstructionDataInvokeCpi::new_zero_copy(&mut bytes, config);
            assert!(result.is_ok(), "Failed to create CPI zero-copy structure");
            let (mut zero_copy_mut, remaining) = result.unwrap();

            // 5. Verify exact buffer allocation
            assert_eq!(
                remaining.len(),
                0,
                "Should have used exactly {} bytes",
                buffer_size
            );

            // 6. Populate the mutable zero-copy structure with random data
            populate_invoke_cpi_zero_copy(&invoke_cpi_ref, &mut zero_copy_mut);
        }; // Mutable borrow ends here

        let borsh_ref = InstructionDataInvokeCpi::deserialize(&mut bytes.as_slice()).unwrap();
        // 7. Test immutable deserialization to verify round-trip functionality
        let result_immut = InstructionDataInvokeCpi::zero_copy_at(&bytes);
        assert!(
            result_immut.is_ok(),
            "Immutable deserialization should succeed"
        );
        assert_eq!(invoke_cpi_ref, borsh_ref);

        // 8. Test that basic zero-copy deserialization works without crashing
        // The main goal is to verify the zero-copy derive macro functionality
        println!("✓ Successfully tested InstructionDataInvokeCpi with {} inputs, {} outputs, {} new_addresses",
                 invoke_cpi_ref.input_compressed_accounts_with_merkle_context.len(),
                 invoke_cpi_ref.output_compressed_accounts.len(),
                 invoke_cpi_ref.new_address_params.len());
    }
}
