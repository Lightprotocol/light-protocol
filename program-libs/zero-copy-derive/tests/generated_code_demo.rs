/*!
This test demonstrates what code gets generated by the enum ZeroCopy derive.

For this input:
```rust
#[derive(ZeroCopy)]
pub enum Action {
    MintTo(MintToAction),
    Update,
}
```

The macro generates:
```rust
// Type alias for pattern matching
pub type MintToType<'a> = <MintToAction as light_zero_copy::borsh::Deserialize<'a>>::Output;

#[derive(Debug, Clone, PartialEq)]
pub enum ZAction<'a> {
    MintTo(MintToType<'a>),  // Uses the type alias - no import needed!
    Update,
}
```

This solves both problems:
1. ✅ No import issues - uses qualified Deserialize::Output internally
2. ✅ Pattern matching works - concrete types via type aliases
*/

use light_zero_copy_derive::ZeroCopy;

#[derive(Debug, Clone, PartialEq, ZeroCopy)]
pub struct MintToAction {
    pub amount: u64,
    pub recipient: Vec<u8>,
}

#[derive(Debug, Clone, ZeroCopy)]
pub enum Action {
    MintTo(MintToAction),
    Update,
    CreateSplMint,
}

#[cfg(test)]
mod tests {
    use light_zero_copy::traits::ZeroCopyAt;

    use super::*;

    #[test]
    fn test_generated_type_aliases_work() {
        // The macro should generate:
        // - pub type MintToType<'a> = <MintToAction as Deserialize<'a>>::Output;
        // - enum ZAction<'a> { MintTo(MintToType<'a>), Update, CreateSplMint }
        // Test that we can deserialize without import issues
        let mut data = vec![0u8]; // MintTo discriminant
        data.extend_from_slice(&999u64.to_le_bytes());
        data.extend_from_slice(&4u32.to_le_bytes());
        data.extend_from_slice(b"user");

        let (result, remaining) = Action::zero_copy_at(&data).unwrap();
        assert_eq!(remaining.len(), 0);

        // The key insight: this should work without any imports because
        // the type alias MintToType<'a> resolves to the Deserialize::Output internally
        println!(
            "✅ Successfully deserialized with type aliases: {:?}",
            result
        );
    }

    #[test]
    fn test_pattern_matching_should_work() {
        // Test unit variant
        let data = [1u8]; // Update discriminant
        let (result, _) = Action::zero_copy_at(&data).unwrap();

        // This demonstrates the usage pattern:
        println!("Got action variant: {:?}", result);

        // In the user's code, this should work:
        // match result {
        //     ZAction::MintTo(mint_action) => {
        //         // mint_action has type MintToType<'_>
        //         // which is actually ZMintToAction<'_>
        //     }
        //     ZAction::Update => { /* handle */ }
        //     ZAction::CreateSplMint => { /* handle */ }
        // }
    }
}

/*
The generated code structure should be:

```rust
// Generated type aliases
pub type MintToType<'a> = <MintToAction as light_zero_copy::borsh::Deserialize<'a>>::Output;

// Generated enum
#[derive(Debug, Clone, PartialEq)]
pub enum ZAction<'a> {
    MintTo(MintToType<'a>),
    Update,
    CreateSplMint,
}

// Generated Deserialize impl
impl<'a> light_zero_copy::borsh::Deserialize<'a> for Action {
    type Output = ZAction<'a>;
    fn zero_copy_at(data: &'a [u8]) -> Result<(Self::Output, &'a [u8]), ZeroCopyError> {
        match data[0] {
            0 => {
                let (value, bytes) = MintToAction::zero_copy_at(&data[1..])?;
                Ok((ZAction::MintTo(value), bytes))
            }
            1 => Ok((ZAction::Update, &data[1..])),
            2 => Ok((ZAction::CreateSplMint, &data[1..])),
            _ => Err(ZeroCopyError::InvalidConversion),
        }
    }
}
```

This approach:
- ✅ Avoids import issues (uses qualified syntax in type alias)
- ✅ Enables pattern matching (concrete types via aliases)
- ✅ Maintains type safety (proper Deserialize trait usage)
*/
