# Initialize Address Tree

**path:** src/initialize_address_tree.rs

**description:**
Initializes an address tree with integrated address queue. This operation creates **one Solana account**:

**Address Merkle tree account** (`BatchedMerkleTreeAccount`) - Stores tree roots, root history, and integrated address queue (bloom filters + hash chains for addresses)
- Account layout `BatchedMerkleTreeAccount` defined in: src/merkle_tree.rs
- Metadata `BatchedMerkleTreeMetadata` defined in: src/merkle_tree_metadata.rs
- Tree type: `TreeType::AddressV2` (5)
- Initial root: `ADDRESS_TREE_INIT_ROOT_40` (pre-initialized with one indexed array element)
- Starts at next_index: 1 (index 0 contains sentinel element)
- Discriminator: b`BatchMta` `[66, 97, 116, 99, 104, 77, 116, 97]` (8 bytes)

Address trees are used for address registration in the Light Protocol. New addresses are inserted into the address queue, then batch-updated into the tree with ZKPs. Unlike state trees, address trees have no separate output queue - the address queue is integrated into the tree account.

**Instruction data:**
Instruction data is defined in: src/initialize_address_tree.rs

`InitAddressTreeAccountsInstructionData` struct:

**Tree configuration:**
- `height`: u32 - Tree height (default: 40, capacity = 2^40 leaves)
- `index`: u64 - Unchecked identifier of the address tree
- `root_history_capacity`: u32 - Size of root history cyclic buffer (default: 200)

**Batch sizes:**
- `input_queue_batch_size`: u64 - Elements per address queue batch (default: 15,000)
- `input_queue_zkp_batch_size`: u64 - Elements per ZKP batch for address insertions (default: 250)

**Validation:** Batch size must be divisible by ZKP batch size. Error: `BatchSizeNotDivisibleByZkpBatchSize` if validation fails.

**Bloom filter configuration:**
- `bloom_filter_capacity`: u64 - Capacity in bits (default: batch_size * 8)
- `bloom_filter_num_iters`: u64 - Number of hash functions (default: 3 for test, 10 for production)

**Validation:**
- Capacity must be divisible by 8
- Capacity must be >= batch_size * 8

**Access control:**
- `program_owner`: Option<Pubkey> - Optional program owning the tree
- `forester`: Option<Pubkey> - Optional forester pubkey for non-Light foresters
- `owner`: Pubkey - Account owner (passed separately as function parameter, not in struct)

**Rollover and fees:**
- `rollover_threshold`: Option<u64> - Percentage threshold for rollover (default: 95%)
- `network_fee`: Option<u64> - Network fee amount (default: 10,000 lamports)
- `close_threshold`: Option<u64> - Placeholder, unimplemented

**Accounts:**
1. merkle_tree_account
   - mutable
   - Address Merkle tree account being initialized
   - Must be rent-exempt for calculated size

Note: No signer accounts required - account is expected to be pre-created with correct size

**Instruction Logic and Checks:**

1. **Calculate account size:**
   - Merkle tree account size: Based on input_queue_batch_size, bloom_filter_capacity, input_queue_zkp_batch_size, root_history_capacity, and height
   - Account size formula defined in: src/merkle_tree.rs (`get_merkle_tree_account_size`)

2. **Verify rent exemption:**
   - Check: merkle_tree_account balance >= minimum rent exemption for mt_account_size
   - Uses: `check_account_balance_is_rent_exempt` from `light-account-checks`
   - Store rent amount for rollover fee calculation

3. **Initialize address Merkle tree account:**
   - Set discriminator: `BatchMta` (8 bytes)
   - Create tree metadata:
     - tree_type: `TreeType::AddressV2` (5)
     - associated_queue: Pubkey::default() (address trees have no separate queue)
     - Calculate rollover_fee: Based on rollover_threshold, height, and merkle_tree_rent
     - access_metadata: Set owner, program_owner, forester
     - rollover_metadata: Set index, rollover_fee, rollover_threshold, network_fee, close_threshold, additional_bytes=None
   - Initialize root history: Cyclic buffer with capacity=root_history_capacity, first entry = `ADDRESS_TREE_INIT_ROOT_40`
   - Initialize integrated address queue:
     - 2 bloom filter stores (one per batch), size = bloom_filter_capacity / 8 bytes each
     - 2 hash chain stores (one per batch), capacity = (input_queue_batch_size / input_queue_zkp_batch_size) each
     - Batch metadata with input_queue_batch_size and input_queue_zkp_batch_size
   - Compute hashed_pubkey: Hash and truncate to 31 bytes for bn254 field compatibility
   - next_index: 1 (starts at 1 because index 0 contains pre-initialized sentinel element)
   - sequence_number: 0 (increments with each tree update)
   - Rollover fee: Charged on address tree operations

4. **Validate configurations:**
   - root_history_capacity >= (input_queue_batch_size / input_queue_zkp_batch_size)
   - Rationale: Ensures sufficient space for roots generated by address queue operations
   - ZKP batch sizes must be 10 or 250 (only supported circuit sizes for address trees)
   - height must be 40 (fixed for address trees)

**Errors:**
- `AccountError::AccountNotRentExempt` (error code: 12011) - Account balance insufficient for rent exemption at calculated size
- `AccountError::InvalidAccountSize` (error code: 12006) - Account data length doesn't match calculated size requirements
- `BatchedMerkleTreeError::BatchSizeNotDivisibleByZkpBatchSize` (error code: 14305) - Batch size is not evenly divisible by ZKP batch size
- `MerkleTreeMetadataError::InvalidRolloverThreshold` - Rollover threshold value is invalid (must be percentage)
- `ZeroCopyError::Size` - Account size mismatch during zero-copy deserialization
- `BorshError` - Failed to serialize or deserialize metadata structures
