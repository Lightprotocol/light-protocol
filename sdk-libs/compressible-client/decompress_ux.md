# Decompress UX Improvement: `from_seeds` Pattern

## Problem

Current decompress flow is verbose and redundant:

```rust
// 1. Create interface
let user_interface = AccountInterface::cold(user_record_pda, compressed_user.clone());

// 2. Extract data, call constructor, pass seeds
let user_variant = CompressedAccountVariant::user_record(
    user_interface.compressed_data().unwrap(),  // extract data
    UserRecordSeeds { authority, mint_authority, owner, category_id },
)?;

// 3. Combine interface + variant
RentFreeDecompressAccount::new(user_interface, user_variant)
```

**Issues:**

- 3 separate steps per account
- `compressed_data()` extraction is boilerplate
- Interface passed twice conceptually (once for data, once for wrapper)

## Solution: `from_seeds` Pattern

```rust
RentFreeDecompressAccount::from_seeds(
    AccountInterface::cold(user_record_pda, compressed_user),
    UserRecordSeeds { authority, mint_authority, owner, category_id },
)?
```

**Single call.** The `Seeds` type (already generated by macro) tells us which variant to construct.

## Design

### 1. Trait Definition (SBF-compatible)

Location: `light-sdk/src/compressible/mod.rs`

```rust
/// Trait for seeds that can construct a compressed account variant.
/// Implemented by generated `XxxSeeds` structs.
pub trait IntoVariant<V> {
    /// Construct variant from compressed account data bytes and these seeds.
    fn into_variant(self, data: &[u8]) -> Result<V, anchor_lang::error::Error>;
}
```

This trait is SBF-compatible because:

- No client-crate dependencies
- Just takes `&[u8]` and returns variant
- Lives in `light-sdk` which is already program-side

### 2. Macro Generates Trait Impl

Location: `sdk-libs/macros/src/compressible/instructions.rs`

Currently generates:

```rust
pub struct UserRecordSeeds {
    pub authority: Pubkey,
    pub mint_authority: Pubkey,
    pub owner: Pubkey,
    pub category_id: u64,
}

impl CompressedAccountVariant {
    pub fn user_record(data: &[u8], seeds: UserRecordSeeds) -> Result<Self, Error> {
        // deserialize, verify seeds, construct variant
    }
}
```

**Add trait impl:**

```rust
impl light_sdk::compressible::IntoVariant<CompressedAccountVariant> for UserRecordSeeds {
    fn into_variant(self, data: &[u8]) -> Result<CompressedAccountVariant, Error> {
        CompressedAccountVariant::user_record(data, self)
    }
}
```

### 3. Client Helper Method

Location: `light-compressible-client/src/lib.rs`

```rust
impl<V> RentFreeDecompressAccount<V> {
    /// Create decompression request from account interface and seeds.
    ///
    /// The seeds type determines which variant constructor to call.
    /// Data is extracted from interface, passed to `IntoVariant::into_variant()`.
    pub fn from_seeds<S>(
        interface: AccountInterface,
        seeds: S,
    ) -> Result<Self, anchor_lang::error::Error>
    where
        S: light_sdk::compressible::IntoVariant<V>,
    {
        let data = interface
            .compressed_data()
            .ok_or_else(|| anchor_lang::error::Error::from(
                anchor_lang::error::ErrorCode::AccountNotInitialized
            ))?;
        let variant = seeds.into_variant(data)?;
        Ok(Self::new(interface, variant))
    }
}
```

### 4. CToken Handling

CToken accounts store `TokenData` in their compressed bytes. Parse internally - no separate `token_data` param needed.

```rust
impl<V> RentFreeDecompressAccount<V> {
    /// Create decompression request for CToken account.
    /// Parses TokenData from interface.compressed_data() internally.
    pub fn from_ctoken<T>(
        interface: AccountInterface,
        ctoken_variant: T,
    ) -> Result<Self, Error>
    where
        T: IntoCTokenVariant<V>,
    {
        let data = interface.compressed_data()
            .ok_or(Error::AccountNotCompressed)?;
        let token_data = TokenData::try_from_slice(data)?;
        let variant = ctoken_variant.into_ctoken_variant(token_data);
        Ok(Self::new(interface, variant))
    }
}
```

**Trait (generated by macro):**

```rust
pub trait IntoCTokenVariant<V> {
    fn into_ctoken_variant(self, token_data: TokenData) -> V;
}

// Generated by macro
impl IntoCTokenVariant<CompressedAccountVariant> for TokenAccountVariant {
    fn into_ctoken_variant(self, token_data: TokenData) -> CompressedAccountVariant {
        CompressedAccountVariant::CTokenData(CTokenData {
            variant: self,
            token_data,
        })
    }
}
```

Usage:

```rust
RentFreeDecompressAccount::from_ctoken(
    AccountInterface::cold(vault_pda, compressed_vault.account),
    TokenAccountVariant::Vault { cmint: cmint_pda },
)?
```

## Final API

### Before (verbose)

```rust
let user_interface = AccountInterface::cold(user_record_pda, compressed_user.clone());
let game_interface = AccountInterface::cold(game_session_pda, compressed_game.clone());
let vault_interface = AccountInterface::cold(vault_pda, compressed_vault.account.clone());

let user_variant = CompressedAccountVariant::user_record(
    user_interface.compressed_data().unwrap(),
    UserRecordSeeds { authority, mint_authority, owner, category_id },
)?;
let game_variant = CompressedAccountVariant::game_session(
    game_interface.compressed_data().unwrap(),
    GameSessionSeeds { user, authority, session_id },
)?;
let vault_ctoken_data = CTokenData {
    variant: TokenAccountVariant::Vault { cmint: cmint_pda },
    token_data: compressed_vault.token.clone(),
};

let decompress_accounts = vec![
    RentFreeDecompressAccount::new(user_interface, user_variant),
    RentFreeDecompressAccount::new(game_interface, game_variant),
    RentFreeDecompressAccount::new(vault_interface, CompressedAccountVariant::CTokenData(vault_ctoken_data)),
];
```

### After (clean)

```rust
let decompress_accounts = vec![
    RentFreeDecompressAccount::from_seeds(
        AccountInterface::cold(user_record_pda, compressed_user),
        UserRecordSeeds { authority, mint_authority, owner, category_id },
    )?,
    RentFreeDecompressAccount::from_seeds(
        AccountInterface::cold(game_session_pda, compressed_game),
        GameSessionSeeds { user, authority, session_id },
    )?,
    RentFreeDecompressAccount::from_ctoken(
        AccountInterface::cold(vault_pda, compressed_vault.account),
        TokenAccountVariant::Vault { cmint: cmint_pda },
    )?,
];
```

**Reduction:** ~25 lines → ~12 lines (52% less)
**Cognitive load:** 3 concepts → 1 concept per account
**Redundant data passing:** Eliminated

## Implementation Checklist

1. **Add `IntoVariant` trait to `light-sdk`**
   - File: `sdk-libs/sdk/src/compressible/mod.rs`
   - SBF-compatible, no client deps

2. **Add `IntoCTokenVariant` trait to `light-sdk`**
   - Same file
   - For CToken variant construction

3. **Update macro to generate `IntoVariant` impl**
   - File: `sdk-libs/macros/src/compressible/instructions.rs`
   - Add impl alongside existing `UserRecordSeeds` struct

4. **Update macro to generate `IntoCTokenVariant` impl**
   - Same file
   - For `TokenAccountVariant`

5. **Add `from_seeds` method to `RentFreeDecompressAccount`**
   - File: `sdk-libs/compressible-client/src/lib.rs`
   - Uses trait bound `S: IntoVariant<V>`

6. **Add `from_ctoken` method to `RentFreeDecompressAccount`**
   - Same file
   - Uses trait bound `T: IntoCTokenVariant<V>`

7. **Update test to use new API**
   - File: `sdk-tests/csdk-anchor-full-derived-test/tests/basic_test.rs`

## Compatibility

- **SBF programs:** No changes needed. Traits in `light-sdk` are SBF-compatible.
- **Existing code:** `::new()` still works. `from_seeds` is additive.
- **Migration:** Optional. Users can adopt incrementally.

## Error Handling

Both methods return `Result` because:

**`from_seeds`:**

1. `compressed_data()` might be `None` (hot account passed to cold-only method)
2. `into_variant()` can fail (seed verification, deserialization)

**`from_ctoken`:**

1. `compressed_data()` might be `None` (hot account passed)
2. `TokenData::try_from_slice()` can fail (malformed data)

## Rating: 9/10

### Pros

- **Consistent**: Both use `AccountInterface` first arg
- **Minimal**: Single call per account, no intermediate vars
- **Type-safe**: Traits enforce correct mapping
- **SBF-compatible**: Traits in light-sdk, impl in macro
- **Clear intent**: `from_seeds` vs `from_ctoken`

### Cons

- CToken still needs `.account` extraction from `CompressedTokenAccount`
- Re-parses `TokenData` from bytes (indexer already parsed, but keeps API uniform)
- Two traits to maintain (hidden from user)
