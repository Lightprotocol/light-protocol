# Light SDK Macros - Compressible System Redesign Specification

## Executive Summary

This document specifies the redesign of the Light SDK macro system for compressible accounts. The goal is to simplify the developer experience while maintaining full functionality and robustness.

## Table of Contents

1. [Current State Analysis](#current-state-analysis)
2. [Design Principles](#design-principles)
3. [The Correct Design](#the-correct-design)
4. [Edge Cases](#edge-cases)
5. [Migration Path](#migration-path)
6. [Implementation Steps](#implementation-steps)
7. [Testing Strategy](#testing-strategy)

---

## 1. Current State Analysis

### 1.1 Current Macro Inventory

| Macro | Status | Purpose |
|-------|--------|---------|
| `#[derive(LightHasher)]` | KEEP | Poseidon hashing for structs |
| `#[derive(LightHasherSha)]` | KEEP | SHA256 hashing for structs |
| `#[derive(LightDiscriminator)]` | KEEP | Unique discriminator for accounts |
| `#[derive(Compressible)]` | KEEP | HasCompressionInfo + CompressAs + Size + CompressedInitSpace |
| `#[derive(CompressiblePack)]` | KEEP | Pack/Unpack traits for Pubkey compression |
| `#[add_compressible_instructions]` | RENAME to `#[compressible]` | Program-level registration + instruction generation |
| `#[derive(HasCompressionInfo)]` | DEPRECATE | Subsumed by Compressible |
| `#[derive(CompressAs)]` | DEPRECATE | Subsumed by Compressible |
| `#[derive(DecompressContext)]` | DEPRECATE | Auto-generated by compressible |
| `#[derive(LightFinalize)]` | KEEP | For init instructions with light-mints |
| `#[light_instruction]` | KEEP | Auto-calls light_finalize |
| `#[light_system_accounts]` | DEPRECATED | Legacy v1 |
| `#[light_accounts]` | DEPRECATED | Legacy v1 |
| `#[derive(LightAccounts)]` | DEPRECATED | Legacy v1 |
| `#[derive(LightTraits)]` | DEPRECATED | Legacy v1 |
| `#[light_program]` | DEPRECATED | Not used |
| `#[account]` | REMOVE | Collides with Anchor |

### 1.2 Current Usage Patterns

**Account Definition (state.rs):**
```rust
#[derive(
    Default, Debug, LightHasher, LightDiscriminator, InitSpace, Compressible, CompressiblePack,
)]
#[account]
pub struct PoolState {
    pub amm_config: Pubkey,
    pub token_0_mint: Pubkey,
    pub token_1_mint: Pubkey,
    #[skip]
    pub compression_info: Option<CompressionInfo>,
}
```

**Program Registration (lib.rs):**
```rust
#[add_compressible_instructions(
    PoolState = (POOL_SEED, ctx.accounts.amm_config, ctx.accounts.token_0_mint, ctx.accounts.token_1_mint),
    Token0Vault = (is_token, POOL_VAULT_SEED, ctx.accounts.pool_state, ctx.accounts.token_0_mint, authority = AUTH_SEED),
    ATA = (is_token, is_ata),
)]
#[program]
pub mod my_program { ... }
```

### 1.3 Key Insight: Why Seeds Must Be Program-Level

**DECOMPRESS** unpacks compressed data into `data: T`, then calls `data.derive_pda_seeds_with_accounts(...)`.

While `self` refers to the unpacked compressed data (not on-chain account), the system uses `ctx.accounts.*` because:

1. **Tokens REQUIRE external accounts** - Token vault seeds reference `ctx.accounts.pool_state`, which isn't stored in the token data
2. **Validation** - Instruction accounts provide external validation that the caller is working with correct entities  
3. **Consistency** - One pattern for all account types

For **COMPRESS**, seeds aren't needed - the Light address is derived from the existing PDA's pubkey directly.

**Therefore: Program-level definition is the ONLY correct place for seeds.**

---

## 2. Design Principles

### 2.1 Core Pillars

1. **Internal Simplicity**: Robust, simple, and performant beats complexity
2. **External Simplicity (UX)**: Straightforward for developers, hard to make mistakes, minimal redundancy
3. **Single Source of Truth**: One place defines seeds - program level
4. **Auditability**: Contained logic, DRY where possible
5. **Backward Compatibility**: Existing programs continue to work during migration

### 2.2 Non-Goals

- Account-level seed definition (impossible for decompress of tokens)
- Multiple paths for the same functionality
- Implicit behavior that's hard to audit

---

## 3. The Correct Design

### 3.1 Account Definition (Simplified)

**NEW (Proposed):**
```rust
#[derive(LightCompressible)]  // NEW: Consolidates all traits
#[compress_as(start_time = 0)]  // Optional: custom compression behavior
#[account]
pub struct GameSession {
    pub session_id: u64,
    #[hash]
    pub player: Pubkey,
    pub start_time: u64,
    #[skip]
    pub compression_info: Option<CompressionInfo>,
}
```

**`#[derive(LightCompressible)]` expands to:**
- `LightHasherSha` (SHA256 - required for compressible accounts)
- `LightDiscriminator`
- `Compressible` (which includes HasCompressionInfo + CompressAs + Size + CompressedInitSpace)
- `CompressiblePack` (which includes Pack + Unpack + Packed struct)

**Note:** All compressible accounts use SHA256 hashing (not Poseidon) because:
1. SHA256 handles large structs (no field count limit)
2. SHA256 handles Pubkeys without requiring `#[hash]` for each one
3. Matches the existing codebase patterns (PoolState, etc.)

**The `#[hash]` attribute is still supported** for fields that need explicit hashing.

### 3.2 Program Registration (Cleaner Naming)

**NEW (Proposed):**
```rust
#[compressible(  // Renamed from add_compressible_instructions
    // PDAs: AccountType = (SEED_CONST, ctx.accounts.field, data.param, ...)
    PoolState = (POOL_SEED, ctx.accounts.amm_config, ctx.accounts.token_0_mint, ctx.accounts.token_1_mint),
    
    // Tokens: is_token flag + seeds + optional authority
    Token0Vault = (is_token, POOL_VAULT_SEED, ctx.accounts.pool_state, ctx.accounts.token_0_mint, authority = AUTH_SEED),
    
    // ATAs: built-in pattern
    ATA = (is_token, is_ata),
    
    // Instruction data fields (when using data.*)
    owner = Pubkey,
    session_id = u64,
)]
#[program]
pub mod my_program { ... }
```

### 3.3 What Gets Generated

The `#[compressible(...)]` macro generates:

```rust
// 1. DecompressAccountsIdempotent with Option<UncheckedAccount> for each ctx.accounts.* reference
#[derive(Accounts)]
pub struct DecompressAccountsIdempotent<'info> {
    #[account(mut)]
    pub fee_payer: Signer<'info>,
    pub config: AccountInfo<'info>,
    #[account(mut)]
    pub rent_sponsor: UncheckedAccount<'info>,
    // Auto-added from seeds:
    pub amm_config: Option<UncheckedAccount<'info>>,
    pub token_0_mint: Option<UncheckedAccount<'info>>,
    pub token_1_mint: Option<UncheckedAccount<'info>>,
    pub pool_state: Option<UncheckedAccount<'info>>,
    // ... system accounts for tokens/mints
}

// 2. SeedParams for data.* references (if any)
#[derive(AnchorSerialize, AnchorDeserialize, Default)]
pub struct SeedParams {
    pub owner: Pubkey,
    pub session_id: u64,
}

// 3. CompressedAccountVariant enum
pub enum CompressedAccountVariant {
    PoolState(PoolState),
    PackedPoolState(PackedPoolState),
    PackedCTokenData(PackedCTokenData<CTokenAccountVariant>),
    // ...
}

// 4. PdaSeedDerivation impl for each PDA type
impl PdaSeedDerivation<DecompressAccountsIdempotent<'_>, SeedParams> for PoolState { ... }

// 5. Rust client helpers
pub fn get_pool_state_pda(amm_config: &Pubkey, token_0_mint: &Pubkey, token_1_mint: &Pubkey) -> (Pubkey, u8) { ... }
pub fn get_poolstate_seeds(...) -> (Vec<Vec<u8>>, Pubkey) { ... }

// 6. Instructions
pub fn decompress_accounts_idempotent(...) -> Result<()>
pub fn compress_accounts_idempotent(...) -> Result<()>
pub fn initialize_compression_config(...) -> Result<()>
pub fn update_compression_config(...) -> Result<()>
```

---

## 4. Edge Cases

### 4.1 Seed Types

| Seed Type | Example | Handling |
|-----------|---------|----------|
| String literal | `"pool"` | `.as_bytes()` |
| Constant | `POOL_SEED` | `.as_bytes()` |
| ctx.accounts.* | `ctx.accounts.amm_config` | `accounts.amm_config.as_ref()?.key()` |
| data.* | `data.session_id.to_le_bytes()` | `seed_params.session_id.to_le_bytes()` |
| Function call | `max_key(&ctx.user.key(), &ctx.authority.key())` | Preserved, args transformed |

### 4.2 Token Account Variants

| Variant | Syntax | Behavior |
|---------|--------|----------|
| Custom seeds | `is_token, "seed", ctx...` | Generate CTokenSeedProvider impl |
| ATA | `is_token, is_ata` | Use standard ATA derivation |
| Authority override | `authority = AUTH_SEED` | For PDA-signed token accounts |
| CPI signer authority | `authority = LIGHT_CPI_SIGNER` | For Light CPI signing |

### 4.3 compress_as Override

When fields should be reset on compression:
```rust
#[derive(LightCompressible)]
#[compress_as(start_time = 0, end_time = None, score = 0)]
pub struct GameSession { ... }
```

### 4.4 Missing Seed Accounts

During decompress, if an optional seed account is not provided:
```rust
accounts.amm_config.as_ref().ok_or_else(|| {
    CompressibleInstructionError::MissingSeedAccount.into()
})?.key()
```

### 4.5 800-Byte Limit

Compressed accounts must fit within 800 bytes. The macro validates:
```rust
if __lp_size > 800 {
    msg!("Compressed account would exceed 800-byte limit ({} bytes)", __lp_size);
    return Err(LightSdkError::ConstraintViolation.into());
}
```

### 4.6 Rent Top-Up Prevention (Grieving)

Accounts track `last_claimed_slot` in CompressionInfo. The rent function gates compression:
- Account must be compressible w.r.t. rent function (current+next epoch)
- Prevents griefing where attacker keeps account decompressed

---

## 5. Migration Path

### 5.1 Phase 1: Add New Macro (Non-Breaking)

1. Add `#[derive(LightCompressible)]` as alias that expands to all required derives
2. Keep existing macros working
3. Add deprecation warnings to old patterns

### 5.2 Phase 2: Rename Program Macro (Breaking)

1. Add `#[compressible]` as new name
2. Keep `#[add_compressible_instructions]` as deprecated alias
3. Update documentation

### 5.3 Phase 3: Remove Deprecated Macros (Future)

1. Remove `#[account]` (conflicts with Anchor)
2. Remove individual trait derives that are subsumed
3. Update all examples

### 5.4 Migration Example

**BEFORE:**
```rust
#[derive(
    Default, Debug, LightHasher, LightDiscriminator, InitSpace, Compressible, CompressiblePack,
)]
#[account]
pub struct PoolState { ... }

#[add_compressible_instructions(
    PoolState = (...),
)]
#[program]
pub mod my_program { ... }
```

**AFTER:**
```rust
#[derive(Default, Debug, InitSpace, LightCompressible)]
#[account]
pub struct PoolState { ... }

#[compressible(
    PoolState = (...),
)]
#[program]
pub mod my_program { ... }
```

---

## 6. Implementation Steps

### Step 1: Create LightCompressible derive macro

**File:** `sdk-libs/macros/src/compressible/light_compressible.rs`

**Functionality:**
- Parse struct
- Generate: LightHasherSha, LightDiscriminator, HasCompressionInfo, CompressAs, Size, CompressedInitSpace
- Generate: Pack/Unpack (from CompressiblePack logic)
- Handle `#[compress_as(...)]` attribute
- Handle `#[hash]` and `#[skip]` field attributes

**Risk:** None - additive change

### Step 2: Register LightCompressible in lib.rs

**File:** `sdk-libs/macros/src/lib.rs`

**Changes:**
- Add `mod light_compressible` to compressible module
- Export `LightCompressible` derive macro
- Optionally add `LightCompressiblePoseidon` variant

**Risk:** None - additive change

### Step 3: Add compressible attribute macro alias

**File:** `sdk-libs/macros/src/lib.rs`

**Changes:**
- Add `#[proc_macro_attribute] pub fn compressible(...)` that calls `add_compressible_instructions`
- Add deprecation notice to `add_compressible_instructions`

**Risk:** None - additive change, backward compatible

### Step 4: Update test programs

**Files:**
- `sdk-tests/csdk-anchor-derived-test/src/state.rs`
- `sdk-tests/csdk-anchor-full-derived-test/src/state.rs`

**Changes:**
- Add tests using new `LightCompressible` derive
- Verify backward compatibility with old derives

**Risk:** Low - test changes only

### Step 5: Update documentation

**Files:**
- `sdk-libs/macros/src/lib.rs` (doc comments)
- `sdk-libs/macros/src/compressible/GUIDE.md`
- `sdk-libs/macros/src/compressible/README.md`

**Risk:** None - documentation only

---

## 7. Testing Strategy

### 7.1 Unit Tests

| Test | File | Purpose |
|------|------|---------|
| LightCompressible generates all traits | `compressible/light_compressible.rs` | Verify expansion |
| compress_as attribute works | `compressible/traits.rs` | Custom compression |
| Pack/Unpack for Pubkey fields | `compressible/pack_unpack.rs` | Pubkey compression |

### 7.2 Integration Tests

| Test | Program | Purpose |
|------|---------|---------|
| Manual implementation works | `csdk-anchor-derived-test` | Baseline |
| Auto-generated implementation works | `csdk-anchor-full-derived-test` | Full automation |
| Complex seeds work | Both | ctx.accounts.*, data.*, expressions |
| Token accounts work | Both | is_token, is_ata, authority |
| Decompress/compress cycle | Both | Full roundtrip |

### 7.3 Validation Checklist

- [ ] `cargo build` succeeds for all test programs
- [ ] `cargo test` passes for csdk-anchor-derived-test
- [ ] `cargo test` passes for csdk-anchor-full-derived-test
- [ ] Generated code compiles without warnings
- [ ] IDL includes all generated instructions
- [ ] Client helper functions work correctly
- [ ] Deprecation warnings appear for old macros

---

## 8. Failure Cases and Mitigations

### 8.1 Step 1 Failures

| Failure | Mitigation |
|---------|------------|
| Trait bound errors | Ensure all generated impls have correct bounds |
| Missing field errors | Validate compression_info field exists |
| Hash attribute conflicts | Preserve existing hash/skip attribute handling |

### 8.2 Step 2 Failures

| Failure | Mitigation |
|---------|------------|
| Re-export conflicts | Use unique internal names |
| Feature flag issues | Test with/without features |

### 8.3 Step 3 Failures

| Failure | Mitigation |
|---------|------------|
| Macro ordering issues | Ensure compressible runs before #[program] |
| Token stream conflicts | Test with complex program modules |

### 8.4 Step 4 Failures

| Failure | Mitigation |
|---------|------------|
| Test compilation errors | Fix generated code based on errors |
| Runtime errors | Debug with expanded macro output |
| IDL mismatch | Verify Anchor IDL generation |

---

## Appendix A: Generated Code Examples

### A.1 LightCompressible Expansion

Input:
```rust
#[derive(LightCompressible)]
pub struct UserRecord {
    #[hash]
    pub owner: Pubkey,
    #[max_len(32)]
    pub name: String,
    pub score: u64,
    #[skip]
    pub compression_info: Option<CompressionInfo>,
}
```

This is EQUIVALENT to writing:
```rust
#[derive(LightHasherSha, LightDiscriminator, Compressible, CompressiblePack)]
pub struct UserRecord {
    #[hash]
    pub owner: Pubkey,
    #[max_len(32)]
    pub name: String,
    pub score: u64,
    #[skip]
    pub compression_info: Option<CompressionInfo>,
}
```

Which generates:
```rust
// From LightHasherSha:
impl light_hasher::DataHasher for UserRecord { ... }
impl light_hasher::to_byte_array::ToByteArray for UserRecord { ... }

// From LightDiscriminator:
impl light_sdk::LightDiscriminator for UserRecord {
    const LIGHT_DISCRIMINATOR: [u8; 8] = [...];
}

// From Compressible:
impl light_sdk::compressible::HasCompressionInfo for UserRecord { ... }
impl light_sdk::compressible::CompressAs for UserRecord { ... }
impl light_sdk::account::Size for UserRecord { ... }
impl light_sdk::compressible::CompressedInitSpace for UserRecord { ... }

// From CompressiblePack:
pub struct PackedUserRecord {
    pub owner: u8,  // Pubkey -> u8 index
    pub name: String,
    pub score: u64,
    pub compression_info: Option<CompressionInfo>,
}
impl light_sdk::compressible::Pack for UserRecord { ... }
impl light_sdk::compressible::Unpack for UserRecord { ... }
impl light_sdk::compressible::Pack for PackedUserRecord { ... }
impl light_sdk::compressible::Unpack for PackedUserRecord { ... }
```

### A.2 compressible Macro Expansion

Input:
```rust
#[compressible(
    UserRecord = ("user", ctx.accounts.owner),
    CTokenSigner = (is_token, "signer", ctx.fee_payer, authority = AUTH_SEED),
)]
#[program]
pub mod my_program { ... }
```

Output: (abbreviated)
```rust
// DecompressAccountsIdempotent
#[derive(Accounts)]
pub struct DecompressAccountsIdempotent<'info> {
    pub fee_payer: Signer<'info>,
    pub config: AccountInfo<'info>,
    pub rent_sponsor: UncheckedAccount<'info>,
    pub owner: Option<UncheckedAccount<'info>>,  // From ctx.accounts.owner
    // ... ctoken accounts
}

// SeedParams (empty if no data.* fields)
pub struct SeedParams {}

// CompressedAccountVariant
pub enum CompressedAccountVariant { ... }

// CTokenAccountVariant
pub enum CTokenAccountVariant {
    CTokenSigner = 0,
}

// PdaSeedDerivation impl
impl PdaSeedDerivation<...> for UserRecord { ... }

// CTokenSeedProvider impl
impl CTokenSeedProvider for CTokenAccountVariant { ... }

// Client helpers
pub fn get_userrecord_seeds(owner: &Pubkey) -> (Vec<Vec<u8>>, Pubkey) { ... }

// Instructions
pub fn decompress_accounts_idempotent(...) -> Result<()> { ... }
pub fn compress_accounts_idempotent(...) -> Result<()> { ... }
pub fn initialize_compression_config(...) -> Result<()> { ... }
pub fn update_compression_config(...) -> Result<()> { ... }

#[program]
pub mod my_program { ... }
```

---

## Appendix B: Decision Log

| Decision | Rationale |
|----------|-----------|
| Program-level seeds only | Decompress requires instruction accounts; tokens can't use self.* |
| SHA256 as default hasher | More efficient on Solana, matches ctoken usage |
| Keep separate LightHasher/LightHasherSha | Poseidon still needed for some use cases |
| Rename to `#[compressible]` | Shorter, clearer, matches domain language |
| Include Pack/Unpack in LightCompressible | Reduces boilerplate, always needed together |
