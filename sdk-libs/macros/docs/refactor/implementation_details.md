# Implementation Details

Details that remain the same as the current implementation.

---

## Discriminator

Uses existing `#[derive(LightDiscriminator)]` implementation (Anchor-style).

---

## Error Handling

Uses `anchor_lang::error::Error` and `ProgramError`:
- `LightPreInit` returns `Result<()>` with Anchor error type
- `LightFinalize` returns `Result<()>` with Anchor error type
- SDK functions use `.map_err()` for error conversion

---

## Seed Verification (Decompress)

At decompress time:
1. Seeds are reconstructed from packed variant + remaining_accounts
2. PDA is derived using `Pubkey::find_program_address(&seeds, program_id)`
3. Derived PDA must match the account being decompressed
4. Verification failure returns error

---

## Client Seed Helpers

The `PackedLightAccountVariant` provides:
- `seed_refs_with_bump()` - Returns seed slice with bump for CPI signing
- Seeds can be reconstructed by unpacking indices from remaining_accounts

---

## Size Validation

Compressed accounts must fit within 800 bytes. Validated at compile-time using const assertions:

```rust
// Generated by #[derive(LightAccount)]
const _: () = {
    assert!(
        UserRecord::INIT_SPACE <= 800,
        "Compressed account size exceeds 800 byte limit"
    );
};
```

This ensures the error is caught at compile time, not runtime. The macro generates this assertion for each account type.

**Note:** The 800-byte limit applies to the compressed (borsh-serialized) representation, which excludes the 8-byte discriminator.

---

## Nested Field Access in Seeds

Supports one level of nesting:
- `params.owner` - extracts `owner` into Seeds struct
- `params.config.owner` - extracts `owner` (terminal field)
- Deeper nesting follows same pattern (terminal field extracted)

Expression suffixes stripped:
- `params.owner.as_ref()` → `owner`
- `authority.key().as_ref()` → `authority`

---

## CompressionInfo Handling

**In packed data:**
- `compression_info` excluded from `PackedXxx` struct
- Bytes are cut off during pack (not field-by-field exclusion)
- Same approach for both borsh and zero-copy accounts

**When hashing:**
- `compression_info` IS included in hash
- Set to `CompressionInfo::compressed()` before hashing
- At decompress, set to same value to reproduce the hash

**Requirement:**
- `compression_info` field must be first or last in struct (not nested)
- Macro validates this at compile time

---

## Zero-Copy Pod Accounts

Requirements:
- Data struct must implement `Pod` from `bytemuck`
- Data struct must also implement `BorshSerialize` and `BorshDeserialize`
- Use `AccountLoader<'info, T>` instead of `Account<'info, T>`
- Add `zero_copy` to light_account attribute: `#[light_account(init, zero_copy)]`

**Pod type requirements:**
- Must use `#[repr(C)]` for predictable layout
- `Pubkey` implements `Pod` when the `bytemuck` feature is enabled on `solana-pubkey`
  ```rust
  #[repr(C)]
  #[derive(Copy, Clone, Pod, Zeroable)]
  pub struct ZeroCopyUserRecord {
      pub owner: Pubkey,  // Pubkey is Pod with bytemuck feature
      pub score: u64,
      pub compression_info: CompressionInfo,
  }
  ```
- All fields must be Pod-compatible (no enums with data, no references, no heap types)
- Must derive `Copy`, `Clone`, `Pod`, and `Zeroable`

**Serialization flow:**
- Pack/unpack uses borsh (same as regular accounts)
- On-chain account uses zero-copy Pod layout
- Compressed form uses borsh serialization regardless of on-chain format

---

## Multiple PDAs in Same Accounts Struct

Supported. Each PDA field:
1. Gets its own `CompressedAccountInfo`
2. Collected into `compressed_accounts` vec in order of declaration
3. Initialized in declaration order
4. `num_pdas` counter tracks position for mint offset

---

## `#[compress_as(field = value)]` Attribute

Overrides field values in compressed/hashed representation.

Allowed values:
- Literals: `0`, `None`, `false`, `""`
- Constants: `DEFAULT_VALUE`
- Not allowed: `self.field` references, function calls

Auto-skipped fields:
- `compression_info` always excluded from hash
- Fields with `#[skip]` excluded

---

## `#[skip]` Attribute

Excludes field from:
- Hash computation
- Pack/unpack (field not in packed struct)
- Size calculation

Cannot skip required fields. `compression_info` is auto-handled.

---

## Constants in Seeds

Uppercase identifiers treated as constants.

Supported:
- Local constants: `SEED`
- Qualified paths: `crate::seeds::VAULT_SEED`
- Module paths: `seeds::MY_SEED`

Constants go directly into `seed_refs()`, not into Seeds struct.
