# LightProgram Attribute Macro

## Overview

`#[light_program]` collects all variants generated by `#[derive(LightAccounts)]` into a unified program-wide enum and generates instruction wrappers.

**Key principle:** Individual variant structs and trait implementations are generated by `#[derive(LightAccounts)]`. This macro only collects and wraps.

| Macro Responsibility | Description |
|---------------------|-------------|
| **Scan** | Find all `#[light_account]` fields across crate |
| **Validate** | Enforce unique field names |
| **Collect** | Generate unified `ProgramAccountVariant` enum |
| **Delegate** | Enum impl delegates to inner variant impls |
| **Instructions** | Generate thin wrappers calling SDK functions |
| **Wrap handlers** | Insert `light_pre_init`/`light_finalize` calls |
| **Accounts structs** | Generate instruction account structs |

---

## Input

```rust
#[light_program]
#[program]
pub mod my_program {
    pub fn create(ctx: Context<Create>, params: CreateParams) -> Result<()> {
        ctx.accounts.user_record.owner = params.owner;
        Ok(())
    }

    pub fn transfer(ctx: Context<Transfer>, params: TransferParams) -> Result<()> {
        // ...
        Ok(())
    }
}
```

---

## Macro Responsibilities

### 1. Scan & Validate

| Step | Description |
|------|-------------|
| Scan | Find all `#[light_account(...)]` attributes across crate |
| Collect | Gather all generated variant types from `#[derive(LightAccounts)]` |
| Validate | **Enforce unique field names** across entire program |

**Error on duplicate:**
```
error: Duplicate light_account field name 'user_record' found in Create and Update structs.
       Field names must be unique across the program.
```

---

### 2. Generate Unified Enum

Collects individual variants (already generated by `#[derive(LightAccounts)]`) into program-wide enum.

```rust
// These already exist (from #[derive(LightAccounts)] on various structs):
// - UserRecordVariant, PackedUserRecordVariant
// - VaultVariant, PackedVaultVariant
// - MyMintVariant, PackedMyMintVariant

// #[light_program] generates:
pub enum ProgramAccountVariant {
    UserRecord(UserRecordVariant),
    Vault(VaultVariant),
    MyMint(MyMintVariant),
}

pub enum PackedProgramAccountVariant {
    UserRecord(PackedUserRecordVariant),
    Vault(PackedVaultVariant),
    MyMint(PackedMyMintVariant),
}
```

**Trait implementation (delegates to inner variants):**

```rust
impl LightAccountVariant for ProgramAccountVariant {
    type Seeds = ProgramAccountSeeds;  // enum of all seed types
    type Data = ProgramAccountData;    // enum of all data types
    type Packed = PackedProgramAccountVariant;

    const SEED_COUNT: usize = 0;  // varies per variant

    fn seeds(&self) -> &Self::Seeds {
        match self {
            Self::UserRecord(v) => ProgramAccountSeeds::UserRecord(v.seeds()),
            Self::Vault(v) => ProgramAccountSeeds::Vault(v.seeds()),
            Self::MyMint(v) => ProgramAccountSeeds::MyMint(v.seeds()),
        }
    }

    fn data(&self) -> &Self::Data {
        match self {
            Self::UserRecord(v) => ProgramAccountData::UserRecord(v.data()),
            Self::Vault(v) => ProgramAccountData::Vault(v.data()),
            Self::MyMint(v) => ProgramAccountData::MyMint(v.data()),
        }
    }

    fn seed_refs(&self) -> Vec<&[u8]> {
        match self {
            Self::UserRecord(v) => v.seed_refs().to_vec(),
            Self::Vault(v) => v.seed_refs().to_vec(),
            Self::MyMint(v) => v.seed_refs().to_vec(),
        }
    }

    fn pack(&self, accounts: &mut PackedAccounts, program_id: &Pubkey) -> Result<Self::Packed, ProgramError> {
        match self {
            Self::UserRecord(v) => Ok(PackedProgramAccountVariant::UserRecord(v.pack(accounts, program_id)?)),
            Self::Vault(v) => Ok(PackedProgramAccountVariant::Vault(v.pack(accounts, program_id)?)),
            Self::MyMint(v) => Ok(PackedProgramAccountVariant::MyMint(v.pack(accounts, program_id)?)),
        }
    }
}
```

---

### 3. Generate Instructions

#### `compress_and_close`

```rust
pub fn compress_and_close(ctx: Context<CompressAndClose>) -> Result<()> {
    light_sdk::compress_and_close::<ProgramAccountVariant>(
        ctx.accounts.data.as_ref(),
        ctx.remaining_accounts,
        CpiSigner::new(&crate::LIGHT_CPI_SIGNER),
    )
}

#[derive(Accounts)]
pub struct CompressAndClose<'info> {
    #[account(mut)]
    pub fee_payer: Signer<'info>,

    pub data: AccountInfo<'info>,

    // System accounts via remaining_accounts
}
```

#### `decompress_idempotent`

```rust
pub fn decompress_idempotent(
    ctx: Context<DecompressIdempotent>,
    params: DecompressParams,
) -> Result<()> {
    light_sdk::decompress_idempotent::<DecompressParams, ProgramAccountVariant>(
        ctx.accounts.data.as_ref(),
        ctx.remaining_accounts,
        CpiSigner::new(&crate::LIGHT_CPI_SIGNER),
    )
}

#[derive(Accounts)]
pub struct DecompressIdempotent<'info> {
    #[account(mut)]
    pub fee_payer: Signer<'info>,

    pub data: AccountInfo<'info>,

    // System accounts via remaining_accounts
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct DecompressParams {
    pub variant: PackedProgramAccountVariant,
    pub proof: DecompressProof,
}
```

#### `initialize_compression_config`

```rust
pub fn initialize_compression_config(
    ctx: Context<InitializeCompressionConfig>,
) -> Result<()> {
    light_sdk::initialize_compression_config(
        ctx.accounts,
        ctx.remaining_accounts,
    )
}

#[derive(Accounts)]
pub struct InitializeCompressionConfig<'info> {
    #[account(mut)]
    pub fee_payer: Signer<'info>,

    #[account(mut)]
    pub authority: Signer<'info>,

    #[account(
        init,
        payer = fee_payer,
        space = 8 + CompressionConfig::INIT_SPACE,
        seeds = [b"compression_config"],
        bump
    )]
    pub config: Account<'info, CompressionConfig>,

    pub system_program: Program<'info, System>,
}
```

#### `update_compression_config`

```rust
pub fn update_compression_config(
    ctx: Context<UpdateCompressionConfig>,
    params: UpdateConfigParams,
) -> Result<()> {
    light_sdk::update_compression_config(
        ctx.accounts,
        params,
    )
}

#[derive(Accounts)]
pub struct UpdateCompressionConfig<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,

    #[account(
        mut,
        seeds = [b"compression_config"],
        bump,
        has_one = authority
    )]
    pub config: Account<'info, CompressionConfig>,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct UpdateConfigParams {
    pub new_authority: Option<Pubkey>,
    // ... other config fields
}
```

---

### 4. Auto-Wrap Instruction Handlers

Finds all `pub fn` using `Context<T>` where `T` derives `LightAccounts` and wraps with lifecycle hooks.

**Before (user writes):**
```rust
pub fn create(ctx: Context<Create>, params: CreateParams) -> Result<()> {
    ctx.accounts.user_record.owner = params.owner;
    ctx.accounts.user_record.score = 0;
    Ok(())
}
```

**After (macro transforms to):**
```rust
pub fn create(ctx: Context<Create>, params: CreateParams) -> Result<()> {
    // 1. Pre-init: create compressed accounts
    ctx.accounts.light_pre_init(
        &params.proof,
        ctx.remaining_accounts,
        params.system_accounts_offset,
    )?;

    // 2. Original handler logic
    ctx.accounts.user_record.owner = params.owner;
    ctx.accounts.user_record.score = 0;

    // 3. Finalize (noop)
    ctx.accounts.light_finalize(ctx.remaining_accounts)?;

    Ok(())
}
```

**Detection logic:**
1. Parse all `pub fn` items in program module
2. Extract `Context<T>` type parameter
3. Check if `T` has any `#[light_account(...)]` fields
4. If yes, wrap with `light_pre_init`/`light_finalize`

---

## SDK Functions (called by generated instructions)

### `compress_and_close<V>`

```rust
pub fn compress_and_close<V: LightAccountVariant>(
    data: &[u8],
    accounts: &[AccountInfo],
    cpi_signer: CpiSigner,
) -> Result<()>
```

**What it does:**
1. Deserialize variant from `data`
2. Hash account data
3. CPI to Light system program to insert into Merkle tree
4. Close the on-chain PDA account

### `decompress_idempotent<P, V>`

```rust
pub fn decompress_idempotent<P, V: LightAccountVariant>(
    data: &[u8],
    accounts: &[AccountInfo],
    cpi_signer: CpiSigner,
) -> Result<()>
```

**What it does:**
1. Deserialize packed variant from `data`
2. Verify proof against Merkle tree
3. Verify seeds match params `P`
4. Create/rehydrate on-chain PDA account (idempotent)
5. Write account data

### `initialize_compression_config`

```rust
pub fn initialize_compression_config<'info>(
    accounts: &InitializeCompressionConfig<'info>,
    remaining_accounts: &[AccountInfo<'info>],
) -> Result<()>
```

### `update_compression_config`

```rust
pub fn update_compression_config<'info>(
    accounts: &UpdateCompressionConfig<'info>,
    params: UpdateConfigParams,
) -> Result<()>
```

---

---

## What Macro Does NOT Do

These are handled by `#[derive(LightAccounts)]`:

| Item | Generated By |
|------|--------------|
| Individual variant structs (`UserRecordVariant`) | `#[derive(LightAccounts)]` |
| Seeds structs (`UserRecordSeeds`) | `#[derive(LightAccounts)]` |
| Packed structs (`PackedUserRecordVariant`) | `#[derive(LightAccounts)]` |
| `LightAccountVariant` trait impl per variant | `#[derive(LightAccounts)]` |
| `PackedLightAccountVariant` trait impl | `#[derive(LightAccounts)]` |
| `LightPreInit` / `LightFinalize` trait impls | `#[derive(LightAccounts)]` |
| `light_pre_init_*` function calls | `#[derive(LightAccounts)]` |

---

## Requirements

Programs using `#[light_program]` must define:

```rust
// CPI signer for Light system program
pub const LIGHT_CPI_SIGNER: Pubkey = pubkey!("...");

// Program ID (from declare_id!)
declare_id!("...");
```
