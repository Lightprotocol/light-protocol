# LightProgram Attribute Macro

## Overview

`#[light_program]` collects all variants generated by `#[derive(LightAccounts)]` into a unified program-wide enum and generates instruction wrappers.

**Key principle:** Individual variant structs and trait implementations are generated by `#[derive(LightAccounts)]`. This macro only collects and wraps.

| Macro Responsibility | Description |
|---------------------|-------------|
| **Scan** | Find all `#[light_account]` fields across crate |
| **Validate** | Enforce unique field names |
| **Collect** | Generate unified `ProgramAccountVariant` enum |
| **Delegate** | Enum impl delegates to inner variant impls |
| **Instructions** | Generate thin wrappers calling SDK functions |
| **Wrap handlers** | Insert `light_pre_init`/`light_finalize` calls |
| **Accounts structs** | Generate instruction account structs |

---

## Input

```rust
#[light_program]
#[program]
pub mod my_program {
    pub fn create(ctx: Context<Create>, params: CreateParams) -> Result<()> {
        ctx.accounts.user_record.owner = params.owner;
        Ok(())
    }

    pub fn transfer(ctx: Context<Transfer>, params: TransferParams) -> Result<()> {
        // ...
        Ok(())
    }
}
```

---

## Macro Responsibilities

### 1. Scan & Validate

| Step | Description |
|------|-------------|
| Scan | Find all `#[light_account(...)]` attributes across crate |
| Collect | Gather all generated variant types from `#[derive(LightAccounts)]` |
| Validate | **Enforce unique field names** across entire program |

**Error on duplicate:**
```
error: Duplicate light_account field name 'user_record' found in Create and Update structs.
       Field names must be unique across the program.
```

---

### 2. Generate Unified Enum

Collects individual variants (already generated by `#[derive(LightAccounts)]`) into program-wide enum.

```rust
// These already exist (from #[derive(LightAccounts)] on various structs):
// - UserRecordVariant, PackedUserRecordVariant
// - VaultVariant, PackedVaultVariant
// - MyMintVariant, PackedMyMintVariant

// #[light_program] generates:
pub enum ProgramAccountVariant {
    UserRecord(UserRecordVariant),
    Vault(VaultVariant),
    MyMint(MyMintVariant),
}

pub enum PackedProgramAccountVariant {
    UserRecord(PackedUserRecordVariant),
    Vault(PackedVaultVariant),
    MyMint(PackedMyMintVariant),
}
```

**Trait implementation (delegates to inner variants):**

```rust
impl LightAccountVariant for ProgramAccountVariant {
    type Seeds = ProgramAccountSeeds;  // enum of all seed types
    type Data = ProgramAccountData;    // enum of all data types
    type Packed = PackedProgramAccountVariant;

    const SEED_COUNT: usize = 0;  // varies per variant

    fn seeds(&self) -> &Self::Seeds {
        match self {
            Self::UserRecord(v) => ProgramAccountSeeds::UserRecord(v.seeds()),
            Self::Vault(v) => ProgramAccountSeeds::Vault(v.seeds()),
            Self::MyMint(v) => ProgramAccountSeeds::MyMint(v.seeds()),
        }
    }

    fn data(&self) -> &Self::Data {
        match self {
            Self::UserRecord(v) => ProgramAccountData::UserRecord(v.data()),
            Self::Vault(v) => ProgramAccountData::Vault(v.data()),
            Self::MyMint(v) => ProgramAccountData::MyMint(v.data()),
        }
    }

    fn seed_refs(&self) -> Vec<&[u8]> {
        match self {
            Self::UserRecord(v) => v.seed_refs().to_vec(),
            Self::Vault(v) => v.seed_refs().to_vec(),
            Self::MyMint(v) => v.seed_refs().to_vec(),
        }
    }

    fn pack(&self, accounts: &mut PackedAccounts, program_id: &Pubkey) -> Result<Self::Packed, ProgramError> {
        match self {
            Self::UserRecord(v) => Ok(PackedProgramAccountVariant::UserRecord(v.pack(accounts, program_id)?)),
            Self::Vault(v) => Ok(PackedProgramAccountVariant::Vault(v.pack(accounts, program_id)?)),
            Self::MyMint(v) => Ok(PackedProgramAccountVariant::MyMint(v.pack(accounts, program_id)?)),
        }
    }
}
```

---

### 3. Generate Instructions

#### `compress_and_close`

```rust
pub fn compress_and_close(ctx: Context<CompressAndClose>) -> Result<()> {
    light_sdk::compress_and_close::<ProgramAccountVariant>(
        ctx.accounts.data.as_ref(),
        ctx.remaining_accounts,
        CpiSigner::new(&crate::LIGHT_CPI_SIGNER),
    )
}

#[derive(Accounts)]
pub struct CompressAndClose<'info> {
    #[account(mut)]
    pub fee_payer: Signer<'info>,

    pub data: AccountInfo<'info>,

    // System accounts via remaining_accounts
}
```

#### `decompress_idempotent`

```rust
pub fn decompress_idempotent(
    ctx: Context<DecompressIdempotent>,
    params: DecompressParams,
) -> Result<()> {
    light_sdk::decompress_idempotent::<DecompressParams, ProgramAccountVariant>(
        ctx.accounts.data.as_ref(),
        ctx.remaining_accounts,
        CpiSigner::new(&crate::LIGHT_CPI_SIGNER),
    )
}

#[derive(Accounts)]
pub struct DecompressIdempotent<'info> {
    #[account(mut)]
    pub fee_payer: Signer<'info>,

    pub data: AccountInfo<'info>,

    // System accounts via remaining_accounts
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct DecompressParams {
    pub variant: PackedProgramAccountVariant,
    pub proof: DecompressProof,
    pub instruction_data: DecompressInstructionData,
}
```

#### `initialize_compression_config`

```rust
pub fn initialize_compression_config(
    ctx: Context<InitializeCompressionConfig>,
) -> Result<()> {
    light_sdk::initialize_compression_config(
        ctx.accounts,
        ctx.remaining_accounts,
    )
}

#[derive(Accounts)]
pub struct InitializeCompressionConfig<'info> {
    #[account(mut)]
    pub fee_payer: Signer<'info>,

    #[account(mut)]
    pub authority: Signer<'info>,

    #[account(
        init,
        payer = fee_payer,
        space = 8 + CompressionConfig::INIT_SPACE,
        seeds = [b"compression_config"],
        bump
    )]
    pub config: Account<'info, CompressionConfig>,

    pub system_program: Program<'info, System>,
}
```

#### `update_compression_config`

```rust
pub fn update_compression_config(
    ctx: Context<UpdateCompressionConfig>,
    params: UpdateConfigParams,
) -> Result<()> {
    light_sdk::update_compression_config(
        ctx.accounts,
        params,
    )
}

#[derive(Accounts)]
pub struct UpdateCompressionConfig<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,

    #[account(
        mut,
        seeds = [b"compression_config"],
        bump,
        has_one = authority
    )]
    pub config: Account<'info, CompressionConfig>,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct UpdateConfigParams {
    pub new_authority: Option<Pubkey>,
    // ... other config fields
}
```

---

### 4. Auto-Wrap Instruction Handlers

Finds all `pub fn` using `Context<T>` where `T` derives `LightAccounts` and wraps with lifecycle hooks.

**Before (user writes):**
```rust
pub fn create(ctx: Context<Create>, params: CreateParams) -> Result<()> {
    ctx.accounts.user_record.owner = params.owner;
    ctx.accounts.user_record.score = 0;
    Ok(())
}
```

**After (macro transforms to):**
```rust
pub fn create(ctx: Context<Create>, params: CreateParams) -> Result<()> {
    // 1. Pre-init: create compressed accounts
    ctx.accounts.light_pre_init(
        &params.proof,
        ctx.remaining_accounts,
        params.system_accounts_offset,
    )?;

    // 2. Original handler logic
    ctx.accounts.user_record.owner = params.owner;
    ctx.accounts.user_record.score = 0;

    // 3. Finalize (noop)
    ctx.accounts.light_finalize(ctx.remaining_accounts)?;

    Ok(())
}
```

**Detection logic:**
1. Parse all `pub fn` items in program module
2. Extract `Context<T>` type parameter
3. Check if `T` has any `#[light_account(...)]` fields
4. If yes, wrap with `light_pre_init`/`light_finalize`

---

## Seed Classification

Seeds in `#[account(seeds = [...])]` are classified into three categories:

| Category | Detection | At Init | At Decompress |
|----------|-----------|---------|---------------|
| **Constant** | Literals (`b"user"`), uppercase (`SEED`) | Compile-time known | Compile-time known |
| **Account** | Identifier not in `#[instruction(...)]` | From ctx account field | From remaining_accounts via index |
| **InstructionData** | Identifier matches `#[instruction(...)]` arg | From instruction params | From `DecompressInstructionData` |

### Detection Order

1. **Literal**: `b"user"`, `"string"` -> constant bytes
2. **Constant**: Uppercase paths (`SEED`, `crate::SEED`) -> compile-time known
3. **InstructionData**: Root identifier matches `#[instruction(...)]` arg name
4. **Account**: Fallback - assumed to be ctx account field

### Instruction Data Detection

The macro parses `#[instruction(...)]` to detect instruction data seeds:

```rust
// Format 1: struct parameter
#[instruction(params: CreateParams)]
// Seeds can use: params.owner, params.id.to_le_bytes()

// Format 2: individual parameters
#[instruction(owner: Pubkey, amount: u64)]
// Seeds can use: owner, amount.to_le_bytes() (no prefix needed)
```

**No `params.` prefix required** - bare identifiers work if they match an instruction arg name.

### Account Seeds

Account seeds must reference fields in the Accounts struct:

```rust
#[account(seeds = [b"vault", authority.key().as_ref()], bump)]
// authority must be a field in the Accounts struct
// remaining_accounts are NOT permitted as seeds
```

---

## Bump Handling

Bumps are NOT classified as seeds. They come from one of three sources:

| Source | Syntax | Description |
|--------|--------|-------------|
| **Derived** | (default) | Macro calls `find_program_address()` at runtime |
| **Instruction Data** | `token::bump = params.vault_bump` | Client passes pre-computed bump |
| **Anchor Bump** | `token::bump = bump` | Use bump from `#[account(seeds=[...], bump)]` |

### Derived (Default)

When no explicit bump is provided, the macro derives it:

```rust
#[light_account(init, token, token::mint = mint, token::authority = [b"vault", owner.key().as_ref()])]
pub vault: UncheckedAccount<'info>,
// bump computed via find_program_address(&[b"vault", owner_key], program_id)
```

### Instruction Data Bump

Client pre-computes and passes the bump:

```rust
#[instruction(params: CreateParams)]  // params.vault_bump: u8
#[light_account(init, token, token::bump = params.vault_bump, ...)]
pub vault: UncheckedAccount<'info>,
```

### Anchor Bump

Use the bump from an Anchor PDA in the same struct:

```rust
#[account(seeds = [b"authority", owner.key().as_ref()], bump)]
pub authority: Account<'info, AuthorityAccount>,

#[light_account(init, token, token::bump = bump, token::authority = [b"authority", owner.key().as_ref()])]
pub vault: UncheckedAccount<'info>,
// Uses the bump Anchor derived for the authority PDA
```

### Bump at Compress vs Decompress

| Flow | Bump Source |
|------|-------------|
| **Init** | Not needed - Anchor creates PDA |
| **Compress** | Derived via `find_program_address()` and stored in packed variant |
| **Decompress** | Read from packed variant (was stored at compress time) |

The bump is stored in the packed seeds struct during compress and recovered during decompress:

```rust
pub struct PackedVaultSeeds {
    pub owner_idx: u8,
    pub bump: u8,  // stored at compress, used at decompress
}
```

---

## Decompress Instruction Data

At decompress time, instruction data seeds must be provided since the original instruction params are not available.

### Generated `DecompressInstructionData` Struct

The macro collects ALL instruction data fields used in seeds across the program:

```rust
// Generated by #[light_program]
// Collects instruction data seeds from all variants
#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct DecompressInstructionData {
    // From UserRecord: seeds = [b"user", owner.as_ref()]
    pub owner: Option<Pubkey>,

    // From Payment: seeds = [b"payment", amount.to_le_bytes().as_ref()]
    pub amount: Option<u64>,

    // From Profile: seeds = [b"profile", name.as_bytes()]
    pub name: Option<String>,

    // ... all instruction data fields from all variants
}
```

### Usage at Decompress

```rust
#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct DecompressParams {
    pub variant: PackedProgramAccountVariant,
    pub proof: DecompressProof,
    pub instruction_data: DecompressInstructionData,  // <- instruction data seeds
}
```

**Client populates only the fields needed for the specific variant:**

```rust
// Decompressing a UserRecord variant
let params = DecompressParams {
    variant: packed_user_record,
    proof: merkle_proof,
    instruction_data: DecompressInstructionData {
        owner: Some(user_pubkey),  // needed for UserRecord seeds
        amount: None,              // not needed
        name: None,                // not needed
    },
};
```

### Seed Reconstruction at Decompress

1. **Constant seeds**: Known at compile time, no data needed
2. **Account seeds**: Resolved from remaining_accounts using packed indices
3. **Instruction data seeds**: Read from `DecompressInstructionData` optional fields

The SDK's `decompress_idempotent` function:
1. Unpacks the variant (account seeds from remaining_accounts)
2. Extracts instruction data seeds from `DecompressInstructionData`
3. Reconstructs full seeds array
4. Derives PDA and verifies it matches

---

## SDK Functions (called by generated instructions)

### `compress_and_close<V>`

```rust
pub fn compress_and_close<V: LightAccountVariant>(
    data: &[u8],
    accounts: &[AccountInfo],
    cpi_signer: CpiSigner,
) -> Result<()>
```

**What it does:**
1. Deserialize variant from `data`
2. Hash account data
3. CPI to Light system program to insert into Merkle tree
4. Close the on-chain PDA account

### `decompress_idempotent<V>`

```rust
pub fn decompress_idempotent<V: LightAccountVariant>(
    params: &DecompressParams,
    accounts: &[AccountInfo],
    cpi_signer: CpiSigner,
) -> Result<()>
```

**What it does:**
1. Deserialize packed variant from params
2. Verify proof against Merkle tree
3. Reconstruct seeds:
   - Constant seeds: compile-time known
   - Account seeds: resolve from `accounts` using packed indices
   - Instruction data seeds: extract from `params.instruction_data`
4. Derive PDA from reconstructed seeds and verify it matches
5. Create/rehydrate on-chain PDA account (idempotent)
6. Write account data

### `initialize_compression_config`

```rust
pub fn initialize_compression_config<'info>(
    accounts: &InitializeCompressionConfig<'info>,
    remaining_accounts: &[AccountInfo<'info>],
) -> Result<()>
```

### `update_compression_config`

```rust
pub fn update_compression_config<'info>(
    accounts: &UpdateCompressionConfig<'info>,
    params: UpdateConfigParams,
) -> Result<()>
```

---

---

## What Macro Does NOT Do

These are handled by `#[derive(LightAccounts)]`:

| Item | Generated By |
|------|--------------|
| Individual variant structs (`UserRecordVariant`) | `#[derive(LightAccounts)]` |
| Seeds structs (`UserRecordSeeds`) | `#[derive(LightAccounts)]` |
| Packed structs (`PackedUserRecordVariant`) | `#[derive(LightAccounts)]` |
| `LightAccountVariant` trait impl per variant | `#[derive(LightAccounts)]` |
| `PackedLightAccountVariant` trait impl | `#[derive(LightAccounts)]` |
| `LightPreInit` / `LightFinalize` trait impls | `#[derive(LightAccounts)]` |
| `light_pre_init_*` function calls | `#[derive(LightAccounts)]` |

---

## Requirements

Programs using `#[light_program]` must define:

```rust
// CPI signer for Light system program
pub const LIGHT_CPI_SIGNER: Pubkey = pubkey!("...");

// Program ID (from declare_id!)
declare_id!("...");
```
