# LightProgram Attribute Macro

## Overview

`#[light_program]` collects all variants generated by `#[derive(LightAccounts)]` into a unified program-wide enum and generates instruction wrappers.

**Key principle:** Individual variant structs and trait implementations are generated by `#[derive(LightAccounts)]`. This macro only collects and wraps.

| Macro Responsibility | Description |
|---------------------|-------------|
| **Scan** | Find all `#[light_account]` fields across crate |
| **Validate** | Enforce unique field names |
| **Collect** | Generate unified `ProgramAccountVariant` enum |
| **Delegate** | Enum impl delegates to inner variant impls |
| **Instructions** | Generate thin wrappers calling SDK functions |
| **Wrap handlers** | Insert `light_pre_init`/`light_finalize` calls |
| **Accounts structs** | Generate instruction account structs |

---

## Input

```rust
#[light_program]
#[program]
pub mod my_program {
    pub fn create(ctx: Context<Create>, params: CreateParams) -> Result<()> {
        ctx.accounts.user_record.owner = params.owner;
        Ok(())
    }

    pub fn transfer(ctx: Context<Transfer>, params: TransferParams) -> Result<()> {
        // ...
        Ok(())
    }
}
```

---

## Macro Responsibilities

### 1. Scan & Validate

| Step | Description |
|------|-------------|
| Scan | Find all `#[light_account(...)]` attributes across crate |
| Collect | Gather all generated variant types from `#[derive(LightAccounts)]` |
| Validate | **Enforce unique field names** across entire program |

**Why unique field names?**

Accounts structs can be reused across multiple instructions:

```rust
// Same struct used in multiple instructions
pub fn create(ctx: Context<UserAccounts>, ...) -> Result<()> { ... }
pub fn update(ctx: Context<UserAccounts>, ...) -> Result<()> { ... }
pub fn delete(ctx: Context<UserAccounts>, ...) -> Result<()> { ... }
```

The program-wide `ProgramAccountVariant` enum uses field names as variant identifiers. Since the same Accounts struct (and its `#[light_account]` fields) can appear in multiple instructions, the enum must deduplicate by field name.

**Error on duplicate:**
```
error: Duplicate light_account field name 'user_record' found in Create and Update structs.
       Field names must be unique across the program.
```

---

### 2. Generate Unified Enum

Collects individual variants (already generated by `#[derive(LightAccounts)]`) into program-wide enum.

```rust
// These already exist (from #[derive(LightAccounts)] on various structs):
// - UserRecordVariant, PackedUserRecordVariant
// - VaultVariant, PackedVaultVariant
// - MyMintVariant, PackedMyMintVariant

// #[light_program] generates:
pub enum ProgramAccountVariant {
    UserRecord(UserRecordVariant),
    Vault(VaultVariant),
    MyMint(MyMintVariant),
}

pub enum PackedProgramAccountVariant {
    UserRecord(PackedUserRecordVariant),
    Vault(PackedVaultVariant),
    MyMint(PackedMyMintVariant),
}
```

**Note:** The program-wide enum does NOT implement `LightAccountVariant` directly because variants have different `SEED_COUNT` values. Instead, it implements `DecompressVariant` for trait-based dispatch:

```rust
impl<'info> DecompressVariant<'info> for PackedProgramAccountVariant {
    fn decompress(
        &self,
        tree_info: &PackedStateTreeInfo,
        output_queue_index: u8,
        pda_account: &AccountInfo<'info>,
        ctx: &mut DecompressCtx<'_, 'info>,
    ) -> Result<(), ProgramError> {
        match self {
            Self::UserRecord(packed) => {
                // SEED_COUNT = 3 for UserRecord
                prepare_account_for_decompression::<3, PackedUserRecordVariant>(
                    packed, tree_info, output_queue_index, pda_account, ctx
                )
            }
            Self::Vault(packed) => {
                // SEED_COUNT = 2 for Vault
                prepare_account_for_decompression::<2, PackedVaultVariant>(
                    packed, tree_info, output_queue_index, pda_account, ctx
                )
            }
            Self::MyMint(packed) => {
                // SEED_COUNT = 3 for MyMint
                prepare_account_for_decompression::<3, PackedMyMintVariant>(
                    packed, tree_info, output_queue_index, pda_account, ctx
                )
            }
        }
    }
}
```

**For compression, the dispatch function uses discriminator matching:**

```rust
fn compress_dispatch<'info>(
    account_info: &AccountInfo<'info>,
    meta: &CompressedAccountMetaNoLamportsNoAddress,
    index: usize,
    ctx: &mut CompressCtx<'_, 'info>,
) -> Result<(), ProgramError> {
    let data = account_info.try_borrow_data()?;
    let discriminator: [u8; 8] = data[..8].try_into().map_err(|_| ProgramError::InvalidAccountData)?;

    match discriminator {
        UserRecord::LIGHT_DISCRIMINATOR => {
            let mut account = UserRecord::try_from_slice(&data[8..])?;
            prepare_account_for_compression(account_info, &mut account, meta, index, ctx)
        }
        VaultData::LIGHT_DISCRIMINATOR => {
            let mut account = VaultData::try_from_slice(&data[8..])?;
            prepare_account_for_compression(account_info, &mut account, meta, index, ctx)
        }
        MyMintData::LIGHT_DISCRIMINATOR => {
            let mut account = MyMintData::try_from_slice(&data[8..])?;
            prepare_account_for_compression(account_info, &mut account, meta, index, ctx)
        }
        _ => Err(ProgramError::InvalidAccountData),
    }
}
```

---

### 3. Generate Instructions

#### `compress_and_close`

```rust
/// Compress PDA accounts idempotently.
/// Uses dispatch callback pattern for discriminator-based routing.
pub fn compress_and_close<'info>(
    program_id: &Pubkey,
    accounts: &[AccountInfo<'info>],
    instruction_data: &[u8],
) -> ProgramResult {
    process_compress_pda_accounts_idempotent(
        accounts,
        instruction_data,
        compress_dispatch,  // Macro-generated dispatch function
        CpiSigner::new(&crate::LIGHT_CPI_SIGNER),
        program_id,
    )
}
```

**Parameters (in instruction data):**
```rust
#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct CompressAndCloseParams {
    /// Validity proof for compressed account verification
    pub proof: ValidityProof,
    /// Accounts to compress (meta only - data read from PDA)
    pub compressed_accounts: Vec<CompressedAccountMetaNoLamportsNoAddress>,
    /// Offset into remaining_accounts where Light system accounts begin
    pub system_accounts_offset: u8,
}
```

#### `decompress_idempotent`

```rust
/// Decompress PDA accounts idempotently.
/// Uses trait-based dispatch via DecompressVariant.
pub fn decompress_idempotent<'info>(
    program_id: &Pubkey,
    accounts: &[AccountInfo<'info>],
    instruction_data: &[u8],
) -> ProgramResult {
    process_decompress_pda_accounts_idempotent::<PackedProgramAccountVariant>(
        accounts,
        instruction_data,
        CpiSigner::new(&crate::LIGHT_CPI_SIGNER),
        program_id,
    )
}
```

**Parameters (in instruction data):**
```rust
#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct DecompressIdempotentParams<V> {
    /// Validity proof for compressed account verification
    pub proof: ValidityProof,
    /// Accounts to decompress - wrapped in CompressedAccountData for metadata
    pub accounts: Vec<CompressedAccountData<V>>,
    /// Offset into remaining_accounts where Light system accounts begin
    pub system_accounts_offset: u8,
}

/// Wrapper containing metadata and packed variant data
#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct CompressedAccountData<V> {
    pub meta: CompressedAccountMetaNoLamportsNoAddress,
    pub data: V,  // PackedProgramAccountVariant
}
```

#### `initialize_compression_config`

```rust
pub fn initialize_compression_config(
    ctx: Context<InitializeCompressionConfig>,
) -> Result<()> {
    light_sdk::initialize_compression_config(
        ctx.accounts,
        ctx.remaining_accounts,
    )
}

#[derive(Accounts)]
pub struct InitializeCompressionConfig<'info> {
    #[account(mut)]
    pub fee_payer: Signer<'info>,

    #[account(mut)]
    pub authority: Signer<'info>,

    #[account(
        init,
        payer = fee_payer,
        space = 8 + CompressionConfig::INIT_SPACE,
        seeds = [b"compression_config"],
        bump
    )]
    pub config: Account<'info, CompressionConfig>,

    pub system_program: Program<'info, System>,
}
```

#### `update_compression_config`

```rust
pub fn update_compression_config(
    ctx: Context<UpdateCompressionConfig>,
    params: UpdateConfigParams,
) -> Result<()> {
    light_sdk::update_compression_config(
        ctx.accounts,
        params,
    )
}

#[derive(Accounts)]
pub struct UpdateCompressionConfig<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,

    #[account(
        mut,
        seeds = [b"compression_config"],
        bump,
        has_one = authority
    )]
    pub config: Account<'info, CompressionConfig>,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct UpdateConfigParams {
    pub new_authority: Option<Pubkey>,
    // ... other config fields
}
```

---

### 4. Auto-Wrap Instruction Handlers

Finds all `pub fn` using `Context<T>` where `T` derives `LightAccounts` and wraps with lifecycle hooks.

**Before (user writes):**
```rust
pub fn create(ctx: Context<Create>, params: CreateParams) -> Result<()> {
    ctx.accounts.user_record.owner = params.owner;
    ctx.accounts.user_record.score = 0;
    Ok(())
}
```

**After (macro transforms to):**
```rust
pub fn create(ctx: Context<Create>, params: CreateParams) -> Result<()> {
    // 1. Pre-init: create compressed accounts
    ctx.accounts.light_pre_init(
        &params.proof,
        ctx.remaining_accounts,
        params.system_accounts_offset,
    )?;

    // 2. Original handler logic
    ctx.accounts.user_record.owner = params.owner;
    ctx.accounts.user_record.score = 0;

    // 3. Finalize (noop)
    ctx.accounts.light_finalize(ctx.remaining_accounts)?;

    Ok(())
}
```

**Detection logic:**
1. Parse all `pub fn` items in program module
2. Extract `Context<T>` type parameter
3. Check if `T` has any `#[light_account(...)]` fields
4. If yes, wrap with `light_pre_init`/`light_finalize`

---

## Seed Classification

Seeds in `#[account(seeds = [...])]` are classified into three categories:

| Category | Detection | At Init | At Decompress |
|----------|-----------|---------|---------------|
| **Constant** | Literals (`b"user"`), uppercase (`SEED`) | Compile-time known | Compile-time known |
| **Account** | Identifier not in `#[instruction(...)]` | From ctx account field | From remaining_accounts via index |
| **InstructionData** | Identifier matches `#[instruction(...)]` arg | From instruction params | From `DecompressInstructionData` |

### Detection Order

1. **Literal**: `b"user"`, `"string"` -> constant bytes
2. **Constant**: Uppercase paths (`SEED`, `crate::SEED`) -> compile-time known
3. **InstructionData**: Root identifier matches `#[instruction(...)]` arg name
4. **Account**: Fallback - assumed to be ctx account field

### Instruction Data Detection

The macro parses `#[instruction(...)]` to detect instruction data seeds:

```rust
// Format 1: struct parameter
#[instruction(params: CreateParams)]
// Seeds can use: params.owner, params.id.to_le_bytes()

// Format 2: individual parameters
#[instruction(owner: Pubkey, amount: u64)]
// Seeds can use: owner, amount.to_le_bytes() (no prefix needed)
```

**No `params.` prefix required** - bare identifiers work if they match an instruction arg name.

### Account Seeds

Account seeds must reference fields in the Accounts struct:

```rust
#[account(seeds = [b"vault", authority.key().as_ref()], bump)]
// authority must be a field in the Accounts struct
// remaining_accounts are NOT permitted as seeds
```

---

## Decompress Instruction Data

At decompress time, instruction data seeds must be provided since the original instruction params are not available.

### Generated `DecompressInstructionData` Struct

The macro collects ALL instruction data fields used in seeds across the program:

```rust
// Generated by #[light_program]
// Collects instruction data seeds from all variants
#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct DecompressInstructionData {
    // From UserRecord: seeds = [b"user", owner.as_ref()]
    pub owner: Option<Pubkey>,

    // From Payment: seeds = [b"payment", amount.to_le_bytes().as_ref()]
    pub amount: Option<u64>,

    // From Profile: seeds = [b"profile", name.as_bytes()]
    pub name: Option<String>,

    // ... all instruction data fields from all variants
}
```

### Usage at Decompress

```rust
#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct DecompressParams {
    pub variant: PackedProgramAccountVariant,
    pub proof: DecompressProof,
    pub instruction_data: DecompressInstructionData,  // <- instruction data seeds
}
```

**Client populates only the fields needed for the specific variant:**

```rust
// Decompressing a UserRecord variant
let params = DecompressParams {
    variant: packed_user_record,
    proof: merkle_proof,
    instruction_data: DecompressInstructionData {
        owner: Some(user_pubkey),  // needed for UserRecord seeds
        amount: None,              // not needed
        name: None,                // not needed
    },
};
```

### Seed Reconstruction at Decompress

1. **Constant seeds**: Known at compile time, no data needed
2. **Account seeds**: Resolved from remaining_accounts using packed indices
3. **Instruction data seeds**: Read from `DecompressInstructionData` optional fields

The SDK's `decompress_idempotent` function:
1. Unpacks the variant (account seeds from remaining_accounts)
2. Extracts instruction data seeds from `DecompressInstructionData`
3. Reconstructs full seeds array
4. Derives PDA and verifies it matches

---

## Remaining Accounts Layout

Both compress and decompress use a standardized remaining accounts layout:

```
[0]: fee_payer (Signer, mut)
[1]: config (LightConfig PDA)
[2]: rent_sponsor (mut)
[3]: compression_authority (Signer) - for compress only
[system_accounts_offset..]: Light system accounts for CPI
[remaining_accounts.len() - num_pda_accounts..]: PDA accounts to compress/decompress
```

---

## Dispatch Patterns

### Compress: CompressDispatchFn Callback

The compress flow uses a **function pointer callback** for discriminator-based dispatch:

```rust
/// Callback type for discriminator-based dispatch.
/// MACRO-GENERATED: Just a match statement routing to prepare_account_for_compression.
/// Takes &mut CompressCtx and pushes CompressedAccountInfo into ctx.compressed_account_infos.
pub type CompressDispatchFn<'info> = fn(
    account_info: &AccountInfo<'info>,
    compressed_account_meta: &CompressedAccountMetaNoLamportsNoAddress,
    index: usize,
    ctx: &mut CompressCtx<'_, 'info>,
) -> Result<(), ProgramError>;
```

**Macro generates:**
```rust
fn compress_dispatch<'info>(
    account_info: &AccountInfo<'info>,
    meta: &CompressedAccountMetaNoLamportsNoAddress,
    index: usize,
    ctx: &mut CompressCtx<'_, 'info>,
) -> Result<(), ProgramError> {
    let data = account_info.try_borrow_data()?;
    let discriminator: [u8; 8] = data[..8].try_into().unwrap();

    match discriminator {
        UserRecord::LIGHT_DISCRIMINATOR => {
            let mut account = UserRecord::deserialize(&mut &data[8..])?;
            prepare_account_for_compression(account_info, &mut account, meta, index, ctx)
        }
        // ... other variants
        _ => Err(ProgramError::InvalidAccountData),
    }
}
```

### Decompress: DecompressVariant Trait

The decompress flow uses a **trait-based dispatch** pattern:

```rust
/// Trait for packed program account variants that support decompression.
///
/// MACRO-GENERATED: The implementation contains a match statement routing each
/// enum variant to the appropriate `prepare_account_for_decompression` call.
pub trait DecompressVariant<'info>: AnchorSerialize + AnchorDeserialize + Clone {
    /// Decompress this variant into a PDA account.
    fn decompress(
        &self,
        meta: &CompressedAccountMetaNoLamportsNoAddress,
        pda_account: &AccountInfo<'info>,
        ctx: &mut DecompressCtx<'_, 'info>,
    ) -> Result<(), ProgramError>;
}
```

**Macro generates:**
```rust
impl<'info> DecompressVariant<'info> for PackedProgramAccountVariant {
    fn decompress(
        &self,
        meta: &CompressedAccountMetaNoLamportsNoAddress,
        pda_account: &AccountInfo<'info>,
        ctx: &mut DecompressCtx<'_, 'info>,
    ) -> Result<(), ProgramError> {
        match self {
            Self::UserRecord(packed) => {
                prepare_account_for_decompression::<3, PackedUserRecordVariant>(
                    packed, meta, pda_account, ctx
                )
            }
            // ... other variants
        }
    }
}
```

---

## Context Structs

### CompressCtx

```rust
/// Context struct holding all data needed for compression.
/// Contains internal vec for collecting CompressedAccountInfo results.
pub struct CompressCtx<'a, 'info> {
    pub program_id: &'a Pubkey,
    pub cpi_accounts: &'a CpiAccounts<'a, 'info>,
    pub remaining_accounts: &'a [AccountInfo<'info>],
    pub rent_sponsor: &'a AccountInfo<'info>,
    pub light_config: &'a LightConfig,
    /// Internal vec - dispatch functions push results here
    pub compressed_account_infos: Vec<CompressedAccountInfo>,
    /// Track which PDA indices to close
    pub pda_indices_to_close: Vec<usize>,
}
```

### DecompressCtx

```rust
/// Context struct holding all data needed for decompression.
/// Contains internal vec for collecting CompressedAccountInfo results.
pub struct DecompressCtx<'a, 'info> {
    pub program_id: &'a Pubkey,
    pub cpi_accounts: &'a CpiAccounts<'a, 'info>,
    pub remaining_accounts: &'a [AccountInfo<'info>],
    pub rent_sponsor: &'a AccountInfo<'info>,
    pub light_config: &'a LightConfig,
    pub rent: &'a Rent,
    pub current_slot: u64,
    /// Internal vec - dispatch functions push results here
    pub compressed_account_infos: Vec<CompressedAccountInfo>,
}
```

---

## SDK Processor Functions

### `process_compress_pda_accounts_idempotent`

```rust
/// Runtime processor - handles all the plumbing, delegates dispatch to callback.
///
/// **Takes raw instruction data** and deserializes internally - minimizes macro code.
/// **Uses only remaining_accounts** - no Context struct needed.
pub fn process_compress_pda_accounts_idempotent<'info>(
    remaining_accounts: &[AccountInfo<'info>],
    instruction_data: &[u8],
    dispatch_fn: CompressDispatchFn<'info>,
    cpi_signer: CpiSigner,
    program_id: &Pubkey,
) -> Result<(), ProgramError>
```

**What it does:**
1. Deserialize `CompressAndCloseParams` from instruction data
2. Extract fee_payer, config, rent_sponsor from remaining_accounts
3. Load and validate LightConfig
4. Build CompressCtx with internal vecs
5. For each PDA account, call dispatch_fn (macro-generated match)
6. CPI to Light System Program with collected CompressedAccountInfos
7. Close the PDA accounts

### `process_decompress_pda_accounts_idempotent`

```rust
/// Runtime processor - handles all the plumbing, dispatches via DecompressVariant trait.
///
/// **Takes raw instruction data** and deserializes internally - minimizes macro code.
/// **Uses only remaining_accounts** - no Context struct needed.
/// **Generic over V** - the program's `PackedProgramAccountVariant` enum.
pub fn process_decompress_pda_accounts_idempotent<'info, V>(
    remaining_accounts: &[AccountInfo<'info>],
    instruction_data: &[u8],
    cpi_signer: CpiSigner,
    program_id: &Pubkey,
) -> Result<(), ProgramError>
where
    V: DecompressVariant<'info>,
```

**What it does:**
1. Deserialize `DecompressIdempotentParams<V>` from instruction data
2. Extract fee_payer, config, rent_sponsor from remaining_accounts
3. Load and validate LightConfig
4. Build DecompressCtx with internal vec
5. For each account, call `variant.decompress()` (trait dispatch)
6. CPI to Light System Program with collected CompressedAccountInfos

### `prepare_account_for_compression`

```rust
/// Generic prepare_account_for_compression.
/// Called by the dispatch function after deserializing the account.
/// Pushes CompressedAccountInfo into ctx.compressed_account_infos.
pub fn prepare_account_for_compression<'info, A>(
    account_info: &AccountInfo<'info>,
    account_data: &mut A,
    compressed_account_meta: &CompressedAccountMetaNoLamportsNoAddress,
    pda_index: usize,
    ctx: &mut CompressCtx<'_, 'info>,
) -> Result<(), ProgramError>
where
    A: LightAccount + LightDiscriminator + Clone + AnchorSerialize,
```

### `prepare_account_for_decompression`

```rust
/// Generic prepare_account_for_decompression.
/// Called by DecompressVariant::decompress() implementation.
/// Pushes CompressedAccountInfo into ctx.compressed_account_infos.
pub fn prepare_account_for_decompression<'info, const SEED_COUNT: usize, P>(
    packed: &P,
    state_tree_info: &PackedStateTreeInfo,
    output_queue_index: u8,
    pda_account: &AccountInfo<'info>,
    ctx: &mut DecompressCtx<'_, 'info>,
) -> Result<(), ProgramError>
where
    P: PackedLightAccountVariant<SEED_COUNT>,
    <P::Unpacked as LightAccountVariant<SEED_COUNT>>::Data:
        LightAccount + LightDiscriminator + Clone + AnchorSerialize + AnchorDeserialize,
```

---

## Legacy SDK Functions

### `initialize_compression_config`

```rust
pub fn initialize_compression_config<'info>(
    accounts: &InitializeCompressionConfig<'info>,
    remaining_accounts: &[AccountInfo<'info>],
) -> Result<()>
```

### `update_compression_config`

```rust
pub fn update_compression_config<'info>(
    accounts: &UpdateCompressionConfig<'info>,
    params: UpdateConfigParams,
) -> Result<()>
```

---

---

## What Macro Does NOT Do

These are handled by `#[derive(LightAccounts)]`:

| Item | Generated By |
|------|--------------|
| Individual variant structs (`UserRecordVariant`) | `#[derive(LightAccounts)]` |
| Seeds structs (`UserRecordSeeds`) | `#[derive(LightAccounts)]` |
| Packed structs (`PackedUserRecordVariant`) | `#[derive(LightAccounts)]` |
| `LightAccountVariant` trait impl per variant | `#[derive(LightAccounts)]` |
| `PackedLightAccountVariant` trait impl | `#[derive(LightAccounts)]` |
| `LightPreInit` / `LightFinalize` trait impls | `#[derive(LightAccounts)]` |
| `light_pre_init_*` function calls | `#[derive(LightAccounts)]` |

---

## Requirements

Programs using `#[light_program]` must define:

```rust
// CPI signer for Light system program
pub const LIGHT_CPI_SIGNER: Pubkey = pubkey!("...");

// Program ID (from declare_id!)
declare_id!("...");
```
