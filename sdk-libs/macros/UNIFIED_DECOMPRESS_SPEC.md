# Unified Decompress Specification v2

## Executive Summary

Extend the `#[compressible(...)]` macro to auto-generate `decompress_accounts_idempotent` that handles **all four account types**. `LightAta` and `LightMint` are **standard SDK types** - programs don't declare them.

---

## 1. Account Type Taxonomy

| Type          | Declaration                                | SDK Type                      | Owner          | Signing                       | Any #    |
| ------------- | ------------------------------------------ | ----------------------------- | -------------- | ----------------------------- | -------- |
| **cPDA**      | `#[compressible(Foo = (...))]`             | Program-generated             | Program        | Program PDA seeds             | ✅       |
| **CToken**    | `#[compressible(Vault = (is_token, ...))]` | Program-generated             | Program        | Program PDA seeds (authority) | ✅       |
| **LightAta**  | NOT declared - always available            | `light_ctoken_sdk::LightAta`  | User wallet    | Wallet signs tx               | ✅       |
| **LightMint** | NOT declared - always available            | `light_ctoken_sdk::LightMint` | ctoken program | Authority signs               | ❌ max 1 |

**Key Design**: Users only declare PDAs and program-owned CToken accounts (Vaults). `LightAta` and `LightMint` are SDK types automatically included.

---

## 2. Macro Declaration Changes

### 2.1 Current Declaration (BEFORE)

```rust
#[compressible(
    // PDAs
    UserRecord = ("user_record", ctx.authority, data.owner),

    // Program-owned CToken (Vault)
    Vault = (is_token, "vault", ctx.cmint, authority = ("vault_authority")),

    // User ATA - REMOVED: Don't declare ATAs anymore
    UserAta = (is_token, is_ata, ctx.wallet, ctx.cmint),  // ❌ REMOVE

    // CMint - REMOVED: Don't declare CMints anymore
    CMint = (is_token, "cmint", ctx.mint_signer, authority = LIGHT_CPI_SIGNER),  // ❌ REMOVE

    // Data fields
    owner = Pubkey,
)]
```

### 2.2 New Declaration (AFTER)

```rust
#[compressible(
    // PDAs only - define your custom compressible PDAs
    UserRecord = ("user_record", ctx.authority, data.owner),
    GameSession = ("game_session", ctx.user, data.session_id.to_le_bytes()),

    // Program-owned CTokens only (Vaults) - OPTIONAL
    Vault = (is_token, "vault", ctx.cmint, authority = ("vault_authority")),

    // Data fields for seeds
    owner = Pubkey,
    session_id = u64,

    // LightAta and LightMint are NOT declared - they're automatically available
)]
```

### 2.3 Programs Without PDAs or Vaults

A program can have:

- Only PDAs (no CTokens)
- Only Vaults (no PDAs)
- Both PDAs and Vaults
- Neither (only uses LightAta/LightMint via the generated instruction)

All programs automatically get `LightAta` and `LightMint` support in `decompress_accounts_idempotent`.

---

## 3. Generated CompressedAccountVariant Enum

The macro generates this enum with program-specific types PLUS standard types:

```rust
// Auto-generated by macro
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub enum CompressedAccountVariant {
    // Program-specific PDAs (if any declared)
    UserRecord(UserRecord),
    PackedUserRecord(PackedUserRecord),
    GameSession(GameSession),
    PackedGameSession(PackedGameSession),

    // Program-specific CTokens/Vaults (if any declared)
    PackedCTokenData(PackedCTokenData<CTokenAccountVariant>),
    CTokenData(CTokenData<CTokenAccountVariant>),

    // ALWAYS included - standard SDK types
    LightAta(light_ctoken_sdk::LightAta),
    LightMint(light_ctoken_sdk::LightMint),
}
```

---

## 4. Combination Rules

### 4.1 Forbidden Combinations

```
┌─────────────────────────────────────────────────────────┐
│  LightMint + (LightAta or CToken) = FORBIDDEN           │
│                                                         │
│  Reason: Both modify on-chain state, neither can be     │
│  in CPI context write mode.                             │
│  - DecompressMint: error 6035 when writing to context   │
│  - Transfer2: error 18001 when writing to context       │
└─────────────────────────────────────────────────────────┘
```

### 4.2 Allowed Combinations

```
✅ cPDA only                    (any number)
✅ CToken only                  (any number)
✅ LightAta only                (any number)
✅ LightMint only               (exactly 1)
✅ cPDA + CToken                (any number each)
✅ cPDA + LightAta              (any number each)
✅ cPDA + LightMint             (any PDAs + exactly 1 mint)
✅ CToken + LightAta            (any number each)
✅ cPDA + CToken + LightAta     (any number each)
```

### 4.3 Constraint Summary

| Constraint                      | Client Validation | On-chain Validation | Error                      |
| ------------------------------- | ----------------- | ------------------- | -------------------------- |
| Max 1 LightMint per instruction | ✅ Yes            | ✅ Yes              | `AtMostOneMintAllowed`     |
| LightMint + tokens forbidden    | ✅ Yes            | ✅ Yes              | `MintAndTokensForbidden`   |
| Wallet must sign for LightAta   | ✅ Yes            | ✅ Yes              | `MissingRequiredSignature` |

---

## 5. Type Definitions and Locations

### 5.1 Where Types Live

| Type              | Location                                          | Description                                      |
| ----------------- | ------------------------------------------------- | ------------------------------------------------ |
| `LightAta`        | `light-ctoken-sdk/src/compressible/light_ata.rs`  | Packed ATA struct (on-chain)                     |
| `LightAtaInput`   | `light-ctoken-sdk/src/compressible/light_ata.rs`  | Client-side input type                           |
| `LightMint`       | `light-ctoken-sdk/src/compressible/light_mint.rs` | Packed Mint struct (on-chain)                    |
| `LightMintInput`  | `light-ctoken-sdk/src/compressible/light_mint.rs` | Client-side input type                           |
| Validation errors | `light-sdk/src/error.rs`                          | `AtMostOneMintAllowed`, `MintAndTokensForbidden` |

### 5.2 LightAta Type Definition

```rust
// light-ctoken-sdk/src/compressible/light_ata.rs

/// On-chain packed ATA type (indices into remaining_accounts)
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct LightAta {
    /// Index of wallet account (must be signer, derives ATA)
    pub wallet_index: u8,
    /// Index of mint account
    pub mint_index: u8,
    /// Index of ATA account (derived from wallet + mint)
    pub ata_index: u8,
    /// Token amount
    pub amount: u64,
    /// Whether delegate is set
    pub has_delegate: bool,
    /// Index of delegate (0 if none)
    pub delegate_index: u8,
    /// Whether account is frozen
    pub is_frozen: bool,
}

/// Client-side input for LightAta decompression
pub struct LightAtaInput {
    /// Compressed token account from indexer
    pub compressed_account: CompressedTokenAccount,
    /// Wallet pubkey (must be signer in transaction)
    pub wallet: Pubkey,
}

impl Pack for LightAtaInput {
    type Packed = LightAta;

    fn pack(&self, packed_accounts: &mut PackedAccounts) -> LightAta {
        // Insert wallet as signer
        let wallet_index = packed_accounts.insert_or_get_config(self.wallet, true, false);

        // Get mint from compressed account data
        let mint = Pubkey::new_from_array(self.compressed_account.token.mint);
        let mint_index = packed_accounts.insert_or_get_read_only(mint);

        // Derive and insert ATA address
        let ata = get_associated_token_address(&self.wallet, &mint);
        let ata_index = packed_accounts.insert_or_get(ata);

        LightAta {
            wallet_index,
            mint_index,
            ata_index,
            amount: self.compressed_account.token.amount,
            has_delegate: self.compressed_account.token.delegate.is_some(),
            delegate_index: if let Some(delegate) = self.compressed_account.token.delegate {
                packed_accounts.insert_or_get_read_only(Pubkey::new_from_array(delegate))
            } else {
                0
            },
            is_frozen: self.compressed_account.token.state == AccountState::Frozen,
        }
    }
}
```

### 5.3 LightMint Type Definition

```rust
// light-ctoken-sdk/src/compressible/light_mint.rs

/// On-chain packed Mint type (indices into remaining_accounts)
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct LightMint {
    /// Index of mint_seed account (derives CMint PDA)
    pub mint_seed_index: u8,
    /// Index of CMint PDA in remaining_accounts
    pub cmint_pda_index: u8,
    /// Compressed address (raw bytes, not an account)
    pub compressed_address: [u8; 32],
    /// Merkle tree leaf index
    pub leaf_index: u32,
    /// Whether to prove by index
    pub prove_by_index: bool,
    /// Root index for proof
    pub root_index: u16,
    /// Token supply
    pub supply: u64,
    /// Token decimals
    pub decimals: u8,
    /// Metadata version
    pub version: u8,
    /// Whether CMint has been decompressed before
    pub cmint_decompressed: bool,
    /// Whether mint_authority is set
    pub has_mint_authority: bool,
    /// Index of mint_authority (0 if none)
    pub mint_authority_index: u8,
    /// Whether freeze_authority is set
    pub has_freeze_authority: bool,
    /// Index of freeze_authority (0 if none)
    pub freeze_authority_index: u8,
    /// Rent payment type (e.g., 2 for sponsor)
    pub rent_payment: u8,
    /// Write top-up amount
    pub write_top_up: u64,
}

/// Client-side input for LightMint decompression
pub struct LightMintInput {
    /// Compressed account from indexer (contains CompressedMint data)
    pub compressed_account: CompressedAccount,
    /// Mint seed pubkey (used to derive CMint PDA)
    pub mint_seed_pubkey: Pubkey,
}

impl Pack for LightMintInput {
    type Packed = LightMint;

    fn pack(&self, packed_accounts: &mut PackedAccounts) -> LightMint {
        // Parse mint data from compressed account
        let mint_data: CompressedMint = borsh::BorshDeserialize::deserialize(
            &mut &self.compressed_account.data.as_ref().unwrap().data[..]
        ).expect("Failed to parse CompressedMint data");

        // Insert mint_seed
        let mint_seed_index = packed_accounts.insert_or_get_read_only(self.mint_seed_pubkey);

        // Derive and insert CMint PDA
        let (cmint_pda, _) = find_cmint_address(&self.mint_seed_pubkey);
        let cmint_pda_index = packed_accounts.insert_or_get(cmint_pda);

        // Pack authorities if present
        let has_mint_authority = mint_data.base.mint_authority.is_some();
        let mint_authority_index = if let Some(auth) = mint_data.base.mint_authority {
            packed_accounts.insert_or_get_read_only(Pubkey::new_from_array(auth.to_bytes()))
        } else {
            0
        };

        let has_freeze_authority = mint_data.base.freeze_authority.is_some();
        let freeze_authority_index = if let Some(auth) = mint_data.base.freeze_authority {
            packed_accounts.insert_or_get_read_only(Pubkey::new_from_array(auth.to_bytes()))
        } else {
            0
        };

        LightMint {
            mint_seed_index,
            cmint_pda_index,
            compressed_address: self.compressed_account.address.unwrap(),
            leaf_index: 0, // Set by caller from tree_info
            prove_by_index: false, // Set by caller
            root_index: 0, // Set by caller
            supply: mint_data.base.supply,
            decimals: mint_data.base.decimals,
            version: mint_data.metadata.version,
            cmint_decompressed: mint_data.metadata.cmint_decompressed,
            has_mint_authority,
            mint_authority_index,
            has_freeze_authority,
            freeze_authority_index,
            rent_payment: 2,
            write_top_up: 5000,
        }
    }
}
```

---

## 6. Client Helper Changes

### 6.1 Updated `decompress_accounts_idempotent` API

The existing helper in `light-compressible-client` needs to understand `LightAtaInput` and `LightMintInput`:

```rust
// light-compressible-client/src/lib.rs

/// Input enum for decompress_accounts_idempotent
/// Wraps all supported input types with their required data
pub enum DecompressInput<T> {
    /// Program-specific PDA or CToken (existing behavior)
    Standard {
        compressed_account: CompressedAccount,
        data: T,  // The variant data (implements Pack)
    },
    /// Standard ATA decompression
    LightAta {
        compressed_account: CompressedTokenAccount,
        wallet: Pubkey,  // Must be signer
    },
    /// Standard Mint decompression
    LightMint {
        compressed_account: CompressedAccount,
        mint_seed_pubkey: Pubkey,
    },
}

/// Builds decompress_accounts_idempotent instruction with full validation
#[allow(clippy::too_many_arguments)]
pub fn decompress_accounts_idempotent<T>(
    program_id: &Pubkey,
    discriminator: &[u8],
    decompressed_account_addresses: &[Pubkey],
    inputs: &[DecompressInput<T>],
    program_account_metas: &[AccountMeta],
    validity_proof_with_context: ValidityProofWithContext,
) -> Result<Instruction, CompressibleClientError>
where
    T: Pack + Clone + std::fmt::Debug,
    T::Packed: AnchorSerialize,
{
    // CLIENT-SIDE VALIDATION
    let mut mint_count = 0;
    let mut has_tokens = false;

    for input in inputs {
        match input {
            DecompressInput::LightMint { .. } => mint_count += 1,
            DecompressInput::LightAta { .. } => has_tokens = true,
            DecompressInput::Standard { compressed_account, .. } => {
                if compressed_account.owner == C_TOKEN_PROGRAM_ID.into() {
                    has_tokens = true;
                }
            }
        }
    }

    // Constraint 1: Max 1 mint
    if mint_count > 1 {
        return Err(CompressibleClientError::AtMostOneMintAllowed);
    }

    // Constraint 2: Mint + tokens forbidden
    if mint_count > 0 && has_tokens {
        return Err(CompressibleClientError::MintAndTokensForbidden);
    }

    // ... rest of implementation (see section 6.2)
}
```

### 6.2 Detailed Client Helper Implementation

```rust
pub fn decompress_accounts_idempotent<T>(
    program_id: &Pubkey,
    discriminator: &[u8],
    decompressed_account_addresses: &[Pubkey],
    inputs: &[DecompressInput<T>],
    program_account_metas: &[AccountMeta],
    validity_proof_with_context: ValidityProofWithContext,
) -> Result<Instruction, CompressibleClientError>
where
    T: Pack + Clone + std::fmt::Debug,
    T::Packed: AnchorSerialize,
{
    if inputs.is_empty() {
        return Err(CompressibleClientError::EmptyInputs);
    }

    // 1. Validate constraints (as shown above)
    // ... validation code ...

    // 2. Determine if CPI context is needed
    let has_pdas = inputs.iter().any(|i| matches!(i,
        DecompressInput::Standard { compressed_account, .. }
        if compressed_account.owner != C_TOKEN_PROGRAM_ID.into()
    ));
    let has_mints = inputs.iter().any(|i| matches!(i, DecompressInput::LightMint { .. }));
    let has_any_tokens = inputs.iter().any(|i| matches!(i,
        DecompressInput::LightAta { .. } |
        DecompressInput::Standard { compressed_account, .. }
        if compressed_account.owner == C_TOKEN_PROGRAM_ID.into()
    ));

    let needs_cpi_context = (has_pdas && has_any_tokens) || (has_pdas && has_mints);

    // 3. Setup PackedAccounts
    let mut remaining_accounts = PackedAccounts::default();

    if needs_cpi_context {
        let cpi_context = inputs.iter().find_map(|i| match i {
            DecompressInput::Standard { compressed_account, .. } =>
                compressed_account.tree_info.cpi_context,
            DecompressInput::LightAta { compressed_account, .. } =>
                compressed_account.account.tree_info.cpi_context,
            DecompressInput::LightMint { compressed_account, .. } =>
                compressed_account.tree_info.cpi_context,
        }).ok_or(CompressibleClientError::MissingCpiContext)?;

        let system_config = SystemAccountMetaConfig::new_with_cpi_context(*program_id, cpi_context);
        remaining_accounts.add_system_accounts_v2(system_config)?;
    } else {
        let system_config = SystemAccountMetaConfig::new(*program_id);
        remaining_accounts.add_system_accounts_v2(system_config)?;
    }

    // 4. Pack output queue
    let first_tree_info = get_first_tree_info(inputs)?;
    let output_queue = get_output_queue(&first_tree_info);
    let output_state_tree_index = remaining_accounts.insert_or_get(output_queue);

    // 5. Pack tree infos from validity proof
    let packed_tree_infos = validity_proof_with_context.pack_tree_infos(&mut remaining_accounts);
    let packed_tree_infos_slice = &packed_tree_infos.state_trees.as_ref().unwrap().packed_tree_infos;

    // 6. Pack each input into CompressedAccountData
    let mut compressed_accounts = Vec::with_capacity(inputs.len());

    for (i, input) in inputs.iter().enumerate() {
        let tree_info = packed_tree_infos_slice.get(i)
            .ok_or(CompressibleClientError::TreeInfoMismatch)?;

        match input {
            DecompressInput::Standard { compressed_account, data } => {
                remaining_accounts.insert_or_get(compressed_account.tree_info.queue);
                let packed_data = data.pack(&mut remaining_accounts);
                compressed_accounts.push(CompressedAccountData {
                    meta: CompressedAccountMetaNoLamportsNoAddress {
                        tree_info: *tree_info,
                        output_state_tree_index,
                    },
                    data: CompressedAccountVariant::from_packed(packed_data),
                });
            }

            DecompressInput::LightAta { compressed_account, wallet } => {
                remaining_accounts.insert_or_get(compressed_account.account.tree_info.queue);

                // Pack wallet as signer
                let wallet_index = remaining_accounts.insert_or_get_config(*wallet, true, false);
                let mint = Pubkey::new_from_array(compressed_account.token.mint);
                let mint_index = remaining_accounts.insert_or_get_read_only(mint);
                let ata = get_associated_token_address(wallet, &mint);
                let ata_index = remaining_accounts.insert_or_get(ata);

                let light_ata = LightAta {
                    wallet_index,
                    mint_index,
                    ata_index,
                    amount: compressed_account.token.amount,
                    has_delegate: compressed_account.token.delegate.is_some(),
                    delegate_index: compressed_account.token.delegate.map(|d|
                        remaining_accounts.insert_or_get_read_only(Pubkey::new_from_array(d))
                    ).unwrap_or(0),
                    is_frozen: compressed_account.token.state == AccountState::Frozen,
                };

                compressed_accounts.push(CompressedAccountData {
                    meta: CompressedAccountMetaNoLamportsNoAddress {
                        tree_info: *tree_info,
                        output_state_tree_index,
                    },
                    data: CompressedAccountVariant::LightAta(light_ata),
                });
            }

            DecompressInput::LightMint { compressed_account, mint_seed_pubkey } => {
                remaining_accounts.insert_or_get(compressed_account.tree_info.queue);

                // Parse mint data
                let mint_data: CompressedMint = borsh::BorshDeserialize::deserialize(
                    &mut &compressed_account.data.as_ref().unwrap().data[..]
                )?;

                let mint_seed_index = remaining_accounts.insert_or_get_read_only(*mint_seed_pubkey);
                let (cmint_pda, _) = find_cmint_address(mint_seed_pubkey);
                let cmint_pda_index = remaining_accounts.insert_or_get(cmint_pda);

                let has_mint_authority = mint_data.base.mint_authority.is_some();
                let mint_authority_index = mint_data.base.mint_authority.map(|auth|
                    remaining_accounts.insert_or_get_read_only(Pubkey::new_from_array(auth.to_bytes()))
                ).unwrap_or(0);

                let has_freeze_authority = mint_data.base.freeze_authority.is_some();
                let freeze_authority_index = mint_data.base.freeze_authority.map(|auth|
                    remaining_accounts.insert_or_get_read_only(Pubkey::new_from_array(auth.to_bytes()))
                ).unwrap_or(0);

                let light_mint = LightMint {
                    mint_seed_index,
                    cmint_pda_index,
                    compressed_address: compressed_account.address.unwrap(),
                    leaf_index: tree_info.leaf_index,
                    prove_by_index: tree_info.prove_by_index,
                    root_index: tree_info.root_index,
                    supply: mint_data.base.supply,
                    decimals: mint_data.base.decimals,
                    version: mint_data.metadata.version,
                    cmint_decompressed: mint_data.metadata.cmint_decompressed,
                    has_mint_authority,
                    mint_authority_index,
                    has_freeze_authority,
                    freeze_authority_index,
                    rent_payment: 2,
                    write_top_up: 5000,
                };

                compressed_accounts.push(CompressedAccountData {
                    meta: CompressedAccountMetaNoLamportsNoAddress {
                        tree_info: *tree_info,
                        output_state_tree_index,
                    },
                    data: CompressedAccountVariant::LightMint(light_mint),
                });
            }
        }
    }

    // 7. Build instruction
    let mut accounts = program_account_metas.to_vec();
    let (system_accounts, system_accounts_offset, _) = remaining_accounts.to_account_metas();
    accounts.extend(system_accounts);

    for address in decompressed_account_addresses {
        accounts.push(AccountMeta::new(*address, false));
    }

    let instruction_data = DecompressMultipleAccountsIdempotentData {
        proof: validity_proof_with_context.proof,
        compressed_accounts,
        system_accounts_offset: system_accounts_offset as u8,
    };

    let serialized_data = instruction_data.try_to_vec()?;
    let mut data = Vec::with_capacity(discriminator.len() + serialized_data.len());
    data.extend_from_slice(discriminator);
    data.extend_from_slice(&serialized_data);

    Ok(Instruction {
        program_id: *program_id,
        accounts,
        data,
    })
}
```

---

## 7. On-Chain Runtime Changes

### 7.1 Validation in `process_decompress_accounts_idempotent`

```rust
// sdk-libs/sdk/src/compressible/decompress_runtime.rs

pub fn process_decompress_accounts_idempotent<'info, Ctx>(
    ctx: &Ctx,
    remaining_accounts: &[AccountInfo<'info>],
    compressed_accounts: Vec<Ctx::CompressedData>,
    proof: ValidityProof,
    system_accounts_offset: u8,
    cpi_signer: CpiSigner,
    program_id: &Pubkey,
    seed_params: Option<&Ctx::SeedParams>,
) -> Result<(), ProgramError>
where
    Ctx: DecompressContext<'info>,
{
    // Count account types
    let (has_tokens, has_pdas, has_mints, mint_count) =
        check_account_types_with_count(&compressed_accounts);

    // VALIDATE CONSTRAINTS
    if mint_count > 1 {
        msg!("At most 1 LightMint allowed per instruction, found {}", mint_count);
        return Err(LightSdkError::AtMostOneMintAllowed.into());
    }

    if has_mints && has_tokens {
        msg!("LightMint + (LightAta/CToken) combination is forbidden");
        return Err(LightSdkError::MintAndTokensForbidden.into());
    }

    // ... rest of existing processing logic ...
}
```

### 7.2 Processing LightAta

The `process_tokens` handler (in `DecompressContext` impl) handles `LightAta`:

```rust
// In macro-generated DecompressContext impl

fn process_tokens<'b>(
    &self,
    cpi_accounts: &CpiAccounts<'b, 'info>,
    compressed_token_accounts: Vec<...>,
    cpi_context_account: Option<&AccountInfo<'info>>,
    remaining_accounts: &[AccountInfo<'info>],
) -> Result<()> {
    for token_account in compressed_token_accounts {
        match token_account {
            // Program-owned CToken (Vault)
            TokenVariant::CTokenData(data) => {
                // Existing vault handling with program PDA signing
                // ...
            }

            // Standard LightAta
            TokenVariant::LightAta(light_ata) => {
                // Unpack wallet from remaining_accounts
                let wallet = &remaining_accounts[light_ata.wallet_index as usize];

                // Validate wallet is signer
                if !wallet.is_signer {
                    return Err(ProgramError::MissingRequiredSignature);
                }

                // Unpack mint and ATA
                let mint = &remaining_accounts[light_ata.mint_index as usize];
                let ata = &remaining_accounts[light_ata.ata_index as usize];

                // Create ATA if needed (idempotent)
                create_associated_token_account_idempotent(
                    fee_payer,
                    wallet,
                    mint,
                    ata,
                )?;

                // Decompress via ctoken CPI
                // Authority = wallet (signer)
                process_decompress_token_cpi(
                    cpi_accounts,
                    light_ata,
                    wallet, // authority is wallet for ATA
                    cpi_context_account,
                    remaining_accounts,
                )?;
            }
        }
    }
    Ok(())
}
```

### 7.3 Processing LightMint

```rust
fn process_mints<'b>(
    &self,
    cpi_accounts: &CpiAccounts<'b, 'info>,
    compressed_mint_accounts: Vec<(LightMint, CompressedAccountMetaNoLamportsNoAddress)>,
    cpi_context_account: Option<&AccountInfo<'info>>,
    remaining_accounts: &[AccountInfo<'info>],
) -> Result<()> {
    for (light_mint, meta) in compressed_mint_accounts {
        // Unpack accounts from remaining_accounts
        let mint_seed = &remaining_accounts[light_mint.mint_seed_index as usize];
        let cmint_pda = &remaining_accounts[light_mint.cmint_pda_index as usize];

        // Get mint authority (from accounts struct)
        let mint_authority = self.cmint_authority()
            .map(|a| a.to_account_info())
            .unwrap_or(self.fee_payer().to_account_info());

        // Decompress via ctoken CPI
        process_decompress_mint_cpi(
            cpi_accounts,
            light_mint,
            &mint_authority,
            cpi_context_account,
            remaining_accounts,
        )?;
    }
    Ok(())
}
```

---

## 8. Visual Diagram

```
                         DECOMPRESS_ACCOUNTS_IDEMPOTENT FLOW
================================================================================

#[compressible(...)] MACRO DECLARATION
--------------------------------------

    #[compressible(
        UserRecord = ("user_record", ctx.authority, data.owner),
        Vault = (is_token, "vault", ctx.cmint, authority = ("vault_authority")),
        owner = Pubkey,
    )]
                    |
                    | MACRO GENERATES:
                    |
                    v
    ┌─────────────────────────────────────────────────────────────────────┐
    │  CompressedAccountVariant enum                                      │
    │  ├── UserRecord(UserRecord)           // Program PDA               │
    │  ├── PackedUserRecord(PackedUserRecord)                            │
    │  ├── PackedCTokenData(PackedCTokenData<CTokenAccountVariant>)      │
    │  ├── CTokenData(CTokenData<CTokenAccountVariant>)                  │
    │  ├── LightAta(LightAta)               // ALWAYS INCLUDED           │
    │  └── LightMint(LightMint)             // ALWAYS INCLUDED           │
    └─────────────────────────────────────────────────────────────────────┘

================================================================================

CLIENT-SIDE (light-compressible-client)
---------------------------------------

    // Build inputs
    let inputs = vec![
        DecompressInput::Standard { compressed, data: UserRecord {...} },
        DecompressInput::LightAta { compressed, wallet: user_wallet },
    ];

    decompress_accounts_idempotent(&program_id, &discriminator, &addresses, &inputs, ...)?;
                    |
                    | CLIENT VALIDATION:
                    |   - mint_count <= 1 ✓
                    |   - !(has_mints && has_tokens) ✓
                    |
                    | PACKING:
                    |   - System accounts
                    |   - Tree infos
                    |   - For LightAta: wallet(signer), mint, ata
                    |   - For LightMint: mint_seed, cmint_pda, authorities
                    |
                    v
              [Instruction]

================================================================================

ON-CHAIN RUNTIME
----------------

    process_decompress_accounts_idempotent()
           |
           v
    ┌─────────────────────────────────────────────────────────────────────┐
    │  1. VALIDATE CONSTRAINTS                                            │
    │     - mint_count > 1? → ERROR: AtMostOneMintAllowed                 │
    │     - has_mints && has_tokens? → ERROR: MintAndTokensForbidden      │
    └─────────────────────────────────────────────────────────────────────┘
           |
           v (passed)
    ┌─────────────────────────────────────────────────────────────────────┐
    │  2. DETERMINE CPI MODE                                              │
    │     - type_count = has_pdas + has_mints + has_tokens                │
    │     - use_cpi_context = type_count > 1                              │
    └─────────────────────────────────────────────────────────────────────┘
           |
           +--------------+--------------+--------------+
           |              |              |              |
           v              v              v              v
    ┌──────────┐   ┌───────────┐   ┌───────────┐   ┌───────────┐
    │ PROCESS  │   │ PROCESS   │   │ PROCESS   │   │ PROCESS   │
    │ PDAs     │   │ CTokens   │   │ LightAta  │   │ LightMint │
    │          │   │ (Vaults)  │   │           │   │           │
    │ Program  │   │ Program   │   │ Wallet    │   │ Authority │
    │ PDA      │   │ PDA       │   │ signs     │   │ signs     │
    │ signing  │   │ signing   │   │           │   │           │
    └──────────┘   └───────────┘   └───────────┘   └───────────┘

================================================================================

VALID COMBINATIONS MATRIX
-------------------------

    │ PDAs │ CToken │ LightAta │ LightMint │ VALID? │ Notes                    │
    │──────│────────│──────────│───────────│────────│──────────────────────────│
    │  Y   │   N    │    N     │     N     │   ✅   │ PDAs only                │
    │  N   │   Y    │    N     │     N     │   ✅   │ Vaults only              │
    │  N   │   N    │    Y     │     N     │   ✅   │ ATAs only                │
    │  N   │   N    │    N     │     Y     │   ✅   │ Mint only (max 1)        │
    │  Y   │   Y    │    N     │     N     │   ✅   │ PDAs + Vaults            │
    │  Y   │   N    │    Y     │     N     │   ✅   │ PDAs + ATAs              │
    │  Y   │   N    │    N     │     Y     │   ✅   │ PDAs + Mint              │
    │  N   │   Y    │    Y     │     N     │   ✅   │ Vaults + ATAs            │
    │  Y   │   Y    │    Y     │     N     │   ✅   │ All tokens + PDAs        │
    │  N   │   Y    │    N     │     Y     │   ❌   │ FORBIDDEN                │
    │  N   │   N    │    Y     │     Y     │   ❌   │ FORBIDDEN                │
    │  *   │   *    │    *     │    >1     │   ❌   │ Max 1 mint               │

================================================================================
```

---

## 9. Implementation Checklist

### 9.1 New Types (light-ctoken-sdk)

| File                             | Change                            |
| -------------------------------- | --------------------------------- |
| `src/compressible/light_ata.rs`  | Add `LightAta`, `LightAtaInput`   |
| `src/compressible/light_mint.rs` | Add `LightMint`, `LightMintInput` |
| `src/compressible/mod.rs`        | Export new types                  |

### 9.2 Errors (light-sdk)

| File           | Change                                               |
| -------------- | ---------------------------------------------------- |
| `src/error.rs` | Add `AtMostOneMintAllowed`, `MintAndTokensForbidden` |

### 9.3 Macro Changes

| File                                     | Change                                         |
| ---------------------------------------- | ---------------------------------------------- |
| `src/compressible/variant_enum.rs`       | Import `LightAta`, `LightMint` from ctoken-sdk |
| `src/compressible/variant_enum.rs`       | Always add `LightAta`, `LightMint` variants    |
| `src/compressible/variant_enum.rs`       | Remove `#[ata]` attribute handling             |
| `src/compressible/decompress_context.rs` | Handle `LightAta` in `process_tokens`          |
| `src/compressible/decompress_context.rs` | Handle `LightMint` in `process_mints`          |

### 9.4 Client Changes (light-compressible-client)

| File         | Change                                                      |
| ------------ | ----------------------------------------------------------- |
| `src/lib.rs` | Add `DecompressInput` enum                                  |
| `src/lib.rs` | Add `CompressibleClientError` variants                      |
| `src/lib.rs` | Update `decompress_accounts_idempotent` to handle all types |
| `src/lib.rs` | Add client-side constraint validation                       |

### 9.5 Runtime Changes (light-sdk)

| File                                     | Change                                            |
| ---------------------------------------- | ------------------------------------------------- |
| `src/compressible/decompress_runtime.rs` | Add constraint validation                         |
| `src/compressible/decompress_runtime.rs` | Update `check_account_types` to return mint count |

---

## 10. Summary

| Old Design                                  | New Design                                        |
| ------------------------------------------- | ------------------------------------------------- |
| Declare `UserAta = (is_token, is_ata, ...)` | Use `LightAta` (standard type, always available)  |
| Declare `CMint = (is_token, ...)`           | Use `LightMint` (standard type, always available) |
| Client manually packs ATAs                  | Client uses `DecompressInput::LightAta`           |
| Client manually packs Mints                 | Client uses `DecompressInput::LightMint`          |
| No constraint validation                    | Client + on-chain validation                      |

**Key Benefits:**

1. **Simpler macro declarations** - No ATA/Mint variants to declare
2. **Standard client API** - `DecompressInput` enum handles all types
3. **Type safety** - Can't confuse ATAs with Vaults
4. **Defense in depth** - Both client and on-chain validation

**Processing order (fixed):**

1. PDAs → 2. LightMint → 3. CToken/LightAta
