//! Program-wide variant enum generation for #[light_program] macro.
//!
//! This module generates:
//! 1. `LightAccountVariant` enum collecting all per-field variants from instruction structs
//! 2. `PackedLightAccountVariant` enum with packed versions
//! 3. `impl DecompressVariant for PackedLightAccountVariant` dispatch
//!
//! The per-field variant structs (`{Field}Variant`, `Packed{Field}Variant`) are generated
//! by `#[derive(LightAccounts)]` in `accounts/variant.rs`.

use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use syn::{Ident, Result, Type};

// =============================================================================
// LIGHT VARIANT BUILDER
// =============================================================================

/// Builder for generating program-wide variant enums and dispatch implementations.
///
/// This builder is simplified compared to the previous implementation - it only
/// wraps the per-field variants generated by `#[derive(LightAccounts)]`.
///
/// Takes `PdaCtxSeedInfo` collected from instruction account structs and generates:
/// 1. `LightAccountVariant` enum wrapping per-field `{Field}Variant` structs
/// 2. `PackedLightAccountVariant` enum wrapping per-field `Packed{Field}Variant` structs
/// 3. `impl DecompressVariant for PackedLightAccountVariant` dispatch
pub(super) struct LightVariantBuilder<'a> {
    /// PDA ctx seed info collected from all instruction account structs.
    pda_ctx_seeds: &'a [PdaCtxSeedInfo],
    /// Whether to include CToken variants in the generated enum.
    include_ctoken: bool,
}

impl<'a> LightVariantBuilder<'a> {
    /// Create a new LightVariantBuilder with the given PDA ctx seed info.
    pub fn new(pda_ctx_seeds: &'a [PdaCtxSeedInfo]) -> Self {
        Self {
            pda_ctx_seeds,
            include_ctoken: false, // Only enable for programs with token fields
        }
    }

    /// Enable CToken variants (for programs with token fields).
    pub fn with_ctoken(mut self) -> Self {
        self.include_ctoken = true;
        self
    }

    /// Validate the builder configuration.
    pub fn validate(&self) -> Result<()> {
        if self.pda_ctx_seeds.is_empty() {
            return Err(syn::Error::new(
                proc_macro2::Span::call_site(),
                "#[light_program] requires at least one Accounts struct with \
                 #[light_account(init)] fields.\n\n\
                 Make sure your program has:\n\
                 1. An Accounts struct with #[derive(Accounts, LightAccounts)]\n\
                 2. At least one field marked with #[light_account(init)]\n\n\
                 Example:\n\
                 #[derive(Accounts, LightAccounts)]\n\
                 #[instruction(params: MyParams)]\n\
                 pub struct MyAccounts<'info> {\n    \
                     #[account(init, ...)]\n    \
                     #[light_account(init)]\n    \
                     pub my_account: Account<'info, MyData>,\n\
                 }",
            ));
        }
        Ok(())
    }

    /// Generate the complete enum definitions and trait implementations.
    pub fn build(&self) -> Result<TokenStream> {
        self.validate()?;

        // NOTE: Variant structs (`RecordVariant`, `PackedRecordVariant`, etc.) are generated
        // by `#[derive(LightAccounts)]` in the instruction module. We just wrap them in
        // the program-wide enum here. Do NOT regenerate them to avoid conflicts.
        let unpacked_enum = self.generate_unpacked_enum();
        let packed_enum = self.generate_packed_enum();
        let light_account_data_struct = self.generate_light_account_data_struct();
        let decompress_variant_impl = self.generate_decompress_variant_impl();
        let pack_impl = self.generate_pack_impl();
        // NOTE: v2 API only - no DecompressibleAccount impl needed (that's v1)

        Ok(quote! {
            #unpacked_enum
            #packed_enum
            #light_account_data_struct
            #decompress_variant_impl
            #pack_impl
        })
    }

    /// Generate the `LightAccountData` wrapper struct.
    ///
    /// This struct combines the PACKED variant enum with metadata for decompression.
    /// The packed variant implements `DecompressVariant` which handles unpacking.
    fn generate_light_account_data_struct(&self) -> TokenStream {
        quote! {
            /// Wrapper for compressed account data with metadata.
            /// Contains PACKED variant data that will be decompressed into PDA accounts.
            #[derive(Clone, Debug, anchor_lang::AnchorSerialize, anchor_lang::AnchorDeserialize)]
            pub struct LightAccountData {
                pub meta: light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
                pub data: PackedLightAccountVariant,
            }
        }
    }

    /// Generate the unpacked `LightAccountVariant` enum.
    ///
    /// Each variant wraps the per-field variant struct generated by LightAccounts.
    fn generate_unpacked_enum(&self) -> TokenStream {
        let variants: Vec<_> = self
            .pda_ctx_seeds
            .iter()
            .map(|info| {
                let variant_name = &info.variant_name;
                let variant_type = format_ident!("{}Variant", variant_name);
                quote! { #variant_name(#variant_type) }
            })
            .collect();

        let ctoken_variants = if self.include_ctoken {
            quote! {
                CTokenData(light_token::compat::CTokenData<TokenAccountVariant>),
            }
        } else {
            quote! {}
        };

        quote! {
            /// Program-wide unpacked variant enum collecting all per-field variants.
            #[derive(anchor_lang::AnchorSerialize, anchor_lang::AnchorDeserialize, Clone, Debug)]
            pub enum LightAccountVariant {
                #(#variants,)*
                #ctoken_variants
            }
        }
    }

    /// Generate the packed `PackedLightAccountVariant` enum.
    ///
    /// Each variant wraps the packed per-field variant struct generated by LightAccounts.
    fn generate_packed_enum(&self) -> TokenStream {
        let variants: Vec<_> = self
            .pda_ctx_seeds
            .iter()
            .map(|info| {
                let variant_name = &info.variant_name;
                let packed_variant_type = format_ident!("Packed{}Variant", variant_name);
                quote! { #variant_name(#packed_variant_type) }
            })
            .collect();

        let ctoken_variants = if self.include_ctoken {
            quote! {
                PackedCTokenData(light_token::compat::PackedCTokenData<PackedTokenAccountVariant>),
            }
        } else {
            quote! {}
        };

        quote! {
            /// Program-wide packed variant enum for efficient serialization.
            #[derive(anchor_lang::AnchorSerialize, anchor_lang::AnchorDeserialize, Clone, Debug)]
            pub enum PackedLightAccountVariant {
                #(#variants,)*
                #ctoken_variants
            }
        }
    }

    /// Generate `impl DecompressVariant for PackedLightAccountVariant`.
    ///
    /// This dispatches to `prepare_account_for_decompression` for each variant.
    fn generate_decompress_variant_impl(&self) -> TokenStream {
        let match_arms: Vec<_> = self
            .pda_ctx_seeds
            .iter()
            .map(|info| {
                let variant_name = &info.variant_name;
                let packed_variant_type = format_ident!("Packed{}Variant", variant_name);
                // Use the seed_count stored in PdaCtxSeedInfo (total seeds + 1 for bump)
                let seed_count = info.seed_count;

                quote! {
                    Self::#variant_name(packed_data) => {
                        light_sdk::interface::prepare_account_for_decompression::<#seed_count, #packed_variant_type>(
                            packed_data,
                            meta,
                            pda_account,
                            ctx,
                        )
                    }
                }
            })
            .collect();

        let ctoken_arm = if self.include_ctoken {
            quote! {
                Self::PackedCTokenData(_) => {
                    Err(light_sdk::error::LightSdkError::TokenPrepareCalled.into())
                }
            }
        } else {
            quote! {}
        };

        quote! {
            impl<'info> light_sdk::interface::DecompressVariant<'info> for PackedLightAccountVariant {
                fn decompress(
                    &self,
                    meta: &light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
                    pda_account: &anchor_lang::prelude::AccountInfo<'info>,
                    ctx: &mut light_sdk::interface::DecompressCtx<'_, 'info>,
                ) -> std::result::Result<(), solana_program_error::ProgramError> {
                    match self {
                        #(#match_arms)*
                        #ctoken_arm
                    }
                }
            }
        }
    }

    /// Generate `impl light_sdk::Pack for LightAccountVariant`.
    ///
    /// This enables the enum to be used with `create_load_instructions` which requires
    /// `V: Pack + Clone + Debug`. Each match arm delegates to the per-field variant's
    /// `LightAccountVariantTrait::pack` method.
    fn generate_pack_impl(&self) -> TokenStream {
        let match_arms: Vec<_> = self
            .pda_ctx_seeds
            .iter()
            .map(|info| {
                let variant_name = &info.variant_name;
                let seed_count = info.seed_count;

                quote! {
                    Self::#variant_name(variant) => {
                        let packed = light_sdk::interface::LightAccountVariantTrait::<#seed_count>::pack(variant, accounts)
                            .map_err(|_| solana_program_error::ProgramError::InvalidAccountData)?;
                        Ok(PackedLightAccountVariant::#variant_name(packed))
                    }
                }
            })
            .collect();

        let ctoken_arm = if self.include_ctoken {
            quote! {
                Self::CTokenData(_) => {
                    Err(solana_program_error::ProgramError::InvalidAccountData)
                }
            }
        } else {
            quote! {}
        };

        quote! {
            impl light_sdk::Pack for LightAccountVariant {
                type Packed = PackedLightAccountVariant;

                fn pack(
                    &self,
                    accounts: &mut light_sdk::instruction::PackedAccounts,
                ) -> std::result::Result<Self::Packed, solana_program_error::ProgramError> {
                    match self {
                        #(#match_arms)*
                        #ctoken_arm
                    }
                }
            }
        }
    }

}

// =============================================================================
// LEGACY SUPPORT: PdaCtxSeedInfo
// =============================================================================

/// Info about ctx.* seeds for a PDA type.
///
/// This struct is used during the transition period to maintain compatibility
/// with existing code. It will be simplified once the full migration is complete.
#[derive(Clone, Debug)]
pub struct PdaCtxSeedInfo {
    /// The variant name (derived from field name, e.g., "Record" from field "record")
    pub variant_name: Ident,
    /// The inner type (e.g., crate::state::SinglePubkeyRecord - preserves full path)
    pub inner_type: Type,
    /// Field names from ctx.accounts.XXX references in seeds
    pub ctx_seed_fields: Vec<Ident>,
    /// Field names that exist on the state struct (for filtering data.* seeds)
    pub state_field_names: std::collections::HashSet<String>,
    /// Params-only seed fields (name, type, has_conversion) - seeds from params.* that don't exist on state
    /// The bool indicates whether a conversion method like to_le_bytes() is applied
    pub params_only_seed_fields: Vec<(Ident, Type, bool)>,
    /// Total number of seeds + 1 for bump. This is used as the const generic N
    /// for PackedLightAccountVariant<N>.
    pub seed_count: usize,
}

impl PdaCtxSeedInfo {
    pub fn with_state_fields(
        variant_name: Ident,
        inner_type: Type,
        ctx_seed_fields: Vec<Ident>,
        state_field_names: std::collections::HashSet<String>,
        params_only_seed_fields: Vec<(Ident, Type, bool)>,
        seed_count: usize,
    ) -> Self {
        Self {
            variant_name,
            inner_type,
            ctx_seed_fields,
            state_field_names,
            params_only_seed_fields,
            seed_count,
        }
    }
}

// =============================================================================
// TOKEN VARIANT BUILDER (unchanged)
// =============================================================================

use super::parsing::{SeedElement, TokenSeedSpec};

/// Builder for generating `TokenAccountVariant` and `PackedTokenAccountVariant` enums.
///
/// Encapsulates the token seed specifications needed to generate
/// all token variant-related code: enum definitions, Pack/Unpack impls, and IntoCTokenVariant.
pub(super) struct TokenVariantBuilder<'a> {
    /// Token seed specifications for each token variant.
    token_seeds: &'a [TokenSeedSpec],
}

impl<'a> TokenVariantBuilder<'a> {
    /// Create a new TokenVariantBuilder with the given token seeds.
    pub fn new(token_seeds: &'a [TokenSeedSpec]) -> Self {
        Self { token_seeds }
    }

    /// Generate the complete token variant code.
    pub fn build(&self) -> Result<TokenStream> {
        let unpacked_enum = self.generate_unpacked_enum();
        let packed_enum = self.generate_packed_enum();
        let pack_impl = self.generate_pack_impl();
        let unpack_impl = self.generate_unpack_impl();
        let into_ctoken_variant_impl = self.generate_into_ctoken_variant_impl();

        Ok(quote! {
            #unpacked_enum
            #packed_enum
            #pack_impl
            #unpack_impl
            #into_ctoken_variant_impl
        })
    }

    /// Generate the unpacked TokenAccountVariant enum.
    fn generate_unpacked_enum(&self) -> TokenStream {
        generate_token_variant_enum(self.token_seeds, "TokenAccountVariant", false)
    }

    /// Generate the packed PackedTokenAccountVariant enum.
    fn generate_packed_enum(&self) -> TokenStream {
        generate_token_variant_enum(self.token_seeds, "PackedTokenAccountVariant", true)
    }

    /// Generate the Pack implementation for TokenAccountVariant.
    fn generate_pack_impl(&self) -> TokenStream {
        let arms = self.token_seeds.iter().map(|spec| {
            let variant_name = &spec.variant;
            let ctx_fields = extract_ctx_fields_from_token_spec(spec);

            if ctx_fields.is_empty() {
                quote! {
                    TokenAccountVariant::#variant_name => Ok(PackedTokenAccountVariant::#variant_name),
                }
            } else {
                let field_bindings: Vec<_> = ctx_fields.iter().collect();
                let idx_fields: Vec<_> = ctx_fields
                    .iter()
                    .map(|f| format_ident!("{}_idx", f))
                    .collect();
                let pack_stmts: Vec<_> = ctx_fields
                    .iter()
                    .zip(idx_fields.iter())
                    .map(|(field, idx)| {
                        quote! { let #idx = remaining_accounts.insert_or_get(*#field); }
                    })
                    .collect();

                quote! {
                    TokenAccountVariant::#variant_name { #(#field_bindings,)* } => {
                        #(#pack_stmts)*
                        Ok(PackedTokenAccountVariant::#variant_name { #(#idx_fields,)* })
                    }
                }
            }
        });

        quote! {
            impl light_token::pack::Pack for TokenAccountVariant {
                type Packed = PackedTokenAccountVariant;

                fn pack(&self, remaining_accounts: &mut light_sdk::instruction::PackedAccounts) -> std::result::Result<Self::Packed, solana_program_error::ProgramError> {
                    match self {
                        #(#arms)*
                    }
                }
            }
        }
    }

    /// Generate the Unpack implementation for PackedTokenAccountVariant.
    fn generate_unpack_impl(&self) -> TokenStream {
        let arms = self.token_seeds.iter().map(|spec| {
            let variant_name = &spec.variant;
            let ctx_fields = extract_ctx_fields_from_token_spec(spec);

            if ctx_fields.is_empty() {
                quote! {
                    PackedTokenAccountVariant::#variant_name => Ok(TokenAccountVariant::#variant_name),
                }
            } else {
                let idx_fields: Vec<_> = ctx_fields
                    .iter()
                    .map(|f| format_ident!("{}_idx", f))
                    .collect();
                let unpack_stmts: Vec<_> = ctx_fields
                    .iter()
                    .zip(idx_fields.iter())
                    .map(|(field, idx)| {
                        quote! {
                            let #field = *remaining_accounts
                                .get(*#idx as usize)
                                .ok_or(solana_program_error::ProgramError::InvalidAccountData)?
                                .key;
                        }
                    })
                    .collect();
                let field_names: Vec<_> = ctx_fields.iter().collect();

                quote! {
                    PackedTokenAccountVariant::#variant_name { #(#idx_fields,)* } => {
                        #(#unpack_stmts)*
                        Ok(TokenAccountVariant::#variant_name { #(#field_names,)* })
                    }
                }
            }
        });

        quote! {
            impl light_token::pack::Unpack for PackedTokenAccountVariant {
                type Unpacked = TokenAccountVariant;

                fn unpack(
                    &self,
                    remaining_accounts: &[solana_account_info::AccountInfo],
                ) -> std::result::Result<Self::Unpacked, solana_program_error::ProgramError> {
                    match self {
                        #(#arms)*
                    }
                }
            }
        }
    }

    /// Generate the IntoCTokenVariant implementation.
    fn generate_into_ctoken_variant_impl(&self) -> TokenStream {
        quote! {
            impl light_sdk::interface::IntoCTokenVariant<LightAccountVariant, light_token::compat::TokenData> for TokenAccountVariant {
                fn into_ctoken_variant(self, token_data: light_token::compat::TokenData) -> LightAccountVariant {
                    LightAccountVariant::CTokenData(light_token::compat::CTokenData {
                        variant: self,
                        token_data,
                    })
                }
            }
        }
    }
}

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

/// Generate a token variant enum with customizable field types.
fn generate_token_variant_enum(
    token_seeds: &[TokenSeedSpec],
    enum_name: &str,
    is_packed: bool,
) -> TokenStream {
    let enum_ident = format_ident!("{}", enum_name);
    let variants = token_seeds.iter().map(|spec| {
        let variant_name = &spec.variant;
        let ctx_fields = extract_ctx_fields_from_token_spec(spec);

        let fields: Vec<_> = ctx_fields
            .iter()
            .map(|field| {
                if is_packed {
                    let idx_field = format_ident!("{}_idx", field);
                    quote! { #idx_field: u8 }
                } else {
                    quote! { #field: Pubkey }
                }
            })
            .collect();

        if ctx_fields.is_empty() {
            quote! { #variant_name, }
        } else {
            quote! { #variant_name { #(#fields,)* }, }
        }
    });

    quote! {
        #[derive(anchor_lang::AnchorSerialize, anchor_lang::AnchorDeserialize, Debug, Clone, Copy)]
        pub enum #enum_ident {
            #(#variants)*
        }
    }
}

/// Extract ctx.* field names from seed elements (both token seeds and authority seeds).
///
/// Uses the visitor-based FieldExtractor for clean AST traversal.
pub fn extract_ctx_fields_from_token_spec(spec: &TokenSeedSpec) -> Vec<Ident> {
    const EXCLUDED: &[&str] = &[
        "fee_payer",
        "rent_sponsor",
        "config",
        "compression_authority",
    ];

    let mut all_fields = Vec::new();
    let mut seen = std::collections::HashSet::new();

    for seed in spec.seeds.iter().chain(spec.authority.iter().flatten()) {
        if let SeedElement::Expression(expr) = seed {
            // Extract fields from this expression using the visitor
            let fields = super::visitors::FieldExtractor::ctx_fields(EXCLUDED).extract(expr);
            // Deduplicate across seeds
            for field in fields {
                let name = field.to_string();
                if seen.insert(name) {
                    all_fields.push(field);
                }
            }
        }
    }

    all_fields
}
