#[allow(unused_imports)]
pub use progenitor_client::{ByteStream, ClientInfo, Error, ResponseValue};
#[allow(unused_imports)]
use progenitor_client::{encode_path, ClientHooks, OperationInfo, RequestBuilderExt};
/// Types used as operation parameters and responses.
#[allow(clippy::all)]
pub mod types {
    /// Error types.
    pub mod error {
        /// Error from a `TryFrom` or `FromStr` implementation.
        pub struct ConversionError(::std::borrow::Cow<'static, str>);
        impl ::std::error::Error for ConversionError {}
        impl ::std::fmt::Display for ConversionError {
            fn fmt(
                &self,
                f: &mut ::std::fmt::Formatter<'_>,
            ) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Display::fmt(&self.0, f)
            }
        }
        impl ::std::fmt::Debug for ConversionError {
            fn fmt(
                &self,
                f: &mut ::std::fmt::Formatter<'_>,
            ) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Debug::fmt(&self.0, f)
            }
        }
        impl From<&'static str> for ConversionError {
            fn from(value: &'static str) -> Self {
                Self(value.into())
            }
        }
        impl From<String> for ConversionError {
            fn from(value: String) -> Self {
                Self(value.into())
            }
        }
    }
    ///`Account`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "hash",
    ///    "lamports",
    ///    "leafIndex",
    ///    "owner",
    ///    "slotCreated",
    ///    "tree"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "data": {
    ///      "$ref": "#/components/schemas/AccountData"
    ///    },
    ///    "hash": {
    ///      "$ref": "#/components/schemas/Hash"
    ///    },
    ///    "lamports": {
    ///      "$ref": "#/components/schemas/UnsignedInteger"
    ///    },
    ///    "leafIndex": {
    ///      "$ref": "#/components/schemas/UnsignedInteger"
    ///    },
    ///    "owner": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "seq": {
    ///      "$ref": "#/components/schemas/UnsignedInteger"
    ///    },
    ///    "slotCreated": {
    ///      "$ref": "#/components/schemas/UnsignedInteger"
    ///    },
    ///    "tree": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct Account {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<SerializablePubkey>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub data: ::std::option::Option<AccountData>,
        pub hash: Hash,
        pub lamports: UnsignedInteger,
        #[serde(rename = "leafIndex")]
        pub leaf_index: UnsignedInteger,
        pub owner: SerializablePubkey,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub seq: ::std::option::Option<UnsignedInteger>,
        #[serde(rename = "slotCreated")]
        pub slot_created: UnsignedInteger,
        pub tree: SerializablePubkey,
    }
    impl Account {
        pub fn builder() -> builder::Account {
            Default::default()
        }
    }
    /**This is currently used internally:
- Internal (state_updates,..)
- GetTransactionWithCompressionInfo (internally)
- GetTransactionWithCompressionInfoV2 (internally)
All endpoints return AccountV2.*/
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "This is currently used internally:\n- Internal (state_updates,..)\n- GetTransactionWithCompressionInfo (internally)\n- GetTransactionWithCompressionInfoV2 (internally)\nAll endpoints return AccountV2.",
    ///  "type": "object",
    ///  "required": [
    ///    "inOutputQueue",
    ///    "nullifiedInTree",
    ///    "queue",
    ///    "spent",
    ///    "treeType"
    ///  ],
    ///  "properties": {
    ///    "inOutputQueue": {
    ///      "type": "boolean"
    ///    },
    ///    "nullifiedInTree": {
    ///      "type": "boolean"
    ///    },
    ///    "nullifier": {
    ///      "$ref": "#/components/schemas/Hash"
    ///    },
    ///    "nullifierQueueIndex": {
    ///      "$ref": "#/components/schemas/UnsignedInteger"
    ///    },
    ///    "queue": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "spent": {
    ///      "type": "boolean"
    ///    },
    ///    "treeType": {
    ///      "type": "integer",
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    },
    ///    "txHash": {
    ///      "$ref": "#/components/schemas/Hash"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AccountContext {
        #[serde(rename = "inOutputQueue")]
        pub in_output_queue: bool,
        #[serde(rename = "nullifiedInTree")]
        pub nullified_in_tree: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub nullifier: ::std::option::Option<Hash>,
        #[serde(
            rename = "nullifierQueueIndex",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub nullifier_queue_index: ::std::option::Option<UnsignedInteger>,
        pub queue: SerializablePubkey,
        pub spent: bool,
        #[serde(rename = "treeType")]
        pub tree_type: u16,
        #[serde(
            rename = "txHash",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub tx_hash: ::std::option::Option<Hash>,
    }
    impl AccountContext {
        pub fn builder() -> builder::AccountContext {
            Default::default()
        }
    }
    ///`AccountData`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "dataHash",
    ///    "discriminator"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "$ref": "#/components/schemas/Base64String"
    ///    },
    ///    "dataHash": {
    ///      "$ref": "#/components/schemas/Hash"
    ///    },
    ///    "discriminator": {
    ///      "$ref": "#/components/schemas/UnsignedInteger"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AccountData {
        pub data: Base64String,
        #[serde(rename = "dataHash")]
        pub data_hash: Hash,
        pub discriminator: UnsignedInteger,
    }
    impl AccountData {
        pub fn builder() -> builder::AccountData {
            Default::default()
        }
    }
    ///Unified account interface — works for both on-chain and compressed accounts
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Unified account interface — works for both on-chain and compressed accounts",
    ///  "type": "object",
    ///  "required": [
    ///    "account",
    ///    "key"
    ///  ],
    ///  "properties": {
    ///    "account": {
    ///      "$ref": "#/components/schemas/SolanaAccountData"
    ///    },
    ///    "cold": {
    ///      "description": "Compressed accounts associated with this pubkey",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/AccountV2"
    ///      }
    ///    },
    ///    "key": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountInterface {
        pub account: SolanaAccountData,
        ///Compressed accounts associated with this pubkey
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cold: ::std::option::Option<::std::vec::Vec<AccountV2>>,
        pub key: SerializablePubkey,
    }
    impl AccountInterface {
        pub fn builder() -> builder::AccountInterface {
            Default::default()
        }
    }
    ///`AccountList`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "oneOf": [
    ///          {
    ///            "type": "null"
    ///          },
    ///          {
    ///            "allOf": [
    ///              {
    ///                "$ref": "#/components/schemas/Account"
    ///              }
    ///            ]
    ///          }
    ///        ]
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AccountList {
        pub items: ::std::vec::Vec<::std::option::Option<Account>>,
    }
    impl AccountList {
        pub fn builder() -> builder::AccountList {
            Default::default()
        }
    }
    ///`AccountListV2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "oneOf": [
    ///          {
    ///            "type": "null"
    ///          },
    ///          {
    ///            "allOf": [
    ///              {
    ///                "$ref": "#/components/schemas/AccountV2"
    ///              }
    ///            ]
    ///          }
    ///        ]
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountListV2 {
        pub items: ::std::vec::Vec<::std::option::Option<AccountV2>>,
    }
    impl AccountListV2 {
        pub fn builder() -> builder::AccountListV2 {
            Default::default()
        }
    }
    ///`AccountProofInputs`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "hash",
    ///    "leafIndex",
    ///    "merkleContext",
    ///    "root",
    ///    "rootIndex"
    ///  ],
    ///  "properties": {
    ///    "hash": {
    ///      "type": "string"
    ///    },
    ///    "leafIndex": {
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "merkleContext": {
    ///      "$ref": "#/components/schemas/MerkleContextV2"
    ///    },
    ///    "root": {
    ///      "type": "string"
    ///    },
    ///    "rootIndex": {
    ///      "$ref": "#/components/schemas/RootIndex"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AccountProofInputs {
        pub hash: ::std::string::String,
        #[serde(rename = "leafIndex")]
        pub leaf_index: u64,
        #[serde(rename = "merkleContext")]
        pub merkle_context: MerkleContextV2,
        pub root: ::std::string::String,
        #[serde(rename = "rootIndex")]
        pub root_index: RootIndex,
    }
    impl AccountProofInputs {
        pub fn builder() -> builder::AccountProofInputs {
            Default::default()
        }
    }
    ///`AccountState`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "initialized",
    ///    "frozen"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum AccountState {
        #[serde(rename = "initialized")]
        Initialized,
        #[serde(rename = "frozen")]
        Frozen,
    }
    impl ::std::fmt::Display for AccountState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Initialized => f.write_str("initialized"),
                Self::Frozen => f.write_str("frozen"),
            }
        }
    }
    impl ::std::str::FromStr for AccountState {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "initialized" => Ok(Self::Initialized),
                "frozen" => Ok(Self::Frozen),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for AccountState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for AccountState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for AccountState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`AccountV2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "hash",
    ///    "lamports",
    ///    "leafIndex",
    ///    "merkleContext",
    ///    "owner",
    ///    "proveByIndex",
    ///    "slotCreated"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "data": {
    ///      "$ref": "#/components/schemas/AccountData"
    ///    },
    ///    "hash": {
    ///      "$ref": "#/components/schemas/Hash"
    ///    },
    ///    "lamports": {
    ///      "$ref": "#/components/schemas/UnsignedInteger"
    ///    },
    ///    "leafIndex": {
    ///      "$ref": "#/components/schemas/UnsignedInteger"
    ///    },
    ///    "merkleContext": {
    ///      "$ref": "#/components/schemas/MerkleContextV2"
    ///    },
    ///    "owner": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "proveByIndex": {
    ///      "type": "boolean"
    ///    },
    ///    "seq": {
    ///      "$ref": "#/components/schemas/UnsignedInteger"
    ///    },
    ///    "slotCreated": {
    ///      "$ref": "#/components/schemas/UnsignedInteger"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AccountV2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<SerializablePubkey>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub data: ::std::option::Option<AccountData>,
        pub hash: Hash,
        pub lamports: UnsignedInteger,
        #[serde(rename = "leafIndex")]
        pub leaf_index: UnsignedInteger,
        #[serde(rename = "merkleContext")]
        pub merkle_context: MerkleContextV2,
        pub owner: SerializablePubkey,
        #[serde(rename = "proveByIndex")]
        pub prove_by_index: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub seq: ::std::option::Option<UnsignedInteger>,
        #[serde(rename = "slotCreated")]
        pub slot_created: UnsignedInteger,
    }
    impl AccountV2 {
        pub fn builder() -> builder::AccountV2 {
            Default::default()
        }
    }
    ///`AccountWithContext`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "account",
    ///    "context"
    ///  ],
    ///  "properties": {
    ///    "account": {
    ///      "$ref": "#/components/schemas/Account"
    ///    },
    ///    "context": {
    ///      "$ref": "#/components/schemas/AccountContext"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AccountWithContext {
        pub account: Account,
        pub context: AccountContext,
    }
    impl AccountWithContext {
        pub fn builder() -> builder::AccountWithContext {
            Default::default()
        }
    }
    ///`AccountWithOptionalTokenData`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "account"
    ///  ],
    ///  "properties": {
    ///    "account": {
    ///      "$ref": "#/components/schemas/Account"
    ///    },
    ///    "optionalTokenData": {
    ///      "$ref": "#/components/schemas/TokenData"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AccountWithOptionalTokenData {
        pub account: Account,
        #[serde(
            rename = "optionalTokenData",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub optional_token_data: ::std::option::Option<TokenData>,
    }
    impl AccountWithOptionalTokenData {
        pub fn builder() -> builder::AccountWithOptionalTokenData {
            Default::default()
        }
    }
    ///`AccountWithOptionalTokenDataV2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "account"
    ///  ],
    ///  "properties": {
    ///    "account": {
    ///      "$ref": "#/components/schemas/AccountV2"
    ///    },
    ///    "optionalTokenData": {
    ///      "$ref": "#/components/schemas/TokenData"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AccountWithOptionalTokenDataV2 {
        pub account: AccountV2,
        #[serde(
            rename = "optionalTokenData",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub optional_token_data: ::std::option::Option<TokenData>,
    }
    impl AccountWithOptionalTokenDataV2 {
        pub fn builder() -> builder::AccountWithOptionalTokenDataV2 {
            Default::default()
        }
    }
    ///`AddressListWithTrees`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "array",
    ///  "items": {
    ///    "$ref": "#/components/schemas/AddressWithTree"
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct AddressListWithTrees(pub ::std::vec::Vec<AddressWithTree>);
    impl ::std::ops::Deref for AddressListWithTrees {
        type Target = ::std::vec::Vec<AddressWithTree>;
        fn deref(&self) -> &::std::vec::Vec<AddressWithTree> {
            &self.0
        }
    }
    impl ::std::convert::From<AddressListWithTrees>
    for ::std::vec::Vec<AddressWithTree> {
        fn from(value: AddressListWithTrees) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<::std::vec::Vec<AddressWithTree>>
    for AddressListWithTrees {
        fn from(value: ::std::vec::Vec<AddressWithTree>) -> Self {
            Self(value)
        }
    }
    ///`AddressProofInputs`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "merkleContext",
    ///    "root",
    ///    "rootIndex"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    },
    ///    "merkleContext": {
    ///      "$ref": "#/components/schemas/MerkleContextV2"
    ///    },
    ///    "root": {
    ///      "type": "string"
    ///    },
    ///    "rootIndex": {
    ///      "type": "integer",
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct AddressProofInputs {
        pub address: ::std::string::String,
        #[serde(rename = "merkleContext")]
        pub merkle_context: MerkleContextV2,
        pub root: ::std::string::String,
        #[serde(rename = "rootIndex")]
        pub root_index: u16,
    }
    impl AddressProofInputs {
        pub fn builder() -> builder::AddressProofInputs {
            Default::default()
        }
    }
    ///`AddressQueueData`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "addresses",
    ///    "initialRoot",
    ///    "leavesHashChains",
    ///    "lowElementIndices",
    ///    "lowElementNextIndices",
    ///    "lowElementNextValues",
    ///    "lowElementValues",
    ///    "nodes",
    ///    "queueIndices",
    ///    "rootSeq",
    ///    "startIndex",
    ///    "subtrees"
    ///  ],
    ///  "properties": {
    ///    "addresses": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SerializablePubkey"
    ///      }
    ///    },
    ///    "initialRoot": {
    ///      "$ref": "#/components/schemas/Hash"
    ///    },
    ///    "leavesHashChains": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Hash"
    ///      }
    ///    },
    ///    "lowElementIndices": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer",
    ///        "format": "uint64",
    ///        "minimum": 0.0
    ///      }
    ///    },
    ///    "lowElementNextIndices": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer",
    ///        "format": "uint64",
    ///        "minimum": 0.0
    ///      }
    ///    },
    ///    "lowElementNextValues": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Hash"
    ///      }
    ///    },
    ///    "lowElementValues": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Hash"
    ///      }
    ///    },
    ///    "nodes": {
    ///      "description": "Deduplicated tree nodes - clients reconstruct proofs from these using low_element_indices",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Node"
    ///      }
    ///    },
    ///    "queueIndices": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer",
    ///        "format": "uint64",
    ///        "minimum": 0.0
    ///      }
    ///    },
    ///    "rootSeq": {
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "startIndex": {
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "subtrees": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Hash"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddressQueueData {
        pub addresses: ::std::vec::Vec<SerializablePubkey>,
        #[serde(rename = "initialRoot")]
        pub initial_root: Hash,
        #[serde(rename = "leavesHashChains")]
        pub leaves_hash_chains: ::std::vec::Vec<Hash>,
        #[serde(rename = "lowElementIndices")]
        pub low_element_indices: ::std::vec::Vec<u64>,
        #[serde(rename = "lowElementNextIndices")]
        pub low_element_next_indices: ::std::vec::Vec<u64>,
        #[serde(rename = "lowElementNextValues")]
        pub low_element_next_values: ::std::vec::Vec<Hash>,
        #[serde(rename = "lowElementValues")]
        pub low_element_values: ::std::vec::Vec<Hash>,
        ///Deduplicated tree nodes - clients reconstruct proofs from these using low_element_indices
        pub nodes: ::std::vec::Vec<Node>,
        #[serde(rename = "queueIndices")]
        pub queue_indices: ::std::vec::Vec<u64>,
        #[serde(rename = "rootSeq")]
        pub root_seq: u64,
        #[serde(rename = "startIndex")]
        pub start_index: u64,
        pub subtrees: ::std::vec::Vec<Hash>,
    }
    impl AddressQueueData {
        pub fn builder() -> builder::AddressQueueData {
            Default::default()
        }
    }
    ///`AddressWithTree`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "tree"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "tree": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct AddressWithTree {
        pub address: SerializablePubkey,
        pub tree: SerializablePubkey,
    }
    impl AddressWithTree {
        pub fn builder() -> builder::AddressWithTree {
            Default::default()
        }
    }
    ///A base 58 encoded string.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A base 58 encoded string.",
    ///  "default": "3J98t1WpEZ73CNm",
    ///  "examples": [
    ///    "3J98t1WpEZ73CNm"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    #[serde(transparent)]
    pub struct Base58String(pub ::std::string::String);
    impl ::std::ops::Deref for Base58String {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<Base58String> for ::std::string::String {
        fn from(value: Base58String) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<::std::string::String> for Base58String {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }
    impl ::std::str::FromStr for Base58String {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::fmt::Display for Base58String {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    ///A base 64 encoded string.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A base 64 encoded string.",
    ///  "default": "SGVsbG8sIFdvcmxkIQ==",
    ///  "examples": [
    ///    "SGVsbG8sIFdvcmxkIQ=="
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    #[serde(transparent)]
    pub struct Base64String(pub ::std::string::String);
    impl ::std::ops::Deref for Base64String {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<Base64String> for ::std::string::String {
        fn from(value: Base64String) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<::std::string::String> for Base64String {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }
    impl ::std::str::FromStr for Base64String {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::fmt::Display for Base64String {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    ///`ClosedAccountV2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "account",
    ///    "nullifier",
    ///    "txHash"
    ///  ],
    ///  "properties": {
    ///    "account": {
    ///      "$ref": "#/components/schemas/AccountV2"
    ///    },
    ///    "nullifier": {
    ///      "$ref": "#/components/schemas/Hash"
    ///    },
    ///    "txHash": {
    ///      "$ref": "#/components/schemas/Hash"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ClosedAccountV2 {
        pub account: AccountV2,
        pub nullifier: Hash,
        #[serde(rename = "txHash")]
        pub tx_hash: Hash,
    }
    impl ClosedAccountV2 {
        pub fn builder() -> builder::ClosedAccountV2 {
            Default::default()
        }
    }
    ///`ClosedAccountWithOptionalTokenDataV2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "account"
    ///  ],
    ///  "properties": {
    ///    "account": {
    ///      "$ref": "#/components/schemas/ClosedAccountV2"
    ///    },
    ///    "optionalTokenData": {
    ///      "$ref": "#/components/schemas/TokenData"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct ClosedAccountWithOptionalTokenDataV2 {
        pub account: ClosedAccountV2,
        #[serde(
            rename = "optionalTokenData",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub optional_token_data: ::std::option::Option<TokenData>,
    }
    impl ClosedAccountWithOptionalTokenDataV2 {
        pub fn builder() -> builder::ClosedAccountWithOptionalTokenDataV2 {
            Default::default()
        }
    }
    ///`CompressedProof`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "a",
    ///    "b",
    ///    "c"
    ///  ],
    ///  "properties": {
    ///    "a": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer"
    ///      }
    ///    },
    ///    "b": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer"
    ///      }
    ///    },
    ///    "c": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CompressedProof {
        pub a: ::std::vec::Vec<i64>,
        pub b: ::std::vec::Vec<i64>,
        pub c: ::std::vec::Vec<i64>,
    }
    impl CompressedProof {
        pub fn builder() -> builder::CompressedProof {
            Default::default()
        }
    }
    ///`CompressedProofWithContext`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "compressedProof",
    ///    "leafIndices",
    ///    "leaves",
    ///    "merkleTrees",
    ///    "rootIndices",
    ///    "roots"
    ///  ],
    ///  "properties": {
    ///    "compressedProof": {
    ///      "$ref": "#/components/schemas/CompressedProof"
    ///    },
    ///    "leafIndices": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer",
    ///        "format": "uint32",
    ///        "minimum": 0.0
    ///      }
    ///    },
    ///    "leaves": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "merkleTrees": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "rootIndices": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer",
    ///        "format": "uint64",
    ///        "minimum": 0.0
    ///      }
    ///    },
    ///    "roots": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CompressedProofWithContext {
        #[serde(rename = "compressedProof")]
        pub compressed_proof: CompressedProof,
        #[serde(rename = "leafIndices")]
        pub leaf_indices: ::std::vec::Vec<u32>,
        pub leaves: ::std::vec::Vec<::std::string::String>,
        #[serde(rename = "merkleTrees")]
        pub merkle_trees: ::std::vec::Vec<::std::string::String>,
        #[serde(rename = "rootIndices")]
        pub root_indices: ::std::vec::Vec<u64>,
        pub roots: ::std::vec::Vec<::std::string::String>,
    }
    impl CompressedProofWithContext {
        pub fn builder() -> builder::CompressedProofWithContext {
            Default::default()
        }
    }
    ///`CompressedProofWithContextV2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "accounts",
    ///    "addresses"
    ///  ],
    ///  "properties": {
    ///    "accounts": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AccountProofInputs"
    ///      }
    ///    },
    ///    "addresses": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AddressProofInputs"
    ///      }
    ///    },
    ///    "compressedProof": {
    ///      "$ref": "#/components/schemas/CompressedProof"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CompressedProofWithContextV2 {
        pub accounts: ::std::vec::Vec<AccountProofInputs>,
        pub addresses: ::std::vec::Vec<AddressProofInputs>,
        #[serde(
            rename = "compressedProof",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub compressed_proof: ::std::option::Option<CompressedProof>,
    }
    impl CompressedProofWithContextV2 {
        pub fn builder() -> builder::CompressedProofWithContextV2 {
            Default::default()
        }
    }
    ///`CompressionInfoV2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "closedAccounts",
    ///    "openedAccounts"
    ///  ],
    ///  "properties": {
    ///    "closedAccounts": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ClosedAccountWithOptionalTokenDataV2"
    ///      }
    ///    },
    ///    "openedAccounts": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AccountWithOptionalTokenDataV2"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct CompressionInfoV2 {
        #[serde(rename = "closedAccounts")]
        pub closed_accounts: ::std::vec::Vec<ClosedAccountWithOptionalTokenDataV2>,
        #[serde(rename = "openedAccounts")]
        pub opened_accounts: ::std::vec::Vec<AccountWithOptionalTokenDataV2>,
    }
    impl CompressionInfoV2 {
        pub fn builder() -> builder::CompressionInfoV2 {
            Default::default()
        }
    }
    ///`Context`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "slot"
    ///  ],
    ///  "properties": {
    ///    "slot": {
    ///      "default": 100,
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": "integer",
    ///      "format": "uint64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct Context {
        pub slot: u64,
    }
    impl Context {
        pub fn builder() -> builder::Context {
            Default::default()
        }
    }
    ///`DataSlice`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "length",
    ///    "offset"
    ///  ],
    ///  "properties": {
    ///    "length": {
    ///      "type": "integer",
    ///      "minimum": 0.0
    ///    },
    ///    "offset": {
    ///      "type": "integer",
    ///      "minimum": 0.0
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct DataSlice {
        pub length: u64,
        pub offset: u64,
    }
    impl DataSlice {
        pub fn builder() -> builder::DataSlice {
            Default::default()
        }
    }
    ///`FilterSelector`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "memcmp": {
    ///      "$ref": "#/components/schemas/Memcmp"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct FilterSelector {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub memcmp: ::std::option::Option<Memcmp>,
    }
    impl ::std::default::Default for FilterSelector {
        fn default() -> Self {
            Self { memcmp: Default::default() }
        }
    }
    impl FilterSelector {
        pub fn builder() -> builder::FilterSelector {
            Default::default()
        }
    }
    ///`GetCompressedAccountProofResponseValue`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "hash",
    ///    "leafIndex",
    ///    "merkleTree",
    ///    "proof",
    ///    "root",
    ///    "rootSeq"
    ///  ],
    ///  "properties": {
    ///    "hash": {
    ///      "$ref": "#/components/schemas/Hash"
    ///    },
    ///    "leafIndex": {
    ///      "type": "integer",
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "merkleTree": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "proof": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Hash"
    ///      }
    ///    },
    ///    "root": {
    ///      "$ref": "#/components/schemas/Hash"
    ///    },
    ///    "rootSeq": {
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetCompressedAccountProofResponseValue {
        pub hash: Hash,
        #[serde(rename = "leafIndex")]
        pub leaf_index: u32,
        #[serde(rename = "merkleTree")]
        pub merkle_tree: SerializablePubkey,
        pub proof: ::std::vec::Vec<Hash>,
        pub root: Hash,
        #[serde(rename = "rootSeq")]
        pub root_seq: u64,
    }
    impl GetCompressedAccountProofResponseValue {
        pub fn builder() -> builder::GetCompressedAccountProofResponseValue {
            Default::default()
        }
    }
    ///`GetCompressedAccountProofResponseValueV2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "hash",
    ///    "leafIndex",
    ///    "proof",
    ///    "proveByIndex",
    ///    "root",
    ///    "rootSeq",
    ///    "treeContext"
    ///  ],
    ///  "properties": {
    ///    "hash": {
    ///      "$ref": "#/components/schemas/Hash"
    ///    },
    ///    "leafIndex": {
    ///      "type": "integer",
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "proof": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Hash"
    ///      }
    ///    },
    ///    "proveByIndex": {
    ///      "type": "boolean"
    ///    },
    ///    "root": {
    ///      "$ref": "#/components/schemas/Hash"
    ///    },
    ///    "rootSeq": {
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "treeContext": {
    ///      "$ref": "#/components/schemas/TreeContextInfo"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct GetCompressedAccountProofResponseValueV2 {
        pub hash: Hash,
        #[serde(rename = "leafIndex")]
        pub leaf_index: u32,
        pub proof: ::std::vec::Vec<Hash>,
        #[serde(rename = "proveByIndex")]
        pub prove_by_index: bool,
        pub root: Hash,
        #[serde(rename = "rootSeq")]
        pub root_seq: u64,
        #[serde(rename = "treeContext")]
        pub tree_context: TreeContextInfo,
    }
    impl GetCompressedAccountProofResponseValueV2 {
        pub fn builder() -> builder::GetCompressedAccountProofResponseValueV2 {
            Default::default()
        }
    }
    ///A 32-byte hash represented as a base58 string.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A 32-byte hash represented as a base58 string.",
    ///  "examples": [
    ///    "11111112cMQwSC9qirWGjZM6gLGwW69X22mqwLLGP"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    #[serde(transparent)]
    pub struct Hash(pub ::std::string::String);
    impl ::std::ops::Deref for Hash {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<Hash> for ::std::string::String {
        fn from(value: Hash) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<::std::string::String> for Hash {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }
    impl ::std::str::FromStr for Hash {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::fmt::Display for Hash {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    ///`InputQueueData`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "accountHashes",
    ///    "firstQueueIndex",
    ///    "leafIndices",
    ///    "leaves",
    ///    "leavesHashChains",
    ///    "nullifiers",
    ///    "txHashes"
    ///  ],
    ///  "properties": {
    ///    "accountHashes": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Hash"
    ///      }
    ///    },
    ///    "firstQueueIndex": {
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "leafIndices": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer",
    ///        "format": "uint64",
    ///        "minimum": 0.0
    ///      }
    ///    },
    ///    "leaves": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Hash"
    ///      }
    ///    },
    ///    "leavesHashChains": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Hash"
    ///      }
    ///    },
    ///    "nullifiers": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Hash"
    ///      }
    ///    },
    ///    "txHashes": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Hash"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct InputQueueData {
        #[serde(rename = "accountHashes")]
        pub account_hashes: ::std::vec::Vec<Hash>,
        #[serde(rename = "firstQueueIndex")]
        pub first_queue_index: u64,
        #[serde(rename = "leafIndices")]
        pub leaf_indices: ::std::vec::Vec<u64>,
        pub leaves: ::std::vec::Vec<Hash>,
        #[serde(rename = "leavesHashChains")]
        pub leaves_hash_chains: ::std::vec::Vec<Hash>,
        pub nullifiers: ::std::vec::Vec<Hash>,
        #[serde(rename = "txHashes")]
        pub tx_hashes: ::std::vec::Vec<Hash>,
    }
    impl InputQueueData {
        pub fn builder() -> builder::InputQueueData {
            Default::default()
        }
    }
    ///`Limit`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "integer",
    ///  "format": "uint64",
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct Limit(pub u64);
    impl ::std::ops::Deref for Limit {
        type Target = u64;
        fn deref(&self) -> &u64 {
            &self.0
        }
    }
    impl ::std::convert::From<Limit> for u64 {
        fn from(value: Limit) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<u64> for Limit {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }
    impl ::std::str::FromStr for Limit {
        type Err = <u64 as ::std::str::FromStr>::Err;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }
    impl ::std::convert::TryFrom<&str> for Limit {
        type Error = <u64 as ::std::str::FromStr>::Err;
        fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for Limit {
        type Error = <u64 as ::std::str::FromStr>::Err;
        fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }
    impl ::std::fmt::Display for Limit {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    ///`Memcmp`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "bytes",
    ///    "offset"
    ///  ],
    ///  "properties": {
    ///    "bytes": {
    ///      "$ref": "#/components/schemas/Base58String"
    ///    },
    ///    "offset": {
    ///      "type": "integer",
    ///      "minimum": 0.0
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct Memcmp {
        pub bytes: Base58String,
        pub offset: u64,
    }
    impl Memcmp {
        pub fn builder() -> builder::Memcmp {
            Default::default()
        }
    }
    ///`MerkleContextV2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "queue",
    ///    "tree",
    ///    "treeType"
    ///  ],
    ///  "properties": {
    ///    "cpiContext": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "nextTreeContext": {
    ///      "$ref": "#/components/schemas/TreeContextInfo"
    ///    },
    ///    "queue": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "tree": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "treeType": {
    ///      "type": "integer",
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct MerkleContextV2 {
        #[serde(
            rename = "cpiContext",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub cpi_context: ::std::option::Option<SerializablePubkey>,
        #[serde(
            rename = "nextTreeContext",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub next_tree_context: ::std::option::Option<TreeContextInfo>,
        pub queue: SerializablePubkey,
        pub tree: SerializablePubkey,
        #[serde(rename = "treeType")]
        pub tree_type: u16,
    }
    impl MerkleContextV2 {
        pub fn builder() -> builder::MerkleContextV2 {
            Default::default()
        }
    }
    ///`MerkleContextWithNewAddressProof`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "higherRangeAddress",
    ///    "lowElementLeafIndex",
    ///    "lowerRangeAddress",
    ///    "merkleTree",
    ///    "nextIndex",
    ///    "proof",
    ///    "root",
    ///    "rootSeq"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "higherRangeAddress": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "lowElementLeafIndex": {
    ///      "type": "integer",
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "lowerRangeAddress": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "merkleTree": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "nextIndex": {
    ///      "type": "integer",
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "proof": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Hash"
    ///      }
    ///    },
    ///    "root": {
    ///      "$ref": "#/components/schemas/Hash"
    ///    },
    ///    "rootSeq": {
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct MerkleContextWithNewAddressProof {
        pub address: SerializablePubkey,
        #[serde(rename = "higherRangeAddress")]
        pub higher_range_address: SerializablePubkey,
        #[serde(rename = "lowElementLeafIndex")]
        pub low_element_leaf_index: u32,
        #[serde(rename = "lowerRangeAddress")]
        pub lower_range_address: SerializablePubkey,
        #[serde(rename = "merkleTree")]
        pub merkle_tree: SerializablePubkey,
        #[serde(rename = "nextIndex")]
        pub next_index: u32,
        pub proof: ::std::vec::Vec<Hash>,
        pub root: Hash,
        #[serde(rename = "rootSeq")]
        pub root_seq: u64,
    }
    impl MerkleContextWithNewAddressProof {
        pub fn builder() -> builder::MerkleContextWithNewAddressProof {
            Default::default()
        }
    }
    ///A tree node with its encoded index and hash
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A tree node with its encoded index and hash",
    ///  "type": "object",
    ///  "required": [
    ///    "hash",
    ///    "index"
    ///  ],
    ///  "properties": {
    ///    "hash": {
    ///      "$ref": "#/components/schemas/Hash"
    ///    },
    ///    "index": {
    ///      "description": "Encoded node index: (level << 56) | position",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct Node {
        pub hash: Hash,
        ///Encoded node index: (level << 56) | position
        pub index: u64,
    }
    impl Node {
        pub fn builder() -> builder::Node {
            Default::default()
        }
    }
    ///`OutputQueueData`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "accountHashes",
    ///    "firstQueueIndex",
    ///    "leafIndices",
    ///    "leaves",
    ///    "leavesHashChains",
    ///    "nextIndex"
    ///  ],
    ///  "properties": {
    ///    "accountHashes": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Hash"
    ///      }
    ///    },
    ///    "firstQueueIndex": {
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "leafIndices": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer",
    ///        "format": "uint64",
    ///        "minimum": 0.0
    ///      }
    ///    },
    ///    "leaves": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Hash"
    ///      }
    ///    },
    ///    "leavesHashChains": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Hash"
    ///      }
    ///    },
    ///    "nextIndex": {
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct OutputQueueData {
        #[serde(rename = "accountHashes")]
        pub account_hashes: ::std::vec::Vec<Hash>,
        #[serde(rename = "firstQueueIndex")]
        pub first_queue_index: u64,
        #[serde(rename = "leafIndices")]
        pub leaf_indices: ::std::vec::Vec<u64>,
        pub leaves: ::std::vec::Vec<Hash>,
        #[serde(rename = "leavesHashChains")]
        pub leaves_hash_chains: ::std::vec::Vec<Hash>,
        #[serde(rename = "nextIndex")]
        pub next_index: u64,
    }
    impl OutputQueueData {
        pub fn builder() -> builder::OutputQueueData {
            Default::default()
        }
    }
    ///`OwnerBalance`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "balance",
    ///    "owner"
    ///  ],
    ///  "properties": {
    ///    "balance": {
    ///      "$ref": "#/components/schemas/UnsignedInteger"
    ///    },
    ///    "owner": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct OwnerBalance {
        pub balance: UnsignedInteger,
        pub owner: SerializablePubkey,
    }
    impl OwnerBalance {
        pub fn builder() -> builder::OwnerBalance {
            Default::default()
        }
    }
    ///`OwnerBalanceList`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "cursor": {
    ///      "$ref": "#/components/schemas/Base58String"
    ///    },
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/OwnerBalance"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct OwnerBalanceList {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<Base58String>,
        pub items: ::std::vec::Vec<OwnerBalance>,
    }
    impl OwnerBalanceList {
        pub fn builder() -> builder::OwnerBalanceList {
            Default::default()
        }
    }
    ///`OwnerBalancesResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/OwnerBalanceList"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct OwnerBalancesResponse {
        pub context: Context,
        pub value: OwnerBalanceList,
    }
    impl OwnerBalancesResponse {
        pub fn builder() -> builder::OwnerBalancesResponse {
            Default::default()
        }
    }
    ///`PaginatedAccountList`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "cursor": {
    ///      "$ref": "#/components/schemas/Hash"
    ///    },
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Account"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PaginatedAccountList {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<Hash>,
        pub items: ::std::vec::Vec<Account>,
    }
    impl PaginatedAccountList {
        pub fn builder() -> builder::PaginatedAccountList {
            Default::default()
        }
    }
    ///`PaginatedAccountListV2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "cursor": {
    ///      "$ref": "#/components/schemas/Hash"
    ///    },
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AccountV2"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PaginatedAccountListV2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<Hash>,
        pub items: ::std::vec::Vec<AccountV2>,
    }
    impl PaginatedAccountListV2 {
        pub fn builder() -> builder::PaginatedAccountListV2 {
            Default::default()
        }
    }
    ///`PaginatedSignatureInfoList`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "cursor": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SignatureInfo"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PaginatedSignatureInfoList {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<::std::string::String>,
        pub items: ::std::vec::Vec<SignatureInfo>,
    }
    impl PaginatedSignatureInfoList {
        pub fn builder() -> builder::PaginatedSignatureInfoList {
            Default::default()
        }
    }
    ///`PostGetAccountInterfaceBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getAccountInterface"
    ///      ]
    ///    },
    ///    "params": {
    ///      "description": "Request for getAccountInterface",
    ///      "type": "object",
    ///      "required": [
    ///        "address"
    ///      ],
    ///      "properties": {
    ///        "address": {
    ///          "$ref": "#/components/schemas/SerializablePubkey"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetAccountInterfaceBody {
        ///An ID to identify the request.
        pub id: PostGetAccountInterfaceBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetAccountInterfaceBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetAccountInterfaceBodyMethod,
        pub params: PostGetAccountInterfaceBodyParams,
    }
    impl PostGetAccountInterfaceBody {
        pub fn builder() -> builder::PostGetAccountInterfaceBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetAccountInterfaceBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetAccountInterfaceBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetAccountInterfaceBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetAccountInterfaceBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetAccountInterfaceBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetAccountInterfaceBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetAccountInterfaceBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetAccountInterfaceBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetAccountInterfaceBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetAccountInterfaceBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetAccountInterfaceBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetAccountInterfaceBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getAccountInterface"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetAccountInterfaceBodyMethod {
        #[serde(rename = "getAccountInterface")]
        GetAccountInterface,
    }
    impl ::std::fmt::Display for PostGetAccountInterfaceBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetAccountInterface => f.write_str("getAccountInterface"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetAccountInterfaceBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getAccountInterface" => Ok(Self::GetAccountInterface),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetAccountInterfaceBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetAccountInterfaceBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetAccountInterfaceBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Request for getAccountInterface
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Request for getAccountInterface",
    ///  "type": "object",
    ///  "required": [
    ///    "address"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetAccountInterfaceBodyParams {
        pub address: SerializablePubkey,
    }
    impl PostGetAccountInterfaceBodyParams {
        pub fn builder() -> builder::PostGetAccountInterfaceBodyParams {
            Default::default()
        }
    }
    ///`PostGetAccountInterfaceResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "description": "Response for getAccountInterface",
    ///      "type": "object",
    ///      "required": [
    ///        "context"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/AccountInterface"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetAccountInterfaceResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<PostGetAccountInterfaceResponseError>,
        ///An ID to identify the response.
        pub id: PostGetAccountInterfaceResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetAccountInterfaceResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<PostGetAccountInterfaceResponseResult>,
    }
    impl PostGetAccountInterfaceResponse {
        pub fn builder() -> builder::PostGetAccountInterfaceResponse {
            Default::default()
        }
    }
    ///`PostGetAccountInterfaceResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetAccountInterfaceResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetAccountInterfaceResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetAccountInterfaceResponseError {
        pub fn builder() -> builder::PostGetAccountInterfaceResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetAccountInterfaceResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetAccountInterfaceResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetAccountInterfaceResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetAccountInterfaceResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetAccountInterfaceResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetAccountInterfaceResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetAccountInterfaceResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetAccountInterfaceResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetAccountInterfaceResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetAccountInterfaceResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetAccountInterfaceResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetAccountInterfaceResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Response for getAccountInterface
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Response for getAccountInterface",
    ///  "type": "object",
    ///  "required": [
    ///    "context"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/AccountInterface"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetAccountInterfaceResponseResult {
        pub context: Context,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub value: ::std::option::Option<AccountInterface>,
    }
    impl PostGetAccountInterfaceResponseResult {
        pub fn builder() -> builder::PostGetAccountInterfaceResponseResult {
            Default::default()
        }
    }
    ///`PostGetCompressedAccountBalanceBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getCompressedAccountBalance"
    ///      ]
    ///    },
    ///    "params": {
    ///      "description": "Request for compressed account data",
    ///      "default": {
    ///        "address": null,
    ///        "hash": "11111111111111111111111111111111"
    ///      },
    ///      "examples": [
    ///        {
    ///          "address": null,
    ///          "hash": "11111111111111111111111111111111"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "properties": {
    ///        "address": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/SerializablePubkey"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "hash": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Hash"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountBalanceBody {
        ///An ID to identify the request.
        pub id: PostGetCompressedAccountBalanceBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedAccountBalanceBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetCompressedAccountBalanceBodyMethod,
        pub params: PostGetCompressedAccountBalanceBodyParams,
    }
    impl PostGetCompressedAccountBalanceBody {
        pub fn builder() -> builder::PostGetCompressedAccountBalanceBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountBalanceBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountBalanceBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountBalanceBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountBalanceBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountBalanceBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountBalanceBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountBalanceBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountBalanceBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountBalanceBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountBalanceBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountBalanceBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountBalanceBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getCompressedAccountBalance"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountBalanceBodyMethod {
        #[serde(rename = "getCompressedAccountBalance")]
        GetCompressedAccountBalance,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountBalanceBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetCompressedAccountBalance => {
                    f.write_str("getCompressedAccountBalance")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountBalanceBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getCompressedAccountBalance" => Ok(Self::GetCompressedAccountBalance),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountBalanceBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountBalanceBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountBalanceBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Request for compressed account data
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Request for compressed account data",
    ///  "default": {
    ///    "address": null,
    ///    "hash": "11111111111111111111111111111111"
    ///  },
    ///  "examples": [
    ///    {
    ///      "address": null,
    ///      "hash": "11111111111111111111111111111111"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "address": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/SerializablePubkey"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "hash": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Hash"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedAccountBalanceBodyParams {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<SerializablePubkey>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub hash: ::std::option::Option<Hash>,
    }
    impl ::std::default::Default for PostGetCompressedAccountBalanceBodyParams {
        fn default() -> Self {
            PostGetCompressedAccountBalanceBodyParams {
                address: ::std::option::Option::None,
                hash: ::std::option::Option::Some(
                    Hash("11111111111111111111111111111111".to_string()),
                ),
            }
        }
    }
    impl PostGetCompressedAccountBalanceBodyParams {
        pub fn builder() -> builder::PostGetCompressedAccountBalanceBodyParams {
            Default::default()
        }
    }
    ///`PostGetCompressedAccountBalanceResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/UnsignedInteger"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountBalanceResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<PostGetCompressedAccountBalanceResponseError>,
        ///An ID to identify the response.
        pub id: PostGetCompressedAccountBalanceResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedAccountBalanceResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<PostGetCompressedAccountBalanceResponseResult>,
    }
    impl PostGetCompressedAccountBalanceResponse {
        pub fn builder() -> builder::PostGetCompressedAccountBalanceResponse {
            Default::default()
        }
    }
    ///`PostGetCompressedAccountBalanceResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountBalanceResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetCompressedAccountBalanceResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetCompressedAccountBalanceResponseError {
        pub fn builder() -> builder::PostGetCompressedAccountBalanceResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountBalanceResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountBalanceResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountBalanceResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountBalanceResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountBalanceResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountBalanceResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountBalanceResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountBalanceResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountBalanceResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedAccountBalanceResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountBalanceResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountBalanceResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedAccountBalanceResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/UnsignedInteger"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedAccountBalanceResponseResult {
        pub context: Context,
        pub value: UnsignedInteger,
    }
    impl PostGetCompressedAccountBalanceResponseResult {
        pub fn builder() -> builder::PostGetCompressedAccountBalanceResponseResult {
            Default::default()
        }
    }
    ///`PostGetCompressedAccountBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getCompressedAccount"
    ///      ]
    ///    },
    ///    "params": {
    ///      "description": "Request for compressed account data",
    ///      "default": {
    ///        "address": null,
    ///        "hash": "11111111111111111111111111111111"
    ///      },
    ///      "examples": [
    ///        {
    ///          "address": null,
    ///          "hash": "11111111111111111111111111111111"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "properties": {
    ///        "address": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/SerializablePubkey"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "hash": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Hash"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountBody {
        ///An ID to identify the request.
        pub id: PostGetCompressedAccountBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedAccountBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetCompressedAccountBodyMethod,
        pub params: PostGetCompressedAccountBodyParams,
    }
    impl PostGetCompressedAccountBody {
        pub fn builder() -> builder::PostGetCompressedAccountBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getCompressedAccount"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountBodyMethod {
        #[serde(rename = "getCompressedAccount")]
        GetCompressedAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetCompressedAccount => f.write_str("getCompressedAccount"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getCompressedAccount" => Ok(Self::GetCompressedAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Request for compressed account data
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Request for compressed account data",
    ///  "default": {
    ///    "address": null,
    ///    "hash": "11111111111111111111111111111111"
    ///  },
    ///  "examples": [
    ///    {
    ///      "address": null,
    ///      "hash": "11111111111111111111111111111111"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "address": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/SerializablePubkey"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "hash": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Hash"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedAccountBodyParams {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<SerializablePubkey>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub hash: ::std::option::Option<Hash>,
    }
    impl ::std::default::Default for PostGetCompressedAccountBodyParams {
        fn default() -> Self {
            PostGetCompressedAccountBodyParams {
                address: ::std::option::Option::None,
                hash: ::std::option::Option::Some(
                    Hash("11111111111111111111111111111111".to_string()),
                ),
            }
        }
    }
    impl PostGetCompressedAccountBodyParams {
        pub fn builder() -> builder::PostGetCompressedAccountBodyParams {
            Default::default()
        }
    }
    ///`PostGetCompressedAccountProofBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getCompressedAccountProof"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "hash"
    ///      ],
    ///      "properties": {
    ///        "hash": {
    ///          "$ref": "#/components/schemas/Hash"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountProofBody {
        ///An ID to identify the request.
        pub id: PostGetCompressedAccountProofBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedAccountProofBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetCompressedAccountProofBodyMethod,
        pub params: PostGetCompressedAccountProofBodyParams,
    }
    impl PostGetCompressedAccountProofBody {
        pub fn builder() -> builder::PostGetCompressedAccountProofBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountProofBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountProofBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountProofBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountProofBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountProofBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountProofBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountProofBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountProofBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountProofBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountProofBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountProofBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountProofBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getCompressedAccountProof"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountProofBodyMethod {
        #[serde(rename = "getCompressedAccountProof")]
        GetCompressedAccountProof,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountProofBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetCompressedAccountProof => {
                    f.write_str("getCompressedAccountProof")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountProofBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getCompressedAccountProof" => Ok(Self::GetCompressedAccountProof),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountProofBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountProofBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountProofBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedAccountProofBodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "hash"
    ///  ],
    ///  "properties": {
    ///    "hash": {
    ///      "$ref": "#/components/schemas/Hash"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountProofBodyParams {
        pub hash: Hash,
    }
    impl PostGetCompressedAccountProofBodyParams {
        pub fn builder() -> builder::PostGetCompressedAccountProofBodyParams {
            Default::default()
        }
    }
    ///`PostGetCompressedAccountProofResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/GetCompressedAccountProofResponseValue"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountProofResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<PostGetCompressedAccountProofResponseError>,
        ///An ID to identify the response.
        pub id: PostGetCompressedAccountProofResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedAccountProofResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<PostGetCompressedAccountProofResponseResult>,
    }
    impl PostGetCompressedAccountProofResponse {
        pub fn builder() -> builder::PostGetCompressedAccountProofResponse {
            Default::default()
        }
    }
    ///`PostGetCompressedAccountProofResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountProofResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetCompressedAccountProofResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetCompressedAccountProofResponseError {
        pub fn builder() -> builder::PostGetCompressedAccountProofResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountProofResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountProofResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountProofResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountProofResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountProofResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountProofResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountProofResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountProofResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountProofResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountProofResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountProofResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountProofResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedAccountProofResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/GetCompressedAccountProofResponseValue"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedAccountProofResponseResult {
        pub context: Context,
        pub value: GetCompressedAccountProofResponseValue,
    }
    impl PostGetCompressedAccountProofResponseResult {
        pub fn builder() -> builder::PostGetCompressedAccountProofResponseResult {
            Default::default()
        }
    }
    ///`PostGetCompressedAccountProofV2Body`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getCompressedAccountProofV2"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "hash"
    ///      ],
    ///      "properties": {
    ///        "hash": {
    ///          "$ref": "#/components/schemas/Hash"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountProofV2Body {
        ///An ID to identify the request.
        pub id: PostGetCompressedAccountProofV2BodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedAccountProofV2BodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetCompressedAccountProofV2BodyMethod,
        pub params: PostGetCompressedAccountProofV2BodyParams,
    }
    impl PostGetCompressedAccountProofV2Body {
        pub fn builder() -> builder::PostGetCompressedAccountProofV2Body {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountProofV2BodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountProofV2BodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountProofV2BodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountProofV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountProofV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountProofV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountProofV2BodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountProofV2BodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountProofV2BodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountProofV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountProofV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountProofV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getCompressedAccountProofV2"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountProofV2BodyMethod {
        #[serde(rename = "getCompressedAccountProofV2")]
        GetCompressedAccountProofV2,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountProofV2BodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetCompressedAccountProofV2 => {
                    f.write_str("getCompressedAccountProofV2")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountProofV2BodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getCompressedAccountProofV2" => Ok(Self::GetCompressedAccountProofV2),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountProofV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountProofV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountProofV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedAccountProofV2BodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "hash"
    ///  ],
    ///  "properties": {
    ///    "hash": {
    ///      "$ref": "#/components/schemas/Hash"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountProofV2BodyParams {
        pub hash: Hash,
    }
    impl PostGetCompressedAccountProofV2BodyParams {
        pub fn builder() -> builder::PostGetCompressedAccountProofV2BodyParams {
            Default::default()
        }
    }
    ///`PostGetCompressedAccountProofV2Response`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/GetCompressedAccountProofResponseValueV2"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountProofV2Response {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<PostGetCompressedAccountProofV2ResponseError>,
        ///An ID to identify the response.
        pub id: PostGetCompressedAccountProofV2ResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedAccountProofV2ResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<PostGetCompressedAccountProofV2ResponseResult>,
    }
    impl PostGetCompressedAccountProofV2Response {
        pub fn builder() -> builder::PostGetCompressedAccountProofV2Response {
            Default::default()
        }
    }
    ///`PostGetCompressedAccountProofV2ResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountProofV2ResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetCompressedAccountProofV2ResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetCompressedAccountProofV2ResponseError {
        pub fn builder() -> builder::PostGetCompressedAccountProofV2ResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountProofV2ResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountProofV2ResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountProofV2ResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountProofV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountProofV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountProofV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountProofV2ResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountProofV2ResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountProofV2ResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedAccountProofV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountProofV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountProofV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedAccountProofV2ResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/GetCompressedAccountProofResponseValueV2"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedAccountProofV2ResponseResult {
        pub context: Context,
        pub value: GetCompressedAccountProofResponseValueV2,
    }
    impl PostGetCompressedAccountProofV2ResponseResult {
        pub fn builder() -> builder::PostGetCompressedAccountProofV2ResponseResult {
            Default::default()
        }
    }
    ///`PostGetCompressedAccountResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Account"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<PostGetCompressedAccountResponseError>,
        ///An ID to identify the response.
        pub id: PostGetCompressedAccountResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedAccountResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<PostGetCompressedAccountResponseResult>,
    }
    impl PostGetCompressedAccountResponse {
        pub fn builder() -> builder::PostGetCompressedAccountResponse {
            Default::default()
        }
    }
    ///`PostGetCompressedAccountResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetCompressedAccountResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetCompressedAccountResponseError {
        pub fn builder() -> builder::PostGetCompressedAccountResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedAccountResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/Account"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedAccountResponseResult {
        pub context: Context,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub value: ::std::option::Option<Account>,
    }
    impl PostGetCompressedAccountResponseResult {
        pub fn builder() -> builder::PostGetCompressedAccountResponseResult {
            Default::default()
        }
    }
    ///`PostGetCompressedAccountV2Body`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getCompressedAccountV2"
    ///      ]
    ///    },
    ///    "params": {
    ///      "description": "Request for compressed account data",
    ///      "default": {
    ///        "address": null,
    ///        "hash": "11111111111111111111111111111111"
    ///      },
    ///      "examples": [
    ///        {
    ///          "address": null,
    ///          "hash": "11111111111111111111111111111111"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "properties": {
    ///        "address": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/SerializablePubkey"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "hash": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Hash"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountV2Body {
        ///An ID to identify the request.
        pub id: PostGetCompressedAccountV2BodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedAccountV2BodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetCompressedAccountV2BodyMethod,
        pub params: PostGetCompressedAccountV2BodyParams,
    }
    impl PostGetCompressedAccountV2Body {
        pub fn builder() -> builder::PostGetCompressedAccountV2Body {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountV2BodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountV2BodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountV2BodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountV2BodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountV2BodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountV2BodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getCompressedAccountV2"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountV2BodyMethod {
        #[serde(rename = "getCompressedAccountV2")]
        GetCompressedAccountV2,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountV2BodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetCompressedAccountV2 => f.write_str("getCompressedAccountV2"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountV2BodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getCompressedAccountV2" => Ok(Self::GetCompressedAccountV2),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Request for compressed account data
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Request for compressed account data",
    ///  "default": {
    ///    "address": null,
    ///    "hash": "11111111111111111111111111111111"
    ///  },
    ///  "examples": [
    ///    {
    ///      "address": null,
    ///      "hash": "11111111111111111111111111111111"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "address": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/SerializablePubkey"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "hash": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Hash"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedAccountV2BodyParams {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<SerializablePubkey>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub hash: ::std::option::Option<Hash>,
    }
    impl ::std::default::Default for PostGetCompressedAccountV2BodyParams {
        fn default() -> Self {
            PostGetCompressedAccountV2BodyParams {
                address: ::std::option::Option::None,
                hash: ::std::option::Option::Some(
                    Hash("11111111111111111111111111111111".to_string()),
                ),
            }
        }
    }
    impl PostGetCompressedAccountV2BodyParams {
        pub fn builder() -> builder::PostGetCompressedAccountV2BodyParams {
            Default::default()
        }
    }
    ///`PostGetCompressedAccountV2Response`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/AccountV2"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountV2Response {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<PostGetCompressedAccountV2ResponseError>,
        ///An ID to identify the response.
        pub id: PostGetCompressedAccountV2ResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedAccountV2ResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<PostGetCompressedAccountV2ResponseResult>,
    }
    impl PostGetCompressedAccountV2Response {
        pub fn builder() -> builder::PostGetCompressedAccountV2Response {
            Default::default()
        }
    }
    ///`PostGetCompressedAccountV2ResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountV2ResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetCompressedAccountV2ResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetCompressedAccountV2ResponseError {
        pub fn builder() -> builder::PostGetCompressedAccountV2ResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountV2ResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountV2ResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountV2ResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountV2ResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountV2ResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountV2ResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedAccountV2ResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/AccountV2"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedAccountV2ResponseResult {
        pub context: Context,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub value: ::std::option::Option<AccountV2>,
    }
    impl PostGetCompressedAccountV2ResponseResult {
        pub fn builder() -> builder::PostGetCompressedAccountV2ResponseResult {
            Default::default()
        }
    }
    ///`PostGetCompressedAccountsByOwnerBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getCompressedAccountsByOwner"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "owner"
    ///      ],
    ///      "properties": {
    ///        "cursor": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Hash"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "dataSlice": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/DataSlice"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "filters": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/FilterSelector"
    ///          }
    ///        },
    ///        "limit": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Limit"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "owner": {
    ///          "$ref": "#/components/schemas/SerializablePubkey"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountsByOwnerBody {
        ///An ID to identify the request.
        pub id: PostGetCompressedAccountsByOwnerBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedAccountsByOwnerBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetCompressedAccountsByOwnerBodyMethod,
        pub params: PostGetCompressedAccountsByOwnerBodyParams,
    }
    impl PostGetCompressedAccountsByOwnerBody {
        pub fn builder() -> builder::PostGetCompressedAccountsByOwnerBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountsByOwnerBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountsByOwnerBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountsByOwnerBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountsByOwnerBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountsByOwnerBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountsByOwnerBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountsByOwnerBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountsByOwnerBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountsByOwnerBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountsByOwnerBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountsByOwnerBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountsByOwnerBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getCompressedAccountsByOwner"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountsByOwnerBodyMethod {
        #[serde(rename = "getCompressedAccountsByOwner")]
        GetCompressedAccountsByOwner,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountsByOwnerBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetCompressedAccountsByOwner => {
                    f.write_str("getCompressedAccountsByOwner")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountsByOwnerBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getCompressedAccountsByOwner" => Ok(Self::GetCompressedAccountsByOwner),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountsByOwnerBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountsByOwnerBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountsByOwnerBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedAccountsByOwnerBodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "owner"
    ///  ],
    ///  "properties": {
    ///    "cursor": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Hash"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "dataSlice": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/DataSlice"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "filters": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/FilterSelector"
    ///      }
    ///    },
    ///    "limit": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Limit"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "owner": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedAccountsByOwnerBodyParams {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<Hash>,
        #[serde(
            rename = "dataSlice",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub data_slice: ::std::option::Option<DataSlice>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub filters: ::std::vec::Vec<FilterSelector>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub limit: ::std::option::Option<Limit>,
        pub owner: SerializablePubkey,
    }
    impl PostGetCompressedAccountsByOwnerBodyParams {
        pub fn builder() -> builder::PostGetCompressedAccountsByOwnerBodyParams {
            Default::default()
        }
    }
    ///`PostGetCompressedAccountsByOwnerResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/PaginatedAccountList"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountsByOwnerResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<PostGetCompressedAccountsByOwnerResponseError>,
        ///An ID to identify the response.
        pub id: PostGetCompressedAccountsByOwnerResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedAccountsByOwnerResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetCompressedAccountsByOwnerResponseResult,
        >,
    }
    impl PostGetCompressedAccountsByOwnerResponse {
        pub fn builder() -> builder::PostGetCompressedAccountsByOwnerResponse {
            Default::default()
        }
    }
    ///`PostGetCompressedAccountsByOwnerResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountsByOwnerResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetCompressedAccountsByOwnerResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetCompressedAccountsByOwnerResponseError {
        pub fn builder() -> builder::PostGetCompressedAccountsByOwnerResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountsByOwnerResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountsByOwnerResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountsByOwnerResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountsByOwnerResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountsByOwnerResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountsByOwnerResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountsByOwnerResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountsByOwnerResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountsByOwnerResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedAccountsByOwnerResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountsByOwnerResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountsByOwnerResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedAccountsByOwnerResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/PaginatedAccountList"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedAccountsByOwnerResponseResult {
        pub context: Context,
        pub value: PaginatedAccountList,
    }
    impl PostGetCompressedAccountsByOwnerResponseResult {
        pub fn builder() -> builder::PostGetCompressedAccountsByOwnerResponseResult {
            Default::default()
        }
    }
    ///`PostGetCompressedAccountsByOwnerV2Body`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getCompressedAccountsByOwnerV2"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "owner"
    ///      ],
    ///      "properties": {
    ///        "cursor": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Hash"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "dataSlice": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/DataSlice"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "filters": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/FilterSelector"
    ///          }
    ///        },
    ///        "limit": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Limit"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "owner": {
    ///          "$ref": "#/components/schemas/SerializablePubkey"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountsByOwnerV2Body {
        ///An ID to identify the request.
        pub id: PostGetCompressedAccountsByOwnerV2BodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedAccountsByOwnerV2BodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetCompressedAccountsByOwnerV2BodyMethod,
        pub params: PostGetCompressedAccountsByOwnerV2BodyParams,
    }
    impl PostGetCompressedAccountsByOwnerV2Body {
        pub fn builder() -> builder::PostGetCompressedAccountsByOwnerV2Body {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountsByOwnerV2BodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountsByOwnerV2BodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountsByOwnerV2BodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountsByOwnerV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountsByOwnerV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountsByOwnerV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountsByOwnerV2BodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountsByOwnerV2BodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountsByOwnerV2BodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedAccountsByOwnerV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountsByOwnerV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountsByOwnerV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getCompressedAccountsByOwnerV2"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountsByOwnerV2BodyMethod {
        #[serde(rename = "getCompressedAccountsByOwnerV2")]
        GetCompressedAccountsByOwnerV2,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountsByOwnerV2BodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetCompressedAccountsByOwnerV2 => {
                    f.write_str("getCompressedAccountsByOwnerV2")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountsByOwnerV2BodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getCompressedAccountsByOwnerV2" => {
                    Ok(Self::GetCompressedAccountsByOwnerV2)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountsByOwnerV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountsByOwnerV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountsByOwnerV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedAccountsByOwnerV2BodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "owner"
    ///  ],
    ///  "properties": {
    ///    "cursor": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Hash"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "dataSlice": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/DataSlice"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "filters": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/FilterSelector"
    ///      }
    ///    },
    ///    "limit": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Limit"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "owner": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedAccountsByOwnerV2BodyParams {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<Hash>,
        #[serde(
            rename = "dataSlice",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub data_slice: ::std::option::Option<DataSlice>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub filters: ::std::vec::Vec<FilterSelector>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub limit: ::std::option::Option<Limit>,
        pub owner: SerializablePubkey,
    }
    impl PostGetCompressedAccountsByOwnerV2BodyParams {
        pub fn builder() -> builder::PostGetCompressedAccountsByOwnerV2BodyParams {
            Default::default()
        }
    }
    ///`PostGetCompressedAccountsByOwnerV2Response`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/PaginatedAccountListV2"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountsByOwnerV2Response {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<
            PostGetCompressedAccountsByOwnerV2ResponseError,
        >,
        ///An ID to identify the response.
        pub id: PostGetCompressedAccountsByOwnerV2ResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedAccountsByOwnerV2ResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetCompressedAccountsByOwnerV2ResponseResult,
        >,
    }
    impl PostGetCompressedAccountsByOwnerV2Response {
        pub fn builder() -> builder::PostGetCompressedAccountsByOwnerV2Response {
            Default::default()
        }
    }
    ///`PostGetCompressedAccountsByOwnerV2ResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedAccountsByOwnerV2ResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetCompressedAccountsByOwnerV2ResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetCompressedAccountsByOwnerV2ResponseError {
        pub fn builder() -> builder::PostGetCompressedAccountsByOwnerV2ResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountsByOwnerV2ResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountsByOwnerV2ResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountsByOwnerV2ResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedAccountsByOwnerV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountsByOwnerV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountsByOwnerV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedAccountsByOwnerV2ResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedAccountsByOwnerV2ResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedAccountsByOwnerV2ResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedAccountsByOwnerV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedAccountsByOwnerV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedAccountsByOwnerV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedAccountsByOwnerV2ResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/PaginatedAccountListV2"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedAccountsByOwnerV2ResponseResult {
        pub context: Context,
        pub value: PaginatedAccountListV2,
    }
    impl PostGetCompressedAccountsByOwnerV2ResponseResult {
        pub fn builder() -> builder::PostGetCompressedAccountsByOwnerV2ResponseResult {
            Default::default()
        }
    }
    ///`PostGetCompressedBalanceByOwnerBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getCompressedBalanceByOwner"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "owner"
    ///      ],
    ///      "properties": {
    ///        "owner": {
    ///          "$ref": "#/components/schemas/SerializablePubkey"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedBalanceByOwnerBody {
        ///An ID to identify the request.
        pub id: PostGetCompressedBalanceByOwnerBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedBalanceByOwnerBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetCompressedBalanceByOwnerBodyMethod,
        pub params: PostGetCompressedBalanceByOwnerBodyParams,
    }
    impl PostGetCompressedBalanceByOwnerBody {
        pub fn builder() -> builder::PostGetCompressedBalanceByOwnerBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedBalanceByOwnerBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedBalanceByOwnerBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedBalanceByOwnerBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedBalanceByOwnerBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedBalanceByOwnerBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedBalanceByOwnerBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedBalanceByOwnerBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedBalanceByOwnerBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedBalanceByOwnerBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedBalanceByOwnerBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedBalanceByOwnerBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedBalanceByOwnerBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getCompressedBalanceByOwner"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedBalanceByOwnerBodyMethod {
        #[serde(rename = "getCompressedBalanceByOwner")]
        GetCompressedBalanceByOwner,
    }
    impl ::std::fmt::Display for PostGetCompressedBalanceByOwnerBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetCompressedBalanceByOwner => {
                    f.write_str("getCompressedBalanceByOwner")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedBalanceByOwnerBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getCompressedBalanceByOwner" => Ok(Self::GetCompressedBalanceByOwner),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedBalanceByOwnerBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedBalanceByOwnerBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedBalanceByOwnerBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedBalanceByOwnerBodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "owner"
    ///  ],
    ///  "properties": {
    ///    "owner": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedBalanceByOwnerBodyParams {
        pub owner: SerializablePubkey,
    }
    impl PostGetCompressedBalanceByOwnerBodyParams {
        pub fn builder() -> builder::PostGetCompressedBalanceByOwnerBodyParams {
            Default::default()
        }
    }
    ///`PostGetCompressedBalanceByOwnerResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/UnsignedInteger"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedBalanceByOwnerResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<PostGetCompressedBalanceByOwnerResponseError>,
        ///An ID to identify the response.
        pub id: PostGetCompressedBalanceByOwnerResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedBalanceByOwnerResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<PostGetCompressedBalanceByOwnerResponseResult>,
    }
    impl PostGetCompressedBalanceByOwnerResponse {
        pub fn builder() -> builder::PostGetCompressedBalanceByOwnerResponse {
            Default::default()
        }
    }
    ///`PostGetCompressedBalanceByOwnerResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedBalanceByOwnerResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetCompressedBalanceByOwnerResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetCompressedBalanceByOwnerResponseError {
        pub fn builder() -> builder::PostGetCompressedBalanceByOwnerResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedBalanceByOwnerResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedBalanceByOwnerResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedBalanceByOwnerResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedBalanceByOwnerResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedBalanceByOwnerResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedBalanceByOwnerResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedBalanceByOwnerResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedBalanceByOwnerResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedBalanceByOwnerResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedBalanceByOwnerResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedBalanceByOwnerResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedBalanceByOwnerResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedBalanceByOwnerResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/UnsignedInteger"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedBalanceByOwnerResponseResult {
        pub context: Context,
        pub value: UnsignedInteger,
    }
    impl PostGetCompressedBalanceByOwnerResponseResult {
        pub fn builder() -> builder::PostGetCompressedBalanceByOwnerResponseResult {
            Default::default()
        }
    }
    ///`PostGetCompressedMintTokenHoldersBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getCompressedMintTokenHolders"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "mint"
    ///      ],
    ///      "properties": {
    ///        "cursor": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Base58String"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "limit": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Limit"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "mint": {
    ///          "$ref": "#/components/schemas/SerializablePubkey"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedMintTokenHoldersBody {
        ///An ID to identify the request.
        pub id: PostGetCompressedMintTokenHoldersBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedMintTokenHoldersBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetCompressedMintTokenHoldersBodyMethod,
        pub params: PostGetCompressedMintTokenHoldersBodyParams,
    }
    impl PostGetCompressedMintTokenHoldersBody {
        pub fn builder() -> builder::PostGetCompressedMintTokenHoldersBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedMintTokenHoldersBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedMintTokenHoldersBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedMintTokenHoldersBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedMintTokenHoldersBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedMintTokenHoldersBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedMintTokenHoldersBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedMintTokenHoldersBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedMintTokenHoldersBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedMintTokenHoldersBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedMintTokenHoldersBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedMintTokenHoldersBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedMintTokenHoldersBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getCompressedMintTokenHolders"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedMintTokenHoldersBodyMethod {
        #[serde(rename = "getCompressedMintTokenHolders")]
        GetCompressedMintTokenHolders,
    }
    impl ::std::fmt::Display for PostGetCompressedMintTokenHoldersBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetCompressedMintTokenHolders => {
                    f.write_str("getCompressedMintTokenHolders")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedMintTokenHoldersBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getCompressedMintTokenHolders" => {
                    Ok(Self::GetCompressedMintTokenHolders)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedMintTokenHoldersBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedMintTokenHoldersBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedMintTokenHoldersBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedMintTokenHoldersBodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "mint"
    ///  ],
    ///  "properties": {
    ///    "cursor": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Base58String"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "limit": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Limit"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "mint": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedMintTokenHoldersBodyParams {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<Base58String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub limit: ::std::option::Option<Limit>,
        pub mint: SerializablePubkey,
    }
    impl PostGetCompressedMintTokenHoldersBodyParams {
        pub fn builder() -> builder::PostGetCompressedMintTokenHoldersBodyParams {
            Default::default()
        }
    }
    ///`PostGetCompressedMintTokenHoldersResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/OwnerBalanceList"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedMintTokenHoldersResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<PostGetCompressedMintTokenHoldersResponseError>,
        ///An ID to identify the response.
        pub id: PostGetCompressedMintTokenHoldersResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedMintTokenHoldersResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetCompressedMintTokenHoldersResponseResult,
        >,
    }
    impl PostGetCompressedMintTokenHoldersResponse {
        pub fn builder() -> builder::PostGetCompressedMintTokenHoldersResponse {
            Default::default()
        }
    }
    ///`PostGetCompressedMintTokenHoldersResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedMintTokenHoldersResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetCompressedMintTokenHoldersResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetCompressedMintTokenHoldersResponseError {
        pub fn builder() -> builder::PostGetCompressedMintTokenHoldersResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedMintTokenHoldersResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedMintTokenHoldersResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedMintTokenHoldersResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedMintTokenHoldersResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedMintTokenHoldersResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedMintTokenHoldersResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedMintTokenHoldersResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedMintTokenHoldersResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedMintTokenHoldersResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedMintTokenHoldersResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedMintTokenHoldersResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedMintTokenHoldersResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedMintTokenHoldersResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/OwnerBalanceList"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedMintTokenHoldersResponseResult {
        pub context: Context,
        pub value: OwnerBalanceList,
    }
    impl PostGetCompressedMintTokenHoldersResponseResult {
        pub fn builder() -> builder::PostGetCompressedMintTokenHoldersResponseResult {
            Default::default()
        }
    }
    ///`PostGetCompressedTokenAccountBalanceBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getCompressedTokenAccountBalance"
    ///      ]
    ///    },
    ///    "params": {
    ///      "description": "Request for compressed account data",
    ///      "default": {
    ///        "address": null,
    ///        "hash": "11111111111111111111111111111111"
    ///      },
    ///      "examples": [
    ///        {
    ///          "address": null,
    ///          "hash": "11111111111111111111111111111111"
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "properties": {
    ///        "address": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/SerializablePubkey"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "hash": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Hash"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedTokenAccountBalanceBody {
        ///An ID to identify the request.
        pub id: PostGetCompressedTokenAccountBalanceBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedTokenAccountBalanceBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetCompressedTokenAccountBalanceBodyMethod,
        pub params: PostGetCompressedTokenAccountBalanceBodyParams,
    }
    impl PostGetCompressedTokenAccountBalanceBody {
        pub fn builder() -> builder::PostGetCompressedTokenAccountBalanceBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountBalanceBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountBalanceBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountBalanceBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedTokenAccountBalanceBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountBalanceBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountBalanceBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountBalanceBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountBalanceBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountBalanceBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountBalanceBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountBalanceBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountBalanceBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getCompressedTokenAccountBalance"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountBalanceBodyMethod {
        #[serde(rename = "getCompressedTokenAccountBalance")]
        GetCompressedTokenAccountBalance,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountBalanceBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetCompressedTokenAccountBalance => {
                    f.write_str("getCompressedTokenAccountBalance")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountBalanceBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getCompressedTokenAccountBalance" => {
                    Ok(Self::GetCompressedTokenAccountBalance)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountBalanceBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountBalanceBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountBalanceBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Request for compressed account data
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Request for compressed account data",
    ///  "default": {
    ///    "address": null,
    ///    "hash": "11111111111111111111111111111111"
    ///  },
    ///  "examples": [
    ///    {
    ///      "address": null,
    ///      "hash": "11111111111111111111111111111111"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "address": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/SerializablePubkey"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "hash": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Hash"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedTokenAccountBalanceBodyParams {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<SerializablePubkey>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub hash: ::std::option::Option<Hash>,
    }
    impl ::std::default::Default for PostGetCompressedTokenAccountBalanceBodyParams {
        fn default() -> Self {
            PostGetCompressedTokenAccountBalanceBodyParams {
                address: ::std::option::Option::None,
                hash: ::std::option::Option::Some(
                    Hash("11111111111111111111111111111111".to_string()),
                ),
            }
        }
    }
    impl PostGetCompressedTokenAccountBalanceBodyParams {
        pub fn builder() -> builder::PostGetCompressedTokenAccountBalanceBodyParams {
            Default::default()
        }
    }
    ///`PostGetCompressedTokenAccountBalanceResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/TokenAccountBalance"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedTokenAccountBalanceResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<
            PostGetCompressedTokenAccountBalanceResponseError,
        >,
        ///An ID to identify the response.
        pub id: PostGetCompressedTokenAccountBalanceResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedTokenAccountBalanceResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetCompressedTokenAccountBalanceResponseResult,
        >,
    }
    impl PostGetCompressedTokenAccountBalanceResponse {
        pub fn builder() -> builder::PostGetCompressedTokenAccountBalanceResponse {
            Default::default()
        }
    }
    ///`PostGetCompressedTokenAccountBalanceResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedTokenAccountBalanceResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetCompressedTokenAccountBalanceResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetCompressedTokenAccountBalanceResponseError {
        pub fn builder() -> builder::PostGetCompressedTokenAccountBalanceResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountBalanceResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountBalanceResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountBalanceResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountBalanceResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountBalanceResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountBalanceResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountBalanceResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountBalanceResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountBalanceResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountBalanceResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountBalanceResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountBalanceResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedTokenAccountBalanceResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/TokenAccountBalance"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedTokenAccountBalanceResponseResult {
        pub context: Context,
        pub value: TokenAccountBalance,
    }
    impl PostGetCompressedTokenAccountBalanceResponseResult {
        pub fn builder() -> builder::PostGetCompressedTokenAccountBalanceResponseResult {
            Default::default()
        }
    }
    ///`PostGetCompressedTokenAccountsByDelegateBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getCompressedTokenAccountsByDelegate"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "delegate"
    ///      ],
    ///      "properties": {
    ///        "cursor": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Base58String"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "delegate": {
    ///          "$ref": "#/components/schemas/SerializablePubkey"
    ///        },
    ///        "limit": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Limit"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "mint": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/SerializablePubkey"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedTokenAccountsByDelegateBody {
        ///An ID to identify the request.
        pub id: PostGetCompressedTokenAccountsByDelegateBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedTokenAccountsByDelegateBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetCompressedTokenAccountsByDelegateBodyMethod,
        pub params: PostGetCompressedTokenAccountsByDelegateBodyParams,
    }
    impl PostGetCompressedTokenAccountsByDelegateBody {
        pub fn builder() -> builder::PostGetCompressedTokenAccountsByDelegateBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountsByDelegateBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountsByDelegateBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountsByDelegateBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountsByDelegateBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountsByDelegateBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountsByDelegateBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountsByDelegateBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountsByDelegateBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountsByDelegateBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountsByDelegateBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountsByDelegateBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountsByDelegateBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getCompressedTokenAccountsByDelegate"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountsByDelegateBodyMethod {
        #[serde(rename = "getCompressedTokenAccountsByDelegate")]
        GetCompressedTokenAccountsByDelegate,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountsByDelegateBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetCompressedTokenAccountsByDelegate => {
                    f.write_str("getCompressedTokenAccountsByDelegate")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountsByDelegateBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getCompressedTokenAccountsByDelegate" => {
                    Ok(Self::GetCompressedTokenAccountsByDelegate)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountsByDelegateBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountsByDelegateBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountsByDelegateBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedTokenAccountsByDelegateBodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "delegate"
    ///  ],
    ///  "properties": {
    ///    "cursor": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Base58String"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "delegate": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "limit": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Limit"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "mint": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/SerializablePubkey"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedTokenAccountsByDelegateBodyParams {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<Base58String>,
        pub delegate: SerializablePubkey,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub limit: ::std::option::Option<Limit>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mint: ::std::option::Option<SerializablePubkey>,
    }
    impl PostGetCompressedTokenAccountsByDelegateBodyParams {
        pub fn builder() -> builder::PostGetCompressedTokenAccountsByDelegateBodyParams {
            Default::default()
        }
    }
    ///`PostGetCompressedTokenAccountsByDelegateResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/TokenAccountList"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedTokenAccountsByDelegateResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<
            PostGetCompressedTokenAccountsByDelegateResponseError,
        >,
        ///An ID to identify the response.
        pub id: PostGetCompressedTokenAccountsByDelegateResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedTokenAccountsByDelegateResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetCompressedTokenAccountsByDelegateResponseResult,
        >,
    }
    impl PostGetCompressedTokenAccountsByDelegateResponse {
        pub fn builder() -> builder::PostGetCompressedTokenAccountsByDelegateResponse {
            Default::default()
        }
    }
    ///`PostGetCompressedTokenAccountsByDelegateResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedTokenAccountsByDelegateResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default
    for PostGetCompressedTokenAccountsByDelegateResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetCompressedTokenAccountsByDelegateResponseError {
        pub fn builder() -> builder::PostGetCompressedTokenAccountsByDelegateResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountsByDelegateResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountsByDelegateResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountsByDelegateResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountsByDelegateResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountsByDelegateResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountsByDelegateResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountsByDelegateResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display
    for PostGetCompressedTokenAccountsByDelegateResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr
    for PostGetCompressedTokenAccountsByDelegateResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountsByDelegateResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountsByDelegateResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountsByDelegateResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedTokenAccountsByDelegateResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/TokenAccountList"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedTokenAccountsByDelegateResponseResult {
        pub context: Context,
        pub value: TokenAccountList,
    }
    impl PostGetCompressedTokenAccountsByDelegateResponseResult {
        pub fn builder() -> builder::PostGetCompressedTokenAccountsByDelegateResponseResult {
            Default::default()
        }
    }
    ///`PostGetCompressedTokenAccountsByDelegateV2Body`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getCompressedTokenAccountsByDelegateV2"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "delegate"
    ///      ],
    ///      "properties": {
    ///        "cursor": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Base58String"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "delegate": {
    ///          "$ref": "#/components/schemas/SerializablePubkey"
    ///        },
    ///        "limit": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Limit"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "mint": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/SerializablePubkey"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedTokenAccountsByDelegateV2Body {
        ///An ID to identify the request.
        pub id: PostGetCompressedTokenAccountsByDelegateV2BodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedTokenAccountsByDelegateV2BodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetCompressedTokenAccountsByDelegateV2BodyMethod,
        pub params: PostGetCompressedTokenAccountsByDelegateV2BodyParams,
    }
    impl PostGetCompressedTokenAccountsByDelegateV2Body {
        pub fn builder() -> builder::PostGetCompressedTokenAccountsByDelegateV2Body {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountsByDelegateV2BodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountsByDelegateV2BodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountsByDelegateV2BodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountsByDelegateV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountsByDelegateV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountsByDelegateV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountsByDelegateV2BodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountsByDelegateV2BodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountsByDelegateV2BodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountsByDelegateV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountsByDelegateV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountsByDelegateV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getCompressedTokenAccountsByDelegateV2"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountsByDelegateV2BodyMethod {
        #[serde(rename = "getCompressedTokenAccountsByDelegateV2")]
        GetCompressedTokenAccountsByDelegateV2,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountsByDelegateV2BodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetCompressedTokenAccountsByDelegateV2 => {
                    f.write_str("getCompressedTokenAccountsByDelegateV2")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountsByDelegateV2BodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getCompressedTokenAccountsByDelegateV2" => {
                    Ok(Self::GetCompressedTokenAccountsByDelegateV2)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountsByDelegateV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountsByDelegateV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountsByDelegateV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedTokenAccountsByDelegateV2BodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "delegate"
    ///  ],
    ///  "properties": {
    ///    "cursor": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Base58String"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "delegate": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "limit": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Limit"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "mint": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/SerializablePubkey"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedTokenAccountsByDelegateV2BodyParams {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<Base58String>,
        pub delegate: SerializablePubkey,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub limit: ::std::option::Option<Limit>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mint: ::std::option::Option<SerializablePubkey>,
    }
    impl PostGetCompressedTokenAccountsByDelegateV2BodyParams {
        pub fn builder() -> builder::PostGetCompressedTokenAccountsByDelegateV2BodyParams {
            Default::default()
        }
    }
    ///`PostGetCompressedTokenAccountsByDelegateV2Response`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/TokenAccountListV2"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedTokenAccountsByDelegateV2Response {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<
            PostGetCompressedTokenAccountsByDelegateV2ResponseError,
        >,
        ///An ID to identify the response.
        pub id: PostGetCompressedTokenAccountsByDelegateV2ResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedTokenAccountsByDelegateV2ResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetCompressedTokenAccountsByDelegateV2ResponseResult,
        >,
    }
    impl PostGetCompressedTokenAccountsByDelegateV2Response {
        pub fn builder() -> builder::PostGetCompressedTokenAccountsByDelegateV2Response {
            Default::default()
        }
    }
    ///`PostGetCompressedTokenAccountsByDelegateV2ResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedTokenAccountsByDelegateV2ResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default
    for PostGetCompressedTokenAccountsByDelegateV2ResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetCompressedTokenAccountsByDelegateV2ResponseError {
        pub fn builder() -> builder::PostGetCompressedTokenAccountsByDelegateV2ResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountsByDelegateV2ResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountsByDelegateV2ResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountsByDelegateV2ResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountsByDelegateV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountsByDelegateV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountsByDelegateV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountsByDelegateV2ResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display
    for PostGetCompressedTokenAccountsByDelegateV2ResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr
    for PostGetCompressedTokenAccountsByDelegateV2ResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountsByDelegateV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountsByDelegateV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountsByDelegateV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedTokenAccountsByDelegateV2ResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/TokenAccountListV2"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedTokenAccountsByDelegateV2ResponseResult {
        pub context: Context,
        pub value: TokenAccountListV2,
    }
    impl PostGetCompressedTokenAccountsByDelegateV2ResponseResult {
        pub fn builder() -> builder::PostGetCompressedTokenAccountsByDelegateV2ResponseResult {
            Default::default()
        }
    }
    ///`PostGetCompressedTokenAccountsByOwnerBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getCompressedTokenAccountsByOwner"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "owner"
    ///      ],
    ///      "properties": {
    ///        "cursor": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Base58String"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "limit": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Limit"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "mint": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/SerializablePubkey"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "owner": {
    ///          "$ref": "#/components/schemas/SerializablePubkey"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedTokenAccountsByOwnerBody {
        ///An ID to identify the request.
        pub id: PostGetCompressedTokenAccountsByOwnerBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedTokenAccountsByOwnerBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetCompressedTokenAccountsByOwnerBodyMethod,
        pub params: PostGetCompressedTokenAccountsByOwnerBodyParams,
    }
    impl PostGetCompressedTokenAccountsByOwnerBody {
        pub fn builder() -> builder::PostGetCompressedTokenAccountsByOwnerBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountsByOwnerBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountsByOwnerBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountsByOwnerBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedTokenAccountsByOwnerBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountsByOwnerBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountsByOwnerBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountsByOwnerBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountsByOwnerBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountsByOwnerBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountsByOwnerBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountsByOwnerBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountsByOwnerBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getCompressedTokenAccountsByOwner"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountsByOwnerBodyMethod {
        #[serde(rename = "getCompressedTokenAccountsByOwner")]
        GetCompressedTokenAccountsByOwner,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountsByOwnerBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetCompressedTokenAccountsByOwner => {
                    f.write_str("getCompressedTokenAccountsByOwner")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountsByOwnerBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getCompressedTokenAccountsByOwner" => {
                    Ok(Self::GetCompressedTokenAccountsByOwner)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountsByOwnerBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountsByOwnerBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountsByOwnerBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedTokenAccountsByOwnerBodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "owner"
    ///  ],
    ///  "properties": {
    ///    "cursor": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Base58String"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "limit": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Limit"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "mint": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/SerializablePubkey"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "owner": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedTokenAccountsByOwnerBodyParams {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<Base58String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub limit: ::std::option::Option<Limit>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mint: ::std::option::Option<SerializablePubkey>,
        pub owner: SerializablePubkey,
    }
    impl PostGetCompressedTokenAccountsByOwnerBodyParams {
        pub fn builder() -> builder::PostGetCompressedTokenAccountsByOwnerBodyParams {
            Default::default()
        }
    }
    ///`PostGetCompressedTokenAccountsByOwnerResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/TokenAccountList"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedTokenAccountsByOwnerResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<
            PostGetCompressedTokenAccountsByOwnerResponseError,
        >,
        ///An ID to identify the response.
        pub id: PostGetCompressedTokenAccountsByOwnerResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedTokenAccountsByOwnerResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetCompressedTokenAccountsByOwnerResponseResult,
        >,
    }
    impl PostGetCompressedTokenAccountsByOwnerResponse {
        pub fn builder() -> builder::PostGetCompressedTokenAccountsByOwnerResponse {
            Default::default()
        }
    }
    ///`PostGetCompressedTokenAccountsByOwnerResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedTokenAccountsByOwnerResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetCompressedTokenAccountsByOwnerResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetCompressedTokenAccountsByOwnerResponseError {
        pub fn builder() -> builder::PostGetCompressedTokenAccountsByOwnerResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountsByOwnerResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountsByOwnerResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountsByOwnerResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountsByOwnerResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountsByOwnerResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountsByOwnerResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountsByOwnerResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountsByOwnerResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountsByOwnerResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountsByOwnerResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountsByOwnerResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountsByOwnerResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedTokenAccountsByOwnerResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/TokenAccountList"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedTokenAccountsByOwnerResponseResult {
        pub context: Context,
        pub value: TokenAccountList,
    }
    impl PostGetCompressedTokenAccountsByOwnerResponseResult {
        pub fn builder() -> builder::PostGetCompressedTokenAccountsByOwnerResponseResult {
            Default::default()
        }
    }
    ///`PostGetCompressedTokenAccountsByOwnerV2Body`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getCompressedTokenAccountsByOwnerV2"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "owner"
    ///      ],
    ///      "properties": {
    ///        "cursor": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Base58String"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "limit": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Limit"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "mint": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/SerializablePubkey"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "owner": {
    ///          "$ref": "#/components/schemas/SerializablePubkey"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedTokenAccountsByOwnerV2Body {
        ///An ID to identify the request.
        pub id: PostGetCompressedTokenAccountsByOwnerV2BodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedTokenAccountsByOwnerV2BodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetCompressedTokenAccountsByOwnerV2BodyMethod,
        pub params: PostGetCompressedTokenAccountsByOwnerV2BodyParams,
    }
    impl PostGetCompressedTokenAccountsByOwnerV2Body {
        pub fn builder() -> builder::PostGetCompressedTokenAccountsByOwnerV2Body {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountsByOwnerV2BodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountsByOwnerV2BodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountsByOwnerV2BodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountsByOwnerV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountsByOwnerV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountsByOwnerV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountsByOwnerV2BodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountsByOwnerV2BodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountsByOwnerV2BodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountsByOwnerV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountsByOwnerV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountsByOwnerV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getCompressedTokenAccountsByOwnerV2"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountsByOwnerV2BodyMethod {
        #[serde(rename = "getCompressedTokenAccountsByOwnerV2")]
        GetCompressedTokenAccountsByOwnerV2,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountsByOwnerV2BodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetCompressedTokenAccountsByOwnerV2 => {
                    f.write_str("getCompressedTokenAccountsByOwnerV2")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountsByOwnerV2BodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getCompressedTokenAccountsByOwnerV2" => {
                    Ok(Self::GetCompressedTokenAccountsByOwnerV2)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountsByOwnerV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountsByOwnerV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountsByOwnerV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedTokenAccountsByOwnerV2BodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "owner"
    ///  ],
    ///  "properties": {
    ///    "cursor": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Base58String"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "limit": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Limit"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "mint": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/SerializablePubkey"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "owner": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedTokenAccountsByOwnerV2BodyParams {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<Base58String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub limit: ::std::option::Option<Limit>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mint: ::std::option::Option<SerializablePubkey>,
        pub owner: SerializablePubkey,
    }
    impl PostGetCompressedTokenAccountsByOwnerV2BodyParams {
        pub fn builder() -> builder::PostGetCompressedTokenAccountsByOwnerV2BodyParams {
            Default::default()
        }
    }
    ///`PostGetCompressedTokenAccountsByOwnerV2Response`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/TokenAccountListV2"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedTokenAccountsByOwnerV2Response {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<
            PostGetCompressedTokenAccountsByOwnerV2ResponseError,
        >,
        ///An ID to identify the response.
        pub id: PostGetCompressedTokenAccountsByOwnerV2ResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedTokenAccountsByOwnerV2ResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetCompressedTokenAccountsByOwnerV2ResponseResult,
        >,
    }
    impl PostGetCompressedTokenAccountsByOwnerV2Response {
        pub fn builder() -> builder::PostGetCompressedTokenAccountsByOwnerV2Response {
            Default::default()
        }
    }
    ///`PostGetCompressedTokenAccountsByOwnerV2ResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedTokenAccountsByOwnerV2ResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default
    for PostGetCompressedTokenAccountsByOwnerV2ResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetCompressedTokenAccountsByOwnerV2ResponseError {
        pub fn builder() -> builder::PostGetCompressedTokenAccountsByOwnerV2ResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountsByOwnerV2ResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountsByOwnerV2ResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountsByOwnerV2ResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountsByOwnerV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountsByOwnerV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountsByOwnerV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenAccountsByOwnerV2ResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenAccountsByOwnerV2ResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenAccountsByOwnerV2ResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenAccountsByOwnerV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenAccountsByOwnerV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenAccountsByOwnerV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedTokenAccountsByOwnerV2ResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/TokenAccountListV2"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedTokenAccountsByOwnerV2ResponseResult {
        pub context: Context,
        pub value: TokenAccountListV2,
    }
    impl PostGetCompressedTokenAccountsByOwnerV2ResponseResult {
        pub fn builder() -> builder::PostGetCompressedTokenAccountsByOwnerV2ResponseResult {
            Default::default()
        }
    }
    ///`PostGetCompressedTokenBalancesByOwnerBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getCompressedTokenBalancesByOwner"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "owner"
    ///      ],
    ///      "properties": {
    ///        "cursor": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Base58String"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "limit": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Limit"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "mint": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/SerializablePubkey"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "owner": {
    ///          "$ref": "#/components/schemas/SerializablePubkey"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedTokenBalancesByOwnerBody {
        ///An ID to identify the request.
        pub id: PostGetCompressedTokenBalancesByOwnerBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedTokenBalancesByOwnerBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetCompressedTokenBalancesByOwnerBodyMethod,
        pub params: PostGetCompressedTokenBalancesByOwnerBodyParams,
    }
    impl PostGetCompressedTokenBalancesByOwnerBody {
        pub fn builder() -> builder::PostGetCompressedTokenBalancesByOwnerBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenBalancesByOwnerBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenBalancesByOwnerBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenBalancesByOwnerBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressedTokenBalancesByOwnerBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenBalancesByOwnerBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenBalancesByOwnerBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenBalancesByOwnerBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenBalancesByOwnerBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenBalancesByOwnerBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenBalancesByOwnerBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenBalancesByOwnerBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenBalancesByOwnerBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getCompressedTokenBalancesByOwner"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenBalancesByOwnerBodyMethod {
        #[serde(rename = "getCompressedTokenBalancesByOwner")]
        GetCompressedTokenBalancesByOwner,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenBalancesByOwnerBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetCompressedTokenBalancesByOwner => {
                    f.write_str("getCompressedTokenBalancesByOwner")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenBalancesByOwnerBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getCompressedTokenBalancesByOwner" => {
                    Ok(Self::GetCompressedTokenBalancesByOwner)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenBalancesByOwnerBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenBalancesByOwnerBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenBalancesByOwnerBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedTokenBalancesByOwnerBodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "owner"
    ///  ],
    ///  "properties": {
    ///    "cursor": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Base58String"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "limit": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Limit"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "mint": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/SerializablePubkey"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "owner": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedTokenBalancesByOwnerBodyParams {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<Base58String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub limit: ::std::option::Option<Limit>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mint: ::std::option::Option<SerializablePubkey>,
        pub owner: SerializablePubkey,
    }
    impl PostGetCompressedTokenBalancesByOwnerBodyParams {
        pub fn builder() -> builder::PostGetCompressedTokenBalancesByOwnerBodyParams {
            Default::default()
        }
    }
    ///`PostGetCompressedTokenBalancesByOwnerResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/TokenBalanceList"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedTokenBalancesByOwnerResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<
            PostGetCompressedTokenBalancesByOwnerResponseError,
        >,
        ///An ID to identify the response.
        pub id: PostGetCompressedTokenBalancesByOwnerResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedTokenBalancesByOwnerResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetCompressedTokenBalancesByOwnerResponseResult,
        >,
    }
    impl PostGetCompressedTokenBalancesByOwnerResponse {
        pub fn builder() -> builder::PostGetCompressedTokenBalancesByOwnerResponse {
            Default::default()
        }
    }
    ///`PostGetCompressedTokenBalancesByOwnerResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedTokenBalancesByOwnerResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetCompressedTokenBalancesByOwnerResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetCompressedTokenBalancesByOwnerResponseError {
        pub fn builder() -> builder::PostGetCompressedTokenBalancesByOwnerResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenBalancesByOwnerResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenBalancesByOwnerResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenBalancesByOwnerResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenBalancesByOwnerResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenBalancesByOwnerResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenBalancesByOwnerResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenBalancesByOwnerResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenBalancesByOwnerResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenBalancesByOwnerResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenBalancesByOwnerResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenBalancesByOwnerResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenBalancesByOwnerResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedTokenBalancesByOwnerResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/TokenBalanceList"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedTokenBalancesByOwnerResponseResult {
        pub context: Context,
        pub value: TokenBalanceList,
    }
    impl PostGetCompressedTokenBalancesByOwnerResponseResult {
        pub fn builder() -> builder::PostGetCompressedTokenBalancesByOwnerResponseResult {
            Default::default()
        }
    }
    ///`PostGetCompressedTokenBalancesByOwnerV2Body`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getCompressedTokenBalancesByOwnerV2"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "owner"
    ///      ],
    ///      "properties": {
    ///        "cursor": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Base58String"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "limit": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Limit"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "mint": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/SerializablePubkey"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "owner": {
    ///          "$ref": "#/components/schemas/SerializablePubkey"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedTokenBalancesByOwnerV2Body {
        ///An ID to identify the request.
        pub id: PostGetCompressedTokenBalancesByOwnerV2BodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedTokenBalancesByOwnerV2BodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetCompressedTokenBalancesByOwnerV2BodyMethod,
        pub params: PostGetCompressedTokenBalancesByOwnerV2BodyParams,
    }
    impl PostGetCompressedTokenBalancesByOwnerV2Body {
        pub fn builder() -> builder::PostGetCompressedTokenBalancesByOwnerV2Body {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenBalancesByOwnerV2BodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenBalancesByOwnerV2BodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenBalancesByOwnerV2BodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenBalancesByOwnerV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenBalancesByOwnerV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenBalancesByOwnerV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenBalancesByOwnerV2BodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenBalancesByOwnerV2BodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenBalancesByOwnerV2BodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenBalancesByOwnerV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenBalancesByOwnerV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenBalancesByOwnerV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getCompressedTokenBalancesByOwnerV2"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenBalancesByOwnerV2BodyMethod {
        #[serde(rename = "getCompressedTokenBalancesByOwnerV2")]
        GetCompressedTokenBalancesByOwnerV2,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenBalancesByOwnerV2BodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetCompressedTokenBalancesByOwnerV2 => {
                    f.write_str("getCompressedTokenBalancesByOwnerV2")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenBalancesByOwnerV2BodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getCompressedTokenBalancesByOwnerV2" => {
                    Ok(Self::GetCompressedTokenBalancesByOwnerV2)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenBalancesByOwnerV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenBalancesByOwnerV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenBalancesByOwnerV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedTokenBalancesByOwnerV2BodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "owner"
    ///  ],
    ///  "properties": {
    ///    "cursor": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Base58String"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "limit": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Limit"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "mint": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/SerializablePubkey"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "owner": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedTokenBalancesByOwnerV2BodyParams {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<Base58String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub limit: ::std::option::Option<Limit>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mint: ::std::option::Option<SerializablePubkey>,
        pub owner: SerializablePubkey,
    }
    impl PostGetCompressedTokenBalancesByOwnerV2BodyParams {
        pub fn builder() -> builder::PostGetCompressedTokenBalancesByOwnerV2BodyParams {
            Default::default()
        }
    }
    ///`PostGetCompressedTokenBalancesByOwnerV2Response`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/TokenBalanceListV2"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedTokenBalancesByOwnerV2Response {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<
            PostGetCompressedTokenBalancesByOwnerV2ResponseError,
        >,
        ///An ID to identify the response.
        pub id: PostGetCompressedTokenBalancesByOwnerV2ResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressedTokenBalancesByOwnerV2ResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetCompressedTokenBalancesByOwnerV2ResponseResult,
        >,
    }
    impl PostGetCompressedTokenBalancesByOwnerV2Response {
        pub fn builder() -> builder::PostGetCompressedTokenBalancesByOwnerV2Response {
            Default::default()
        }
    }
    ///`PostGetCompressedTokenBalancesByOwnerV2ResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressedTokenBalancesByOwnerV2ResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default
    for PostGetCompressedTokenBalancesByOwnerV2ResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetCompressedTokenBalancesByOwnerV2ResponseError {
        pub fn builder() -> builder::PostGetCompressedTokenBalancesByOwnerV2ResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenBalancesByOwnerV2ResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenBalancesByOwnerV2ResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenBalancesByOwnerV2ResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenBalancesByOwnerV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenBalancesByOwnerV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenBalancesByOwnerV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressedTokenBalancesByOwnerV2ResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressedTokenBalancesByOwnerV2ResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressedTokenBalancesByOwnerV2ResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressedTokenBalancesByOwnerV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressedTokenBalancesByOwnerV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressedTokenBalancesByOwnerV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressedTokenBalancesByOwnerV2ResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/TokenBalanceListV2"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressedTokenBalancesByOwnerV2ResponseResult {
        pub context: Context,
        pub value: TokenBalanceListV2,
    }
    impl PostGetCompressedTokenBalancesByOwnerV2ResponseResult {
        pub fn builder() -> builder::PostGetCompressedTokenBalancesByOwnerV2ResponseResult {
            Default::default()
        }
    }
    ///`PostGetCompressionSignaturesForAccountBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getCompressionSignaturesForAccount"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "hash"
    ///      ],
    ///      "properties": {
    ///        "hash": {
    ///          "$ref": "#/components/schemas/Hash"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressionSignaturesForAccountBody {
        ///An ID to identify the request.
        pub id: PostGetCompressionSignaturesForAccountBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressionSignaturesForAccountBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetCompressionSignaturesForAccountBodyMethod,
        pub params: PostGetCompressionSignaturesForAccountBodyParams,
    }
    impl PostGetCompressionSignaturesForAccountBody {
        pub fn builder() -> builder::PostGetCompressionSignaturesForAccountBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressionSignaturesForAccountBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressionSignaturesForAccountBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressionSignaturesForAccountBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressionSignaturesForAccountBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressionSignaturesForAccountBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressionSignaturesForAccountBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressionSignaturesForAccountBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressionSignaturesForAccountBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressionSignaturesForAccountBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressionSignaturesForAccountBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressionSignaturesForAccountBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressionSignaturesForAccountBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getCompressionSignaturesForAccount"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressionSignaturesForAccountBodyMethod {
        #[serde(rename = "getCompressionSignaturesForAccount")]
        GetCompressionSignaturesForAccount,
    }
    impl ::std::fmt::Display for PostGetCompressionSignaturesForAccountBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetCompressionSignaturesForAccount => {
                    f.write_str("getCompressionSignaturesForAccount")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressionSignaturesForAccountBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getCompressionSignaturesForAccount" => {
                    Ok(Self::GetCompressionSignaturesForAccount)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressionSignaturesForAccountBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressionSignaturesForAccountBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressionSignaturesForAccountBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressionSignaturesForAccountBodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "hash"
    ///  ],
    ///  "properties": {
    ///    "hash": {
    ///      "$ref": "#/components/schemas/Hash"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressionSignaturesForAccountBodyParams {
        pub hash: Hash,
    }
    impl PostGetCompressionSignaturesForAccountBodyParams {
        pub fn builder() -> builder::PostGetCompressionSignaturesForAccountBodyParams {
            Default::default()
        }
    }
    ///`PostGetCompressionSignaturesForAccountResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/SignatureInfoList"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressionSignaturesForAccountResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<
            PostGetCompressionSignaturesForAccountResponseError,
        >,
        ///An ID to identify the response.
        pub id: PostGetCompressionSignaturesForAccountResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressionSignaturesForAccountResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetCompressionSignaturesForAccountResponseResult,
        >,
    }
    impl PostGetCompressionSignaturesForAccountResponse {
        pub fn builder() -> builder::PostGetCompressionSignaturesForAccountResponse {
            Default::default()
        }
    }
    ///`PostGetCompressionSignaturesForAccountResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressionSignaturesForAccountResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default
    for PostGetCompressionSignaturesForAccountResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetCompressionSignaturesForAccountResponseError {
        pub fn builder() -> builder::PostGetCompressionSignaturesForAccountResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressionSignaturesForAccountResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressionSignaturesForAccountResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressionSignaturesForAccountResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressionSignaturesForAccountResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressionSignaturesForAccountResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressionSignaturesForAccountResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressionSignaturesForAccountResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressionSignaturesForAccountResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressionSignaturesForAccountResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressionSignaturesForAccountResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressionSignaturesForAccountResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressionSignaturesForAccountResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressionSignaturesForAccountResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/SignatureInfoList"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressionSignaturesForAccountResponseResult {
        pub context: Context,
        pub value: SignatureInfoList,
    }
    impl PostGetCompressionSignaturesForAccountResponseResult {
        pub fn builder() -> builder::PostGetCompressionSignaturesForAccountResponseResult {
            Default::default()
        }
    }
    ///`PostGetCompressionSignaturesForAddressBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getCompressionSignaturesForAddress"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "address"
    ///      ],
    ///      "properties": {
    ///        "address": {
    ///          "$ref": "#/components/schemas/SerializablePubkey"
    ///        },
    ///        "cursor": {
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "limit": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Limit"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressionSignaturesForAddressBody {
        ///An ID to identify the request.
        pub id: PostGetCompressionSignaturesForAddressBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressionSignaturesForAddressBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetCompressionSignaturesForAddressBodyMethod,
        pub params: PostGetCompressionSignaturesForAddressBodyParams,
    }
    impl PostGetCompressionSignaturesForAddressBody {
        pub fn builder() -> builder::PostGetCompressionSignaturesForAddressBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressionSignaturesForAddressBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressionSignaturesForAddressBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressionSignaturesForAddressBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressionSignaturesForAddressBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressionSignaturesForAddressBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressionSignaturesForAddressBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressionSignaturesForAddressBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressionSignaturesForAddressBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressionSignaturesForAddressBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressionSignaturesForAddressBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressionSignaturesForAddressBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressionSignaturesForAddressBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getCompressionSignaturesForAddress"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressionSignaturesForAddressBodyMethod {
        #[serde(rename = "getCompressionSignaturesForAddress")]
        GetCompressionSignaturesForAddress,
    }
    impl ::std::fmt::Display for PostGetCompressionSignaturesForAddressBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetCompressionSignaturesForAddress => {
                    f.write_str("getCompressionSignaturesForAddress")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressionSignaturesForAddressBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getCompressionSignaturesForAddress" => {
                    Ok(Self::GetCompressionSignaturesForAddress)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressionSignaturesForAddressBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressionSignaturesForAddressBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressionSignaturesForAddressBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressionSignaturesForAddressBodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "cursor": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "limit": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Limit"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressionSignaturesForAddressBodyParams {
        pub address: SerializablePubkey,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub limit: ::std::option::Option<Limit>,
    }
    impl PostGetCompressionSignaturesForAddressBodyParams {
        pub fn builder() -> builder::PostGetCompressionSignaturesForAddressBodyParams {
            Default::default()
        }
    }
    ///`PostGetCompressionSignaturesForAddressResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/PaginatedSignatureInfoList"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressionSignaturesForAddressResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<
            PostGetCompressionSignaturesForAddressResponseError,
        >,
        ///An ID to identify the response.
        pub id: PostGetCompressionSignaturesForAddressResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressionSignaturesForAddressResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetCompressionSignaturesForAddressResponseResult,
        >,
    }
    impl PostGetCompressionSignaturesForAddressResponse {
        pub fn builder() -> builder::PostGetCompressionSignaturesForAddressResponse {
            Default::default()
        }
    }
    ///`PostGetCompressionSignaturesForAddressResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressionSignaturesForAddressResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default
    for PostGetCompressionSignaturesForAddressResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetCompressionSignaturesForAddressResponseError {
        pub fn builder() -> builder::PostGetCompressionSignaturesForAddressResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressionSignaturesForAddressResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressionSignaturesForAddressResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressionSignaturesForAddressResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressionSignaturesForAddressResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressionSignaturesForAddressResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressionSignaturesForAddressResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressionSignaturesForAddressResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressionSignaturesForAddressResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressionSignaturesForAddressResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressionSignaturesForAddressResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressionSignaturesForAddressResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressionSignaturesForAddressResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressionSignaturesForAddressResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/PaginatedSignatureInfoList"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressionSignaturesForAddressResponseResult {
        pub context: Context,
        pub value: PaginatedSignatureInfoList,
    }
    impl PostGetCompressionSignaturesForAddressResponseResult {
        pub fn builder() -> builder::PostGetCompressionSignaturesForAddressResponseResult {
            Default::default()
        }
    }
    ///`PostGetCompressionSignaturesForOwnerBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getCompressionSignaturesForOwner"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "owner"
    ///      ],
    ///      "properties": {
    ///        "cursor": {
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "limit": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Limit"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "owner": {
    ///          "$ref": "#/components/schemas/SerializablePubkey"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressionSignaturesForOwnerBody {
        ///An ID to identify the request.
        pub id: PostGetCompressionSignaturesForOwnerBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressionSignaturesForOwnerBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetCompressionSignaturesForOwnerBodyMethod,
        pub params: PostGetCompressionSignaturesForOwnerBodyParams,
    }
    impl PostGetCompressionSignaturesForOwnerBody {
        pub fn builder() -> builder::PostGetCompressionSignaturesForOwnerBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressionSignaturesForOwnerBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressionSignaturesForOwnerBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressionSignaturesForOwnerBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetCompressionSignaturesForOwnerBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressionSignaturesForOwnerBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressionSignaturesForOwnerBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressionSignaturesForOwnerBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressionSignaturesForOwnerBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressionSignaturesForOwnerBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressionSignaturesForOwnerBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressionSignaturesForOwnerBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressionSignaturesForOwnerBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getCompressionSignaturesForOwner"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressionSignaturesForOwnerBodyMethod {
        #[serde(rename = "getCompressionSignaturesForOwner")]
        GetCompressionSignaturesForOwner,
    }
    impl ::std::fmt::Display for PostGetCompressionSignaturesForOwnerBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetCompressionSignaturesForOwner => {
                    f.write_str("getCompressionSignaturesForOwner")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressionSignaturesForOwnerBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getCompressionSignaturesForOwner" => {
                    Ok(Self::GetCompressionSignaturesForOwner)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressionSignaturesForOwnerBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressionSignaturesForOwnerBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressionSignaturesForOwnerBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressionSignaturesForOwnerBodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "owner"
    ///  ],
    ///  "properties": {
    ///    "cursor": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "limit": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Limit"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "owner": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressionSignaturesForOwnerBodyParams {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub limit: ::std::option::Option<Limit>,
        pub owner: SerializablePubkey,
    }
    impl PostGetCompressionSignaturesForOwnerBodyParams {
        pub fn builder() -> builder::PostGetCompressionSignaturesForOwnerBodyParams {
            Default::default()
        }
    }
    ///`PostGetCompressionSignaturesForOwnerResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/PaginatedSignatureInfoList"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressionSignaturesForOwnerResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<
            PostGetCompressionSignaturesForOwnerResponseError,
        >,
        ///An ID to identify the response.
        pub id: PostGetCompressionSignaturesForOwnerResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressionSignaturesForOwnerResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetCompressionSignaturesForOwnerResponseResult,
        >,
    }
    impl PostGetCompressionSignaturesForOwnerResponse {
        pub fn builder() -> builder::PostGetCompressionSignaturesForOwnerResponse {
            Default::default()
        }
    }
    ///`PostGetCompressionSignaturesForOwnerResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressionSignaturesForOwnerResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetCompressionSignaturesForOwnerResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetCompressionSignaturesForOwnerResponseError {
        pub fn builder() -> builder::PostGetCompressionSignaturesForOwnerResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressionSignaturesForOwnerResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressionSignaturesForOwnerResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressionSignaturesForOwnerResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressionSignaturesForOwnerResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressionSignaturesForOwnerResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressionSignaturesForOwnerResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressionSignaturesForOwnerResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressionSignaturesForOwnerResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressionSignaturesForOwnerResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressionSignaturesForOwnerResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressionSignaturesForOwnerResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressionSignaturesForOwnerResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressionSignaturesForOwnerResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/PaginatedSignatureInfoList"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressionSignaturesForOwnerResponseResult {
        pub context: Context,
        pub value: PaginatedSignatureInfoList,
    }
    impl PostGetCompressionSignaturesForOwnerResponseResult {
        pub fn builder() -> builder::PostGetCompressionSignaturesForOwnerResponseResult {
            Default::default()
        }
    }
    ///`PostGetCompressionSignaturesForTokenOwnerBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getCompressionSignaturesForTokenOwner"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "owner"
    ///      ],
    ///      "properties": {
    ///        "cursor": {
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "limit": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Limit"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "owner": {
    ///          "$ref": "#/components/schemas/SerializablePubkey"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressionSignaturesForTokenOwnerBody {
        ///An ID to identify the request.
        pub id: PostGetCompressionSignaturesForTokenOwnerBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressionSignaturesForTokenOwnerBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetCompressionSignaturesForTokenOwnerBodyMethod,
        pub params: PostGetCompressionSignaturesForTokenOwnerBodyParams,
    }
    impl PostGetCompressionSignaturesForTokenOwnerBody {
        pub fn builder() -> builder::PostGetCompressionSignaturesForTokenOwnerBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressionSignaturesForTokenOwnerBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressionSignaturesForTokenOwnerBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressionSignaturesForTokenOwnerBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressionSignaturesForTokenOwnerBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressionSignaturesForTokenOwnerBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressionSignaturesForTokenOwnerBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressionSignaturesForTokenOwnerBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetCompressionSignaturesForTokenOwnerBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressionSignaturesForTokenOwnerBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressionSignaturesForTokenOwnerBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressionSignaturesForTokenOwnerBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressionSignaturesForTokenOwnerBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getCompressionSignaturesForTokenOwner"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressionSignaturesForTokenOwnerBodyMethod {
        #[serde(rename = "getCompressionSignaturesForTokenOwner")]
        GetCompressionSignaturesForTokenOwner,
    }
    impl ::std::fmt::Display for PostGetCompressionSignaturesForTokenOwnerBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetCompressionSignaturesForTokenOwner => {
                    f.write_str("getCompressionSignaturesForTokenOwner")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressionSignaturesForTokenOwnerBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getCompressionSignaturesForTokenOwner" => {
                    Ok(Self::GetCompressionSignaturesForTokenOwner)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressionSignaturesForTokenOwnerBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressionSignaturesForTokenOwnerBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressionSignaturesForTokenOwnerBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressionSignaturesForTokenOwnerBodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "owner"
    ///  ],
    ///  "properties": {
    ///    "cursor": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "limit": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Limit"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "owner": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressionSignaturesForTokenOwnerBodyParams {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub limit: ::std::option::Option<Limit>,
        pub owner: SerializablePubkey,
    }
    impl PostGetCompressionSignaturesForTokenOwnerBodyParams {
        pub fn builder() -> builder::PostGetCompressionSignaturesForTokenOwnerBodyParams {
            Default::default()
        }
    }
    ///`PostGetCompressionSignaturesForTokenOwnerResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/PaginatedSignatureInfoList"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressionSignaturesForTokenOwnerResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<
            PostGetCompressionSignaturesForTokenOwnerResponseError,
        >,
        ///An ID to identify the response.
        pub id: PostGetCompressionSignaturesForTokenOwnerResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetCompressionSignaturesForTokenOwnerResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetCompressionSignaturesForTokenOwnerResponseResult,
        >,
    }
    impl PostGetCompressionSignaturesForTokenOwnerResponse {
        pub fn builder() -> builder::PostGetCompressionSignaturesForTokenOwnerResponse {
            Default::default()
        }
    }
    ///`PostGetCompressionSignaturesForTokenOwnerResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetCompressionSignaturesForTokenOwnerResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default
    for PostGetCompressionSignaturesForTokenOwnerResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetCompressionSignaturesForTokenOwnerResponseError {
        pub fn builder() -> builder::PostGetCompressionSignaturesForTokenOwnerResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressionSignaturesForTokenOwnerResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetCompressionSignaturesForTokenOwnerResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetCompressionSignaturesForTokenOwnerResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressionSignaturesForTokenOwnerResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressionSignaturesForTokenOwnerResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressionSignaturesForTokenOwnerResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetCompressionSignaturesForTokenOwnerResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display
    for PostGetCompressionSignaturesForTokenOwnerResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr
    for PostGetCompressionSignaturesForTokenOwnerResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetCompressionSignaturesForTokenOwnerResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetCompressionSignaturesForTokenOwnerResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetCompressionSignaturesForTokenOwnerResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetCompressionSignaturesForTokenOwnerResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/PaginatedSignatureInfoList"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetCompressionSignaturesForTokenOwnerResponseResult {
        pub context: Context,
        pub value: PaginatedSignatureInfoList,
    }
    impl PostGetCompressionSignaturesForTokenOwnerResponseResult {
        pub fn builder() -> builder::PostGetCompressionSignaturesForTokenOwnerResponseResult {
            Default::default()
        }
    }
    ///`PostGetIndexerHealthBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getIndexerHealth"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetIndexerHealthBody {
        ///An ID to identify the request.
        pub id: PostGetIndexerHealthBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetIndexerHealthBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetIndexerHealthBodyMethod,
    }
    impl PostGetIndexerHealthBody {
        pub fn builder() -> builder::PostGetIndexerHealthBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetIndexerHealthBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetIndexerHealthBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetIndexerHealthBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetIndexerHealthBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PostGetIndexerHealthBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PostGetIndexerHealthBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetIndexerHealthBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetIndexerHealthBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetIndexerHealthBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetIndexerHealthBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetIndexerHealthBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetIndexerHealthBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getIndexerHealth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetIndexerHealthBodyMethod {
        #[serde(rename = "getIndexerHealth")]
        GetIndexerHealth,
    }
    impl ::std::fmt::Display for PostGetIndexerHealthBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetIndexerHealth => f.write_str("getIndexerHealth"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetIndexerHealthBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getIndexerHealth" => Ok(Self::GetIndexerHealth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetIndexerHealthBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetIndexerHealthBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetIndexerHealthBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetIndexerHealthResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "description": "ok if healthy",
    ///      "default": "ok",
    ///      "type": "string",
    ///      "enum": [
    ///        "ok"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetIndexerHealthResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<PostGetIndexerHealthResponseError>,
        ///An ID to identify the response.
        pub id: PostGetIndexerHealthResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetIndexerHealthResponseJsonrpc,
        ///ok if healthy
        #[serde(default = "defaults::post_get_indexer_health_response_result")]
        pub result: PostGetIndexerHealthResponseResult,
    }
    impl PostGetIndexerHealthResponse {
        pub fn builder() -> builder::PostGetIndexerHealthResponse {
            Default::default()
        }
    }
    ///`PostGetIndexerHealthResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetIndexerHealthResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetIndexerHealthResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetIndexerHealthResponseError {
        pub fn builder() -> builder::PostGetIndexerHealthResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetIndexerHealthResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetIndexerHealthResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetIndexerHealthResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetIndexerHealthResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetIndexerHealthResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetIndexerHealthResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetIndexerHealthResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetIndexerHealthResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetIndexerHealthResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetIndexerHealthResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetIndexerHealthResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetIndexerHealthResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///ok if healthy
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "ok if healthy",
    ///  "default": "ok",
    ///  "type": "string",
    ///  "enum": [
    ///    "ok"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetIndexerHealthResponseResult {
        #[serde(rename = "ok")]
        Ok,
    }
    impl ::std::fmt::Display for PostGetIndexerHealthResponseResult {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ok => f.write_str("ok"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetIndexerHealthResponseResult {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ok" => Ok(Self::Ok),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetIndexerHealthResponseResult {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetIndexerHealthResponseResult {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetIndexerHealthResponseResult {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::default::Default for PostGetIndexerHealthResponseResult {
        fn default() -> Self {
            PostGetIndexerHealthResponseResult::Ok
        }
    }
    ///`PostGetIndexerSlotBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getIndexerSlot"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetIndexerSlotBody {
        ///An ID to identify the request.
        pub id: PostGetIndexerSlotBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetIndexerSlotBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetIndexerSlotBodyMethod,
    }
    impl PostGetIndexerSlotBody {
        pub fn builder() -> builder::PostGetIndexerSlotBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetIndexerSlotBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetIndexerSlotBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetIndexerSlotBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetIndexerSlotBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PostGetIndexerSlotBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PostGetIndexerSlotBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetIndexerSlotBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetIndexerSlotBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetIndexerSlotBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetIndexerSlotBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetIndexerSlotBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetIndexerSlotBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getIndexerSlot"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetIndexerSlotBodyMethod {
        #[serde(rename = "getIndexerSlot")]
        GetIndexerSlot,
    }
    impl ::std::fmt::Display for PostGetIndexerSlotBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetIndexerSlot => f.write_str("getIndexerSlot"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetIndexerSlotBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getIndexerSlot" => Ok(Self::GetIndexerSlot),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetIndexerSlotBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetIndexerSlotBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetIndexerSlotBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetIndexerSlotResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "default": 100,
    ///      "examples": [
    ///        100
    ///      ],
    ///      "type": "integer",
    ///      "format": "uint64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetIndexerSlotResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<PostGetIndexerSlotResponseError>,
        ///An ID to identify the response.
        pub id: PostGetIndexerSlotResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetIndexerSlotResponseJsonrpc,
        #[serde(default = "defaults::default_u64::<u64, 100>")]
        pub result: u64,
    }
    impl PostGetIndexerSlotResponse {
        pub fn builder() -> builder::PostGetIndexerSlotResponse {
            Default::default()
        }
    }
    ///`PostGetIndexerSlotResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetIndexerSlotResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetIndexerSlotResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetIndexerSlotResponseError {
        pub fn builder() -> builder::PostGetIndexerSlotResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetIndexerSlotResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetIndexerSlotResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetIndexerSlotResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetIndexerSlotResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetIndexerSlotResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetIndexerSlotResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetIndexerSlotResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetIndexerSlotResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetIndexerSlotResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetIndexerSlotResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetIndexerSlotResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetIndexerSlotResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetLatestCompressionSignaturesBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getLatestCompressionSignatures"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "properties": {
    ///        "cursor": {
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "limit": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Limit"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetLatestCompressionSignaturesBody {
        ///An ID to identify the request.
        pub id: PostGetLatestCompressionSignaturesBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetLatestCompressionSignaturesBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetLatestCompressionSignaturesBodyMethod,
        pub params: PostGetLatestCompressionSignaturesBodyParams,
    }
    impl PostGetLatestCompressionSignaturesBody {
        pub fn builder() -> builder::PostGetLatestCompressionSignaturesBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetLatestCompressionSignaturesBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetLatestCompressionSignaturesBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetLatestCompressionSignaturesBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetLatestCompressionSignaturesBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetLatestCompressionSignaturesBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetLatestCompressionSignaturesBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetLatestCompressionSignaturesBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetLatestCompressionSignaturesBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetLatestCompressionSignaturesBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetLatestCompressionSignaturesBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetLatestCompressionSignaturesBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetLatestCompressionSignaturesBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getLatestCompressionSignatures"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetLatestCompressionSignaturesBodyMethod {
        #[serde(rename = "getLatestCompressionSignatures")]
        GetLatestCompressionSignatures,
    }
    impl ::std::fmt::Display for PostGetLatestCompressionSignaturesBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetLatestCompressionSignatures => {
                    f.write_str("getLatestCompressionSignatures")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetLatestCompressionSignaturesBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getLatestCompressionSignatures" => {
                    Ok(Self::GetLatestCompressionSignatures)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetLatestCompressionSignaturesBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetLatestCompressionSignaturesBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetLatestCompressionSignaturesBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetLatestCompressionSignaturesBodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "cursor": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "limit": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Limit"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetLatestCompressionSignaturesBodyParams {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub limit: ::std::option::Option<Limit>,
    }
    impl ::std::default::Default for PostGetLatestCompressionSignaturesBodyParams {
        fn default() -> Self {
            Self {
                cursor: Default::default(),
                limit: Default::default(),
            }
        }
    }
    impl PostGetLatestCompressionSignaturesBodyParams {
        pub fn builder() -> builder::PostGetLatestCompressionSignaturesBodyParams {
            Default::default()
        }
    }
    ///`PostGetLatestCompressionSignaturesResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/PaginatedSignatureInfoList"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetLatestCompressionSignaturesResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<
            PostGetLatestCompressionSignaturesResponseError,
        >,
        ///An ID to identify the response.
        pub id: PostGetLatestCompressionSignaturesResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetLatestCompressionSignaturesResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetLatestCompressionSignaturesResponseResult,
        >,
    }
    impl PostGetLatestCompressionSignaturesResponse {
        pub fn builder() -> builder::PostGetLatestCompressionSignaturesResponse {
            Default::default()
        }
    }
    ///`PostGetLatestCompressionSignaturesResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetLatestCompressionSignaturesResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetLatestCompressionSignaturesResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetLatestCompressionSignaturesResponseError {
        pub fn builder() -> builder::PostGetLatestCompressionSignaturesResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetLatestCompressionSignaturesResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetLatestCompressionSignaturesResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetLatestCompressionSignaturesResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetLatestCompressionSignaturesResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetLatestCompressionSignaturesResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetLatestCompressionSignaturesResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetLatestCompressionSignaturesResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetLatestCompressionSignaturesResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetLatestCompressionSignaturesResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetLatestCompressionSignaturesResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetLatestCompressionSignaturesResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetLatestCompressionSignaturesResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetLatestCompressionSignaturesResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/PaginatedSignatureInfoList"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetLatestCompressionSignaturesResponseResult {
        pub context: Context,
        pub value: PaginatedSignatureInfoList,
    }
    impl PostGetLatestCompressionSignaturesResponseResult {
        pub fn builder() -> builder::PostGetLatestCompressionSignaturesResponseResult {
            Default::default()
        }
    }
    ///`PostGetLatestNonVotingSignaturesBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getLatestNonVotingSignatures"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "properties": {
    ///        "cursor": {
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "limit": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Limit"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetLatestNonVotingSignaturesBody {
        ///An ID to identify the request.
        pub id: PostGetLatestNonVotingSignaturesBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetLatestNonVotingSignaturesBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetLatestNonVotingSignaturesBodyMethod,
        pub params: PostGetLatestNonVotingSignaturesBodyParams,
    }
    impl PostGetLatestNonVotingSignaturesBody {
        pub fn builder() -> builder::PostGetLatestNonVotingSignaturesBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetLatestNonVotingSignaturesBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetLatestNonVotingSignaturesBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetLatestNonVotingSignaturesBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetLatestNonVotingSignaturesBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetLatestNonVotingSignaturesBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetLatestNonVotingSignaturesBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetLatestNonVotingSignaturesBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetLatestNonVotingSignaturesBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetLatestNonVotingSignaturesBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetLatestNonVotingSignaturesBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetLatestNonVotingSignaturesBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetLatestNonVotingSignaturesBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getLatestNonVotingSignatures"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetLatestNonVotingSignaturesBodyMethod {
        #[serde(rename = "getLatestNonVotingSignatures")]
        GetLatestNonVotingSignatures,
    }
    impl ::std::fmt::Display for PostGetLatestNonVotingSignaturesBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetLatestNonVotingSignatures => {
                    f.write_str("getLatestNonVotingSignatures")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetLatestNonVotingSignaturesBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getLatestNonVotingSignatures" => Ok(Self::GetLatestNonVotingSignatures),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetLatestNonVotingSignaturesBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetLatestNonVotingSignaturesBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetLatestNonVotingSignaturesBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetLatestNonVotingSignaturesBodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "cursor": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "limit": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Limit"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetLatestNonVotingSignaturesBodyParams {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub limit: ::std::option::Option<Limit>,
    }
    impl ::std::default::Default for PostGetLatestNonVotingSignaturesBodyParams {
        fn default() -> Self {
            Self {
                cursor: Default::default(),
                limit: Default::default(),
            }
        }
    }
    impl PostGetLatestNonVotingSignaturesBodyParams {
        pub fn builder() -> builder::PostGetLatestNonVotingSignaturesBodyParams {
            Default::default()
        }
    }
    ///`PostGetLatestNonVotingSignaturesResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/SignatureInfoListWithError"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetLatestNonVotingSignaturesResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<PostGetLatestNonVotingSignaturesResponseError>,
        ///An ID to identify the response.
        pub id: PostGetLatestNonVotingSignaturesResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetLatestNonVotingSignaturesResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetLatestNonVotingSignaturesResponseResult,
        >,
    }
    impl PostGetLatestNonVotingSignaturesResponse {
        pub fn builder() -> builder::PostGetLatestNonVotingSignaturesResponse {
            Default::default()
        }
    }
    ///`PostGetLatestNonVotingSignaturesResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetLatestNonVotingSignaturesResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetLatestNonVotingSignaturesResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetLatestNonVotingSignaturesResponseError {
        pub fn builder() -> builder::PostGetLatestNonVotingSignaturesResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetLatestNonVotingSignaturesResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetLatestNonVotingSignaturesResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetLatestNonVotingSignaturesResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetLatestNonVotingSignaturesResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetLatestNonVotingSignaturesResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetLatestNonVotingSignaturesResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetLatestNonVotingSignaturesResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetLatestNonVotingSignaturesResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetLatestNonVotingSignaturesResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetLatestNonVotingSignaturesResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetLatestNonVotingSignaturesResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetLatestNonVotingSignaturesResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetLatestNonVotingSignaturesResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/SignatureInfoListWithError"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetLatestNonVotingSignaturesResponseResult {
        pub context: Context,
        pub value: SignatureInfoListWithError,
    }
    impl PostGetLatestNonVotingSignaturesResponseResult {
        pub fn builder() -> builder::PostGetLatestNonVotingSignaturesResponseResult {
            Default::default()
        }
    }
    ///`PostGetMultipleAccountInterfacesBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getMultipleAccountInterfaces"
    ///      ]
    ///    },
    ///    "params": {
    ///      "description": "Request for getMultipleAccountInterfaces",
    ///      "type": "object",
    ///      "required": [
    ///        "addresses"
    ///      ],
    ///      "properties": {
    ///        "addresses": {
    ///          "description": "List of account addresses to look up (max 100)",
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/SerializablePubkey"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleAccountInterfacesBody {
        ///An ID to identify the request.
        pub id: PostGetMultipleAccountInterfacesBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetMultipleAccountInterfacesBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetMultipleAccountInterfacesBodyMethod,
        pub params: PostGetMultipleAccountInterfacesBodyParams,
    }
    impl PostGetMultipleAccountInterfacesBody {
        pub fn builder() -> builder::PostGetMultipleAccountInterfacesBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleAccountInterfacesBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetMultipleAccountInterfacesBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleAccountInterfacesBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetMultipleAccountInterfacesBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleAccountInterfacesBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleAccountInterfacesBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleAccountInterfacesBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetMultipleAccountInterfacesBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleAccountInterfacesBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetMultipleAccountInterfacesBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleAccountInterfacesBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleAccountInterfacesBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getMultipleAccountInterfaces"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleAccountInterfacesBodyMethod {
        #[serde(rename = "getMultipleAccountInterfaces")]
        GetMultipleAccountInterfaces,
    }
    impl ::std::fmt::Display for PostGetMultipleAccountInterfacesBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetMultipleAccountInterfaces => {
                    f.write_str("getMultipleAccountInterfaces")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleAccountInterfacesBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getMultipleAccountInterfaces" => Ok(Self::GetMultipleAccountInterfaces),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetMultipleAccountInterfacesBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleAccountInterfacesBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleAccountInterfacesBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Request for getMultipleAccountInterfaces
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Request for getMultipleAccountInterfaces",
    ///  "type": "object",
    ///  "required": [
    ///    "addresses"
    ///  ],
    ///  "properties": {
    ///    "addresses": {
    ///      "description": "List of account addresses to look up (max 100)",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SerializablePubkey"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetMultipleAccountInterfacesBodyParams {
        ///List of account addresses to look up (max 100)
        pub addresses: ::std::vec::Vec<SerializablePubkey>,
    }
    impl PostGetMultipleAccountInterfacesBodyParams {
        pub fn builder() -> builder::PostGetMultipleAccountInterfacesBodyParams {
            Default::default()
        }
    }
    ///`PostGetMultipleAccountInterfacesResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "description": "Response for getMultipleAccountInterfaces",
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "description": "List of account results (Some for found accounts, None for not found)",
    ///          "type": "array",
    ///          "items": {
    ///            "oneOf": [
    ///              {
    ///                "type": "null"
    ///              },
    ///              {
    ///                "allOf": [
    ///                  {
    ///                    "$ref": "#/components/schemas/AccountInterface"
    ///                  }
    ///                ]
    ///              }
    ///            ]
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleAccountInterfacesResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<PostGetMultipleAccountInterfacesResponseError>,
        ///An ID to identify the response.
        pub id: PostGetMultipleAccountInterfacesResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetMultipleAccountInterfacesResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetMultipleAccountInterfacesResponseResult,
        >,
    }
    impl PostGetMultipleAccountInterfacesResponse {
        pub fn builder() -> builder::PostGetMultipleAccountInterfacesResponse {
            Default::default()
        }
    }
    ///`PostGetMultipleAccountInterfacesResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleAccountInterfacesResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetMultipleAccountInterfacesResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetMultipleAccountInterfacesResponseError {
        pub fn builder() -> builder::PostGetMultipleAccountInterfacesResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleAccountInterfacesResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetMultipleAccountInterfacesResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleAccountInterfacesResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetMultipleAccountInterfacesResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleAccountInterfacesResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleAccountInterfacesResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleAccountInterfacesResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetMultipleAccountInterfacesResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleAccountInterfacesResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetMultipleAccountInterfacesResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleAccountInterfacesResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleAccountInterfacesResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Response for getMultipleAccountInterfaces
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Response for getMultipleAccountInterfaces",
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "description": "List of account results (Some for found accounts, None for not found)",
    ///      "type": "array",
    ///      "items": {
    ///        "oneOf": [
    ///          {
    ///            "type": "null"
    ///          },
    ///          {
    ///            "allOf": [
    ///              {
    ///                "$ref": "#/components/schemas/AccountInterface"
    ///              }
    ///            ]
    ///          }
    ///        ]
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleAccountInterfacesResponseResult {
        pub context: Context,
        ///List of account results (Some for found accounts, None for not found)
        pub value: ::std::vec::Vec<::std::option::Option<AccountInterface>>,
    }
    impl PostGetMultipleAccountInterfacesResponseResult {
        pub fn builder() -> builder::PostGetMultipleAccountInterfacesResponseResult {
            Default::default()
        }
    }
    ///`PostGetMultipleCompressedAccountProofsBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getMultipleCompressedAccountProofs"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Hash"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleCompressedAccountProofsBody {
        ///An ID to identify the request.
        pub id: PostGetMultipleCompressedAccountProofsBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetMultipleCompressedAccountProofsBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetMultipleCompressedAccountProofsBodyMethod,
        pub params: ::std::vec::Vec<Hash>,
    }
    impl PostGetMultipleCompressedAccountProofsBody {
        pub fn builder() -> builder::PostGetMultipleCompressedAccountProofsBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleCompressedAccountProofsBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetMultipleCompressedAccountProofsBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleCompressedAccountProofsBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetMultipleCompressedAccountProofsBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleCompressedAccountProofsBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleCompressedAccountProofsBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleCompressedAccountProofsBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetMultipleCompressedAccountProofsBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleCompressedAccountProofsBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetMultipleCompressedAccountProofsBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleCompressedAccountProofsBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleCompressedAccountProofsBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getMultipleCompressedAccountProofs"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleCompressedAccountProofsBodyMethod {
        #[serde(rename = "getMultipleCompressedAccountProofs")]
        GetMultipleCompressedAccountProofs,
    }
    impl ::std::fmt::Display for PostGetMultipleCompressedAccountProofsBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetMultipleCompressedAccountProofs => {
                    f.write_str("getMultipleCompressedAccountProofs")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleCompressedAccountProofsBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getMultipleCompressedAccountProofs" => {
                    Ok(Self::GetMultipleCompressedAccountProofs)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetMultipleCompressedAccountProofsBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleCompressedAccountProofsBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleCompressedAccountProofsBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetMultipleCompressedAccountProofsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/GetCompressedAccountProofResponseValue"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleCompressedAccountProofsResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<
            PostGetMultipleCompressedAccountProofsResponseError,
        >,
        ///An ID to identify the response.
        pub id: PostGetMultipleCompressedAccountProofsResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetMultipleCompressedAccountProofsResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetMultipleCompressedAccountProofsResponseResult,
        >,
    }
    impl PostGetMultipleCompressedAccountProofsResponse {
        pub fn builder() -> builder::PostGetMultipleCompressedAccountProofsResponse {
            Default::default()
        }
    }
    ///`PostGetMultipleCompressedAccountProofsResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleCompressedAccountProofsResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default
    for PostGetMultipleCompressedAccountProofsResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetMultipleCompressedAccountProofsResponseError {
        pub fn builder() -> builder::PostGetMultipleCompressedAccountProofsResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleCompressedAccountProofsResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetMultipleCompressedAccountProofsResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleCompressedAccountProofsResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetMultipleCompressedAccountProofsResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleCompressedAccountProofsResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleCompressedAccountProofsResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleCompressedAccountProofsResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetMultipleCompressedAccountProofsResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleCompressedAccountProofsResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetMultipleCompressedAccountProofsResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleCompressedAccountProofsResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleCompressedAccountProofsResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetMultipleCompressedAccountProofsResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/GetCompressedAccountProofResponseValue"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetMultipleCompressedAccountProofsResponseResult {
        pub context: Context,
        pub value: ::std::vec::Vec<GetCompressedAccountProofResponseValue>,
    }
    impl PostGetMultipleCompressedAccountProofsResponseResult {
        pub fn builder() -> builder::PostGetMultipleCompressedAccountProofsResponseResult {
            Default::default()
        }
    }
    ///`PostGetMultipleCompressedAccountProofsV2Body`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getMultipleCompressedAccountProofsV2"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Hash"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleCompressedAccountProofsV2Body {
        ///An ID to identify the request.
        pub id: PostGetMultipleCompressedAccountProofsV2BodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetMultipleCompressedAccountProofsV2BodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetMultipleCompressedAccountProofsV2BodyMethod,
        pub params: ::std::vec::Vec<Hash>,
    }
    impl PostGetMultipleCompressedAccountProofsV2Body {
        pub fn builder() -> builder::PostGetMultipleCompressedAccountProofsV2Body {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleCompressedAccountProofsV2BodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetMultipleCompressedAccountProofsV2BodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleCompressedAccountProofsV2BodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetMultipleCompressedAccountProofsV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleCompressedAccountProofsV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleCompressedAccountProofsV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleCompressedAccountProofsV2BodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetMultipleCompressedAccountProofsV2BodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleCompressedAccountProofsV2BodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetMultipleCompressedAccountProofsV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleCompressedAccountProofsV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleCompressedAccountProofsV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getMultipleCompressedAccountProofsV2"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleCompressedAccountProofsV2BodyMethod {
        #[serde(rename = "getMultipleCompressedAccountProofsV2")]
        GetMultipleCompressedAccountProofsV2,
    }
    impl ::std::fmt::Display for PostGetMultipleCompressedAccountProofsV2BodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetMultipleCompressedAccountProofsV2 => {
                    f.write_str("getMultipleCompressedAccountProofsV2")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleCompressedAccountProofsV2BodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getMultipleCompressedAccountProofsV2" => {
                    Ok(Self::GetMultipleCompressedAccountProofsV2)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetMultipleCompressedAccountProofsV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleCompressedAccountProofsV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleCompressedAccountProofsV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetMultipleCompressedAccountProofsV2Response`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/GetCompressedAccountProofResponseValueV2"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleCompressedAccountProofsV2Response {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<
            PostGetMultipleCompressedAccountProofsV2ResponseError,
        >,
        ///An ID to identify the response.
        pub id: PostGetMultipleCompressedAccountProofsV2ResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetMultipleCompressedAccountProofsV2ResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetMultipleCompressedAccountProofsV2ResponseResult,
        >,
    }
    impl PostGetMultipleCompressedAccountProofsV2Response {
        pub fn builder() -> builder::PostGetMultipleCompressedAccountProofsV2Response {
            Default::default()
        }
    }
    ///`PostGetMultipleCompressedAccountProofsV2ResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleCompressedAccountProofsV2ResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default
    for PostGetMultipleCompressedAccountProofsV2ResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetMultipleCompressedAccountProofsV2ResponseError {
        pub fn builder() -> builder::PostGetMultipleCompressedAccountProofsV2ResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleCompressedAccountProofsV2ResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetMultipleCompressedAccountProofsV2ResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleCompressedAccountProofsV2ResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetMultipleCompressedAccountProofsV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleCompressedAccountProofsV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleCompressedAccountProofsV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleCompressedAccountProofsV2ResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display
    for PostGetMultipleCompressedAccountProofsV2ResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr
    for PostGetMultipleCompressedAccountProofsV2ResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetMultipleCompressedAccountProofsV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleCompressedAccountProofsV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleCompressedAccountProofsV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetMultipleCompressedAccountProofsV2ResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/GetCompressedAccountProofResponseValueV2"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetMultipleCompressedAccountProofsV2ResponseResult {
        pub context: Context,
        pub value: ::std::vec::Vec<GetCompressedAccountProofResponseValueV2>,
    }
    impl PostGetMultipleCompressedAccountProofsV2ResponseResult {
        pub fn builder() -> builder::PostGetMultipleCompressedAccountProofsV2ResponseResult {
            Default::default()
        }
    }
    ///`PostGetMultipleCompressedAccountsBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getMultipleCompressedAccounts"
    ///      ]
    ///    },
    ///    "params": {
    ///      "description": "Request for compressed account data",
    ///      "default": {
    ///        "addresses": null,
    ///        "hashes": [
    ///          "11157t3sqMV725NVRLrVQbAu98Jjfk1uCKehJnXXQs",
    ///          "1117mWrzzrZr312ebPDHu8tbfMwFNvCvMbr6WepCNG"
    ///        ]
    ///      },
    ///      "examples": [
    ///        {
    ///          "addresses": null,
    ///          "hashes": [
    ///            "11157t3sqMV725NVRLrVQbAu98Jjfk1uCKehJnXXQs",
    ///            "1117mWrzzrZr312ebPDHu8tbfMwFNvCvMbr6WepCNG"
    ///          ]
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "properties": {
    ///        "addresses": {
    ///          "type": [
    ///            "array",
    ///            "null"
    ///          ],
    ///          "items": {
    ///            "$ref": "#/components/schemas/SerializablePubkey"
    ///          }
    ///        },
    ///        "hashes": {
    ///          "type": [
    ///            "array",
    ///            "null"
    ///          ],
    ///          "items": {
    ///            "$ref": "#/components/schemas/Hash"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleCompressedAccountsBody {
        ///An ID to identify the request.
        pub id: PostGetMultipleCompressedAccountsBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetMultipleCompressedAccountsBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetMultipleCompressedAccountsBodyMethod,
        pub params: PostGetMultipleCompressedAccountsBodyParams,
    }
    impl PostGetMultipleCompressedAccountsBody {
        pub fn builder() -> builder::PostGetMultipleCompressedAccountsBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleCompressedAccountsBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetMultipleCompressedAccountsBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleCompressedAccountsBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetMultipleCompressedAccountsBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleCompressedAccountsBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleCompressedAccountsBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleCompressedAccountsBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetMultipleCompressedAccountsBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleCompressedAccountsBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetMultipleCompressedAccountsBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleCompressedAccountsBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleCompressedAccountsBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getMultipleCompressedAccounts"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleCompressedAccountsBodyMethod {
        #[serde(rename = "getMultipleCompressedAccounts")]
        GetMultipleCompressedAccounts,
    }
    impl ::std::fmt::Display for PostGetMultipleCompressedAccountsBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetMultipleCompressedAccounts => {
                    f.write_str("getMultipleCompressedAccounts")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleCompressedAccountsBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getMultipleCompressedAccounts" => {
                    Ok(Self::GetMultipleCompressedAccounts)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetMultipleCompressedAccountsBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleCompressedAccountsBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleCompressedAccountsBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Request for compressed account data
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Request for compressed account data",
    ///  "default": {
    ///    "addresses": null,
    ///    "hashes": [
    ///      "11157t3sqMV725NVRLrVQbAu98Jjfk1uCKehJnXXQs",
    ///      "1117mWrzzrZr312ebPDHu8tbfMwFNvCvMbr6WepCNG"
    ///    ]
    ///  },
    ///  "examples": [
    ///    {
    ///      "addresses": null,
    ///      "hashes": [
    ///        "11157t3sqMV725NVRLrVQbAu98Jjfk1uCKehJnXXQs",
    ///        "1117mWrzzrZr312ebPDHu8tbfMwFNvCvMbr6WepCNG"
    ///      ]
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "addresses": {
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/SerializablePubkey"
    ///      }
    ///    },
    ///    "hashes": {
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/Hash"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetMultipleCompressedAccountsBodyParams {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub addresses: ::std::option::Option<::std::vec::Vec<SerializablePubkey>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub hashes: ::std::option::Option<::std::vec::Vec<Hash>>,
    }
    impl ::std::default::Default for PostGetMultipleCompressedAccountsBodyParams {
        fn default() -> Self {
            PostGetMultipleCompressedAccountsBodyParams {
                addresses: ::std::option::Option::None,
                hashes: ::std::option::Option::Some(
                    vec![
                        Hash("11157t3sqMV725NVRLrVQbAu98Jjfk1uCKehJnXXQs".to_string()),
                        Hash("1117mWrzzrZr312ebPDHu8tbfMwFNvCvMbr6WepCNG".to_string())
                    ],
                ),
            }
        }
    }
    impl PostGetMultipleCompressedAccountsBodyParams {
        pub fn builder() -> builder::PostGetMultipleCompressedAccountsBodyParams {
            Default::default()
        }
    }
    ///`PostGetMultipleCompressedAccountsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/AccountList"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleCompressedAccountsResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<PostGetMultipleCompressedAccountsResponseError>,
        ///An ID to identify the response.
        pub id: PostGetMultipleCompressedAccountsResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetMultipleCompressedAccountsResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetMultipleCompressedAccountsResponseResult,
        >,
    }
    impl PostGetMultipleCompressedAccountsResponse {
        pub fn builder() -> builder::PostGetMultipleCompressedAccountsResponse {
            Default::default()
        }
    }
    ///`PostGetMultipleCompressedAccountsResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleCompressedAccountsResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetMultipleCompressedAccountsResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetMultipleCompressedAccountsResponseError {
        pub fn builder() -> builder::PostGetMultipleCompressedAccountsResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleCompressedAccountsResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetMultipleCompressedAccountsResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleCompressedAccountsResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetMultipleCompressedAccountsResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleCompressedAccountsResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleCompressedAccountsResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleCompressedAccountsResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetMultipleCompressedAccountsResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleCompressedAccountsResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetMultipleCompressedAccountsResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleCompressedAccountsResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleCompressedAccountsResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetMultipleCompressedAccountsResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/AccountList"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetMultipleCompressedAccountsResponseResult {
        pub context: Context,
        pub value: AccountList,
    }
    impl PostGetMultipleCompressedAccountsResponseResult {
        pub fn builder() -> builder::PostGetMultipleCompressedAccountsResponseResult {
            Default::default()
        }
    }
    ///`PostGetMultipleCompressedAccountsV2Body`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getMultipleCompressedAccountsV2"
    ///      ]
    ///    },
    ///    "params": {
    ///      "description": "Request for compressed account data",
    ///      "default": {
    ///        "addresses": null,
    ///        "hashes": [
    ///          "1119DWteoLSdjvrT6g6L8C2PfDD2faiTQUpsjY2RiF",
    ///          "111BuZ6b86gm7XhxjvTakhRvxSMjXp2GqgifkNUmDK"
    ///        ]
    ///      },
    ///      "examples": [
    ///        {
    ///          "addresses": null,
    ///          "hashes": [
    ///            "1119DWteoLSdjvrT6g6L8C2PfDD2faiTQUpsjY2RiF",
    ///            "111BuZ6b86gm7XhxjvTakhRvxSMjXp2GqgifkNUmDK"
    ///          ]
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "properties": {
    ///        "addresses": {
    ///          "type": [
    ///            "array",
    ///            "null"
    ///          ],
    ///          "items": {
    ///            "$ref": "#/components/schemas/SerializablePubkey"
    ///          }
    ///        },
    ///        "hashes": {
    ///          "type": [
    ///            "array",
    ///            "null"
    ///          ],
    ///          "items": {
    ///            "$ref": "#/components/schemas/Hash"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleCompressedAccountsV2Body {
        ///An ID to identify the request.
        pub id: PostGetMultipleCompressedAccountsV2BodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetMultipleCompressedAccountsV2BodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetMultipleCompressedAccountsV2BodyMethod,
        pub params: PostGetMultipleCompressedAccountsV2BodyParams,
    }
    impl PostGetMultipleCompressedAccountsV2Body {
        pub fn builder() -> builder::PostGetMultipleCompressedAccountsV2Body {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleCompressedAccountsV2BodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetMultipleCompressedAccountsV2BodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleCompressedAccountsV2BodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetMultipleCompressedAccountsV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleCompressedAccountsV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleCompressedAccountsV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleCompressedAccountsV2BodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetMultipleCompressedAccountsV2BodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleCompressedAccountsV2BodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetMultipleCompressedAccountsV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleCompressedAccountsV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleCompressedAccountsV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getMultipleCompressedAccountsV2"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleCompressedAccountsV2BodyMethod {
        #[serde(rename = "getMultipleCompressedAccountsV2")]
        GetMultipleCompressedAccountsV2,
    }
    impl ::std::fmt::Display for PostGetMultipleCompressedAccountsV2BodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetMultipleCompressedAccountsV2 => {
                    f.write_str("getMultipleCompressedAccountsV2")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleCompressedAccountsV2BodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getMultipleCompressedAccountsV2" => {
                    Ok(Self::GetMultipleCompressedAccountsV2)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetMultipleCompressedAccountsV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleCompressedAccountsV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleCompressedAccountsV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///Request for compressed account data
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Request for compressed account data",
    ///  "default": {
    ///    "addresses": null,
    ///    "hashes": [
    ///      "1119DWteoLSdjvrT6g6L8C2PfDD2faiTQUpsjY2RiF",
    ///      "111BuZ6b86gm7XhxjvTakhRvxSMjXp2GqgifkNUmDK"
    ///    ]
    ///  },
    ///  "examples": [
    ///    {
    ///      "addresses": null,
    ///      "hashes": [
    ///        "1119DWteoLSdjvrT6g6L8C2PfDD2faiTQUpsjY2RiF",
    ///        "111BuZ6b86gm7XhxjvTakhRvxSMjXp2GqgifkNUmDK"
    ///      ]
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "addresses": {
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/SerializablePubkey"
    ///      }
    ///    },
    ///    "hashes": {
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/Hash"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetMultipleCompressedAccountsV2BodyParams {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub addresses: ::std::option::Option<::std::vec::Vec<SerializablePubkey>>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub hashes: ::std::option::Option<::std::vec::Vec<Hash>>,
    }
    impl ::std::default::Default for PostGetMultipleCompressedAccountsV2BodyParams {
        fn default() -> Self {
            PostGetMultipleCompressedAccountsV2BodyParams {
                addresses: ::std::option::Option::None,
                hashes: ::std::option::Option::Some(
                    vec![
                        Hash("1119DWteoLSdjvrT6g6L8C2PfDD2faiTQUpsjY2RiF".to_string()),
                        Hash("111BuZ6b86gm7XhxjvTakhRvxSMjXp2GqgifkNUmDK".to_string())
                    ],
                ),
            }
        }
    }
    impl PostGetMultipleCompressedAccountsV2BodyParams {
        pub fn builder() -> builder::PostGetMultipleCompressedAccountsV2BodyParams {
            Default::default()
        }
    }
    ///`PostGetMultipleCompressedAccountsV2Response`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/AccountListV2"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleCompressedAccountsV2Response {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<
            PostGetMultipleCompressedAccountsV2ResponseError,
        >,
        ///An ID to identify the response.
        pub id: PostGetMultipleCompressedAccountsV2ResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetMultipleCompressedAccountsV2ResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetMultipleCompressedAccountsV2ResponseResult,
        >,
    }
    impl PostGetMultipleCompressedAccountsV2Response {
        pub fn builder() -> builder::PostGetMultipleCompressedAccountsV2Response {
            Default::default()
        }
    }
    ///`PostGetMultipleCompressedAccountsV2ResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleCompressedAccountsV2ResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetMultipleCompressedAccountsV2ResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetMultipleCompressedAccountsV2ResponseError {
        pub fn builder() -> builder::PostGetMultipleCompressedAccountsV2ResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleCompressedAccountsV2ResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetMultipleCompressedAccountsV2ResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleCompressedAccountsV2ResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetMultipleCompressedAccountsV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleCompressedAccountsV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleCompressedAccountsV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleCompressedAccountsV2ResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetMultipleCompressedAccountsV2ResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleCompressedAccountsV2ResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetMultipleCompressedAccountsV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleCompressedAccountsV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleCompressedAccountsV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetMultipleCompressedAccountsV2ResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/AccountListV2"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetMultipleCompressedAccountsV2ResponseResult {
        pub context: Context,
        pub value: AccountListV2,
    }
    impl PostGetMultipleCompressedAccountsV2ResponseResult {
        pub fn builder() -> builder::PostGetMultipleCompressedAccountsV2ResponseResult {
            Default::default()
        }
    }
    ///`PostGetMultipleNewAddressProofsBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getMultipleNewAddressProofs"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SerializablePubkey"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleNewAddressProofsBody {
        ///An ID to identify the request.
        pub id: PostGetMultipleNewAddressProofsBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetMultipleNewAddressProofsBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetMultipleNewAddressProofsBodyMethod,
        pub params: ::std::vec::Vec<SerializablePubkey>,
    }
    impl PostGetMultipleNewAddressProofsBody {
        pub fn builder() -> builder::PostGetMultipleNewAddressProofsBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleNewAddressProofsBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetMultipleNewAddressProofsBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleNewAddressProofsBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetMultipleNewAddressProofsBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleNewAddressProofsBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleNewAddressProofsBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleNewAddressProofsBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetMultipleNewAddressProofsBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleNewAddressProofsBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetMultipleNewAddressProofsBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleNewAddressProofsBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleNewAddressProofsBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getMultipleNewAddressProofs"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleNewAddressProofsBodyMethod {
        #[serde(rename = "getMultipleNewAddressProofs")]
        GetMultipleNewAddressProofs,
    }
    impl ::std::fmt::Display for PostGetMultipleNewAddressProofsBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetMultipleNewAddressProofs => {
                    f.write_str("getMultipleNewAddressProofs")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleNewAddressProofsBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getMultipleNewAddressProofs" => Ok(Self::GetMultipleNewAddressProofs),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetMultipleNewAddressProofsBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleNewAddressProofsBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleNewAddressProofsBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetMultipleNewAddressProofsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/MerkleContextWithNewAddressProof"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleNewAddressProofsResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<PostGetMultipleNewAddressProofsResponseError>,
        ///An ID to identify the response.
        pub id: PostGetMultipleNewAddressProofsResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetMultipleNewAddressProofsResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<PostGetMultipleNewAddressProofsResponseResult>,
    }
    impl PostGetMultipleNewAddressProofsResponse {
        pub fn builder() -> builder::PostGetMultipleNewAddressProofsResponse {
            Default::default()
        }
    }
    ///`PostGetMultipleNewAddressProofsResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleNewAddressProofsResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetMultipleNewAddressProofsResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetMultipleNewAddressProofsResponseError {
        pub fn builder() -> builder::PostGetMultipleNewAddressProofsResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleNewAddressProofsResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetMultipleNewAddressProofsResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleNewAddressProofsResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetMultipleNewAddressProofsResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleNewAddressProofsResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleNewAddressProofsResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleNewAddressProofsResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetMultipleNewAddressProofsResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleNewAddressProofsResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetMultipleNewAddressProofsResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleNewAddressProofsResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleNewAddressProofsResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetMultipleNewAddressProofsResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/MerkleContextWithNewAddressProof"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleNewAddressProofsResponseResult {
        pub context: Context,
        pub value: ::std::vec::Vec<MerkleContextWithNewAddressProof>,
    }
    impl PostGetMultipleNewAddressProofsResponseResult {
        pub fn builder() -> builder::PostGetMultipleNewAddressProofsResponseResult {
            Default::default()
        }
    }
    ///`PostGetMultipleNewAddressProofsV2Body`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getMultipleNewAddressProofsV2"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AddressWithTree"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleNewAddressProofsV2Body {
        ///An ID to identify the request.
        pub id: PostGetMultipleNewAddressProofsV2BodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetMultipleNewAddressProofsV2BodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetMultipleNewAddressProofsV2BodyMethod,
        pub params: ::std::vec::Vec<AddressWithTree>,
    }
    impl PostGetMultipleNewAddressProofsV2Body {
        pub fn builder() -> builder::PostGetMultipleNewAddressProofsV2Body {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleNewAddressProofsV2BodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetMultipleNewAddressProofsV2BodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleNewAddressProofsV2BodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetMultipleNewAddressProofsV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleNewAddressProofsV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleNewAddressProofsV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleNewAddressProofsV2BodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetMultipleNewAddressProofsV2BodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleNewAddressProofsV2BodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetMultipleNewAddressProofsV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleNewAddressProofsV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleNewAddressProofsV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getMultipleNewAddressProofsV2"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleNewAddressProofsV2BodyMethod {
        #[serde(rename = "getMultipleNewAddressProofsV2")]
        GetMultipleNewAddressProofsV2,
    }
    impl ::std::fmt::Display for PostGetMultipleNewAddressProofsV2BodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetMultipleNewAddressProofsV2 => {
                    f.write_str("getMultipleNewAddressProofsV2")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleNewAddressProofsV2BodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getMultipleNewAddressProofsV2" => {
                    Ok(Self::GetMultipleNewAddressProofsV2)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetMultipleNewAddressProofsV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleNewAddressProofsV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleNewAddressProofsV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetMultipleNewAddressProofsV2Response`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/MerkleContextWithNewAddressProof"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleNewAddressProofsV2Response {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<PostGetMultipleNewAddressProofsV2ResponseError>,
        ///An ID to identify the response.
        pub id: PostGetMultipleNewAddressProofsV2ResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetMultipleNewAddressProofsV2ResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetMultipleNewAddressProofsV2ResponseResult,
        >,
    }
    impl PostGetMultipleNewAddressProofsV2Response {
        pub fn builder() -> builder::PostGetMultipleNewAddressProofsV2Response {
            Default::default()
        }
    }
    ///`PostGetMultipleNewAddressProofsV2ResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleNewAddressProofsV2ResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetMultipleNewAddressProofsV2ResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetMultipleNewAddressProofsV2ResponseError {
        pub fn builder() -> builder::PostGetMultipleNewAddressProofsV2ResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleNewAddressProofsV2ResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetMultipleNewAddressProofsV2ResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleNewAddressProofsV2ResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetMultipleNewAddressProofsV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleNewAddressProofsV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleNewAddressProofsV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetMultipleNewAddressProofsV2ResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetMultipleNewAddressProofsV2ResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetMultipleNewAddressProofsV2ResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetMultipleNewAddressProofsV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetMultipleNewAddressProofsV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetMultipleNewAddressProofsV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetMultipleNewAddressProofsV2ResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/MerkleContextWithNewAddressProof"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetMultipleNewAddressProofsV2ResponseResult {
        pub context: Context,
        pub value: ::std::vec::Vec<MerkleContextWithNewAddressProof>,
    }
    impl PostGetMultipleNewAddressProofsV2ResponseResult {
        pub fn builder() -> builder::PostGetMultipleNewAddressProofsV2ResponseResult {
            Default::default()
        }
    }
    ///`PostGetQueueElementsBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getQueueElements"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "tree"
    ///      ],
    ///      "properties": {
    ///        "addressQueue": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/QueueRequest"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "inputQueue": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/QueueRequest"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "outputQueue": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/QueueRequest"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "tree": {
    ///          "$ref": "#/components/schemas/Hash"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetQueueElementsBody {
        ///An ID to identify the request.
        pub id: PostGetQueueElementsBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetQueueElementsBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetQueueElementsBodyMethod,
        pub params: PostGetQueueElementsBodyParams,
    }
    impl PostGetQueueElementsBody {
        pub fn builder() -> builder::PostGetQueueElementsBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetQueueElementsBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetQueueElementsBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetQueueElementsBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetQueueElementsBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PostGetQueueElementsBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PostGetQueueElementsBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetQueueElementsBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetQueueElementsBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetQueueElementsBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetQueueElementsBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetQueueElementsBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetQueueElementsBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getQueueElements"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetQueueElementsBodyMethod {
        #[serde(rename = "getQueueElements")]
        GetQueueElements,
    }
    impl ::std::fmt::Display for PostGetQueueElementsBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetQueueElements => f.write_str("getQueueElements"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetQueueElementsBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getQueueElements" => Ok(Self::GetQueueElements),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetQueueElementsBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetQueueElementsBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetQueueElementsBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetQueueElementsBodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "tree"
    ///  ],
    ///  "properties": {
    ///    "addressQueue": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/QueueRequest"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "inputQueue": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/QueueRequest"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "outputQueue": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/QueueRequest"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "tree": {
    ///      "$ref": "#/components/schemas/Hash"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetQueueElementsBodyParams {
        #[serde(
            rename = "addressQueue",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub address_queue: ::std::option::Option<QueueRequest>,
        #[serde(
            rename = "inputQueue",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub input_queue: ::std::option::Option<QueueRequest>,
        #[serde(
            rename = "outputQueue",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub output_queue: ::std::option::Option<QueueRequest>,
        pub tree: Hash,
    }
    impl PostGetQueueElementsBodyParams {
        pub fn builder() -> builder::PostGetQueueElementsBodyParams {
            Default::default()
        }
    }
    ///`PostGetQueueElementsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context"
    ///      ],
    ///      "properties": {
    ///        "addressQueue": {
    ///          "$ref": "#/components/schemas/AddressQueueData"
    ///        },
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "stateQueue": {
    ///          "$ref": "#/components/schemas/StateQueueData"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetQueueElementsResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<PostGetQueueElementsResponseError>,
        ///An ID to identify the response.
        pub id: PostGetQueueElementsResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetQueueElementsResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<PostGetQueueElementsResponseResult>,
    }
    impl PostGetQueueElementsResponse {
        pub fn builder() -> builder::PostGetQueueElementsResponse {
            Default::default()
        }
    }
    ///`PostGetQueueElementsResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetQueueElementsResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetQueueElementsResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetQueueElementsResponseError {
        pub fn builder() -> builder::PostGetQueueElementsResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetQueueElementsResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetQueueElementsResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetQueueElementsResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetQueueElementsResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetQueueElementsResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetQueueElementsResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetQueueElementsResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetQueueElementsResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetQueueElementsResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetQueueElementsResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetQueueElementsResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetQueueElementsResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetQueueElementsResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context"
    ///  ],
    ///  "properties": {
    ///    "addressQueue": {
    ///      "$ref": "#/components/schemas/AddressQueueData"
    ///    },
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "stateQueue": {
    ///      "$ref": "#/components/schemas/StateQueueData"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetQueueElementsResponseResult {
        #[serde(
            rename = "addressQueue",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub address_queue: ::std::option::Option<AddressQueueData>,
        pub context: Context,
        #[serde(
            rename = "stateQueue",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub state_queue: ::std::option::Option<StateQueueData>,
    }
    impl PostGetQueueElementsResponseResult {
        pub fn builder() -> builder::PostGetQueueElementsResponseResult {
            Default::default()
        }
    }
    ///`PostGetQueueInfoBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getQueueInfo"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "properties": {
    ///        "trees": {
    ///          "type": [
    ///            "array",
    ///            "null"
    ///          ],
    ///          "items": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetQueueInfoBody {
        ///An ID to identify the request.
        pub id: PostGetQueueInfoBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetQueueInfoBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetQueueInfoBodyMethod,
        pub params: PostGetQueueInfoBodyParams,
    }
    impl PostGetQueueInfoBody {
        pub fn builder() -> builder::PostGetQueueInfoBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetQueueInfoBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetQueueInfoBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetQueueInfoBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetQueueInfoBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PostGetQueueInfoBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PostGetQueueInfoBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetQueueInfoBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetQueueInfoBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetQueueInfoBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetQueueInfoBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetQueueInfoBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PostGetQueueInfoBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getQueueInfo"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetQueueInfoBodyMethod {
        #[serde(rename = "getQueueInfo")]
        GetQueueInfo,
    }
    impl ::std::fmt::Display for PostGetQueueInfoBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetQueueInfo => f.write_str("getQueueInfo"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetQueueInfoBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getQueueInfo" => Ok(Self::GetQueueInfo),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetQueueInfoBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PostGetQueueInfoBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PostGetQueueInfoBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetQueueInfoBodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "trees": {
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetQueueInfoBodyParams {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub trees: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    }
    impl ::std::default::Default for PostGetQueueInfoBodyParams {
        fn default() -> Self {
            Self { trees: Default::default() }
        }
    }
    impl PostGetQueueInfoBodyParams {
        pub fn builder() -> builder::PostGetQueueInfoBodyParams {
            Default::default()
        }
    }
    ///`PostGetQueueInfoResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "queues",
    ///        "slot"
    ///      ],
    ///      "properties": {
    ///        "queues": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/QueueInfo"
    ///          }
    ///        },
    ///        "slot": {
    ///          "type": "integer",
    ///          "format": "uint64",
    ///          "minimum": 0.0
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetQueueInfoResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<PostGetQueueInfoResponseError>,
        ///An ID to identify the response.
        pub id: PostGetQueueInfoResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetQueueInfoResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<PostGetQueueInfoResponseResult>,
    }
    impl PostGetQueueInfoResponse {
        pub fn builder() -> builder::PostGetQueueInfoResponse {
            Default::default()
        }
    }
    ///`PostGetQueueInfoResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetQueueInfoResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetQueueInfoResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetQueueInfoResponseError {
        pub fn builder() -> builder::PostGetQueueInfoResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetQueueInfoResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetQueueInfoResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetQueueInfoResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetQueueInfoResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PostGetQueueInfoResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PostGetQueueInfoResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetQueueInfoResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetQueueInfoResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetQueueInfoResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetQueueInfoResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetQueueInfoResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetQueueInfoResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetQueueInfoResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "queues",
    ///    "slot"
    ///  ],
    ///  "properties": {
    ///    "queues": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/QueueInfo"
    ///      }
    ///    },
    ///    "slot": {
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetQueueInfoResponseResult {
        pub queues: ::std::vec::Vec<QueueInfo>,
        pub slot: u64,
    }
    impl PostGetQueueInfoResponseResult {
        pub fn builder() -> builder::PostGetQueueInfoResponseResult {
            Default::default()
        }
    }
    ///`PostGetTransactionWithCompressionInfoBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getTransactionWithCompressionInfo"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "signature"
    ///      ],
    ///      "properties": {
    ///        "signature": {
    ///          "$ref": "#/components/schemas/SerializableSignature"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetTransactionWithCompressionInfoBody {
        ///An ID to identify the request.
        pub id: PostGetTransactionWithCompressionInfoBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetTransactionWithCompressionInfoBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetTransactionWithCompressionInfoBodyMethod,
        pub params: PostGetTransactionWithCompressionInfoBodyParams,
    }
    impl PostGetTransactionWithCompressionInfoBody {
        pub fn builder() -> builder::PostGetTransactionWithCompressionInfoBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetTransactionWithCompressionInfoBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetTransactionWithCompressionInfoBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetTransactionWithCompressionInfoBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetTransactionWithCompressionInfoBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetTransactionWithCompressionInfoBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetTransactionWithCompressionInfoBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetTransactionWithCompressionInfoBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetTransactionWithCompressionInfoBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetTransactionWithCompressionInfoBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetTransactionWithCompressionInfoBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetTransactionWithCompressionInfoBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetTransactionWithCompressionInfoBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getTransactionWithCompressionInfo"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetTransactionWithCompressionInfoBodyMethod {
        #[serde(rename = "getTransactionWithCompressionInfo")]
        GetTransactionWithCompressionInfo,
    }
    impl ::std::fmt::Display for PostGetTransactionWithCompressionInfoBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetTransactionWithCompressionInfo => {
                    f.write_str("getTransactionWithCompressionInfo")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetTransactionWithCompressionInfoBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getTransactionWithCompressionInfo" => {
                    Ok(Self::GetTransactionWithCompressionInfo)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetTransactionWithCompressionInfoBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetTransactionWithCompressionInfoBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetTransactionWithCompressionInfoBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetTransactionWithCompressionInfoBodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "signature"
    ///  ],
    ///  "properties": {
    ///    "signature": {
    ///      "$ref": "#/components/schemas/SerializableSignature"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetTransactionWithCompressionInfoBodyParams {
        pub signature: SerializableSignature,
    }
    impl PostGetTransactionWithCompressionInfoBodyParams {
        pub fn builder() -> builder::PostGetTransactionWithCompressionInfoBodyParams {
            Default::default()
        }
    }
    ///`PostGetTransactionWithCompressionInfoResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "description": "A Solana transaction with additional compression information",
    ///      "type": "object",
    ///      "properties": {
    ///        "compression_info": {
    ///          "type": "object",
    ///          "required": [
    ///            "closedAccounts",
    ///            "openedAccounts"
    ///          ],
    ///          "properties": {
    ///            "closedAccounts": {
    ///              "type": "array",
    ///              "items": {
    ///                "$ref": "#/components/schemas/AccountWithOptionalTokenData"
    ///              }
    ///            },
    ///            "openedAccounts": {
    ///              "type": "array",
    ///              "items": {
    ///                "$ref": "#/components/schemas/AccountWithOptionalTokenData"
    ///              }
    ///            }
    ///          },
    ///          "additionalProperties": false
    ///        },
    ///        "transaction": {
    ///          "description": "An encoded confirmed transaction with status meta",
    ///          "type": "object"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetTransactionWithCompressionInfoResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<
            PostGetTransactionWithCompressionInfoResponseError,
        >,
        ///An ID to identify the response.
        pub id: PostGetTransactionWithCompressionInfoResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetTransactionWithCompressionInfoResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetTransactionWithCompressionInfoResponseResult,
        >,
    }
    impl PostGetTransactionWithCompressionInfoResponse {
        pub fn builder() -> builder::PostGetTransactionWithCompressionInfoResponse {
            Default::default()
        }
    }
    ///`PostGetTransactionWithCompressionInfoResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetTransactionWithCompressionInfoResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetTransactionWithCompressionInfoResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetTransactionWithCompressionInfoResponseError {
        pub fn builder() -> builder::PostGetTransactionWithCompressionInfoResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetTransactionWithCompressionInfoResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetTransactionWithCompressionInfoResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetTransactionWithCompressionInfoResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetTransactionWithCompressionInfoResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetTransactionWithCompressionInfoResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetTransactionWithCompressionInfoResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetTransactionWithCompressionInfoResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetTransactionWithCompressionInfoResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetTransactionWithCompressionInfoResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetTransactionWithCompressionInfoResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetTransactionWithCompressionInfoResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetTransactionWithCompressionInfoResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///A Solana transaction with additional compression information
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A Solana transaction with additional compression information",
    ///  "type": "object",
    ///  "properties": {
    ///    "compression_info": {
    ///      "type": "object",
    ///      "required": [
    ///        "closedAccounts",
    ///        "openedAccounts"
    ///      ],
    ///      "properties": {
    ///        "closedAccounts": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/AccountWithOptionalTokenData"
    ///          }
    ///        },
    ///        "openedAccounts": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/AccountWithOptionalTokenData"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "transaction": {
    ///      "description": "An encoded confirmed transaction with status meta",
    ///      "type": "object"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetTransactionWithCompressionInfoResponseResult {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub compression_info: ::std::option::Option<
            PostGetTransactionWithCompressionInfoResponseResultCompressionInfo,
        >,
        ///An encoded confirmed transaction with status meta
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub transaction: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    }
    impl ::std::default::Default
    for PostGetTransactionWithCompressionInfoResponseResult {
        fn default() -> Self {
            Self {
                compression_info: Default::default(),
                transaction: Default::default(),
            }
        }
    }
    impl PostGetTransactionWithCompressionInfoResponseResult {
        pub fn builder() -> builder::PostGetTransactionWithCompressionInfoResponseResult {
            Default::default()
        }
    }
    ///`PostGetTransactionWithCompressionInfoResponseResultCompressionInfo`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "closedAccounts",
    ///    "openedAccounts"
    ///  ],
    ///  "properties": {
    ///    "closedAccounts": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AccountWithOptionalTokenData"
    ///      }
    ///    },
    ///    "openedAccounts": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AccountWithOptionalTokenData"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetTransactionWithCompressionInfoResponseResultCompressionInfo {
        #[serde(rename = "closedAccounts")]
        pub closed_accounts: ::std::vec::Vec<AccountWithOptionalTokenData>,
        #[serde(rename = "openedAccounts")]
        pub opened_accounts: ::std::vec::Vec<AccountWithOptionalTokenData>,
    }
    impl PostGetTransactionWithCompressionInfoResponseResultCompressionInfo {
        pub fn builder() -> builder::PostGetTransactionWithCompressionInfoResponseResultCompressionInfo {
            Default::default()
        }
    }
    ///`PostGetTransactionWithCompressionInfoV2Body`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getTransactionWithCompressionInfoV2"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "signature"
    ///      ],
    ///      "properties": {
    ///        "signature": {
    ///          "$ref": "#/components/schemas/SerializableSignature"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetTransactionWithCompressionInfoV2Body {
        ///An ID to identify the request.
        pub id: PostGetTransactionWithCompressionInfoV2BodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetTransactionWithCompressionInfoV2BodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetTransactionWithCompressionInfoV2BodyMethod,
        pub params: PostGetTransactionWithCompressionInfoV2BodyParams,
    }
    impl PostGetTransactionWithCompressionInfoV2Body {
        pub fn builder() -> builder::PostGetTransactionWithCompressionInfoV2Body {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetTransactionWithCompressionInfoV2BodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetTransactionWithCompressionInfoV2BodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetTransactionWithCompressionInfoV2BodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetTransactionWithCompressionInfoV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetTransactionWithCompressionInfoV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetTransactionWithCompressionInfoV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetTransactionWithCompressionInfoV2BodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetTransactionWithCompressionInfoV2BodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetTransactionWithCompressionInfoV2BodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetTransactionWithCompressionInfoV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetTransactionWithCompressionInfoV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetTransactionWithCompressionInfoV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getTransactionWithCompressionInfoV2"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetTransactionWithCompressionInfoV2BodyMethod {
        #[serde(rename = "getTransactionWithCompressionInfoV2")]
        GetTransactionWithCompressionInfoV2,
    }
    impl ::std::fmt::Display for PostGetTransactionWithCompressionInfoV2BodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetTransactionWithCompressionInfoV2 => {
                    f.write_str("getTransactionWithCompressionInfoV2")
                }
            }
        }
    }
    impl ::std::str::FromStr for PostGetTransactionWithCompressionInfoV2BodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getTransactionWithCompressionInfoV2" => {
                    Ok(Self::GetTransactionWithCompressionInfoV2)
                }
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetTransactionWithCompressionInfoV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetTransactionWithCompressionInfoV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetTransactionWithCompressionInfoV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetTransactionWithCompressionInfoV2BodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "signature"
    ///  ],
    ///  "properties": {
    ///    "signature": {
    ///      "$ref": "#/components/schemas/SerializableSignature"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetTransactionWithCompressionInfoV2BodyParams {
        pub signature: SerializableSignature,
    }
    impl PostGetTransactionWithCompressionInfoV2BodyParams {
        pub fn builder() -> builder::PostGetTransactionWithCompressionInfoV2BodyParams {
            Default::default()
        }
    }
    ///`PostGetTransactionWithCompressionInfoV2Response`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "description": "A Solana transaction with additional compression information",
    ///      "type": "object",
    ///      "properties": {
    ///        "compression_info": {
    ///          "type": "object",
    ///          "required": [
    ///            "closedAccounts",
    ///            "openedAccounts"
    ///          ],
    ///          "properties": {
    ///            "closedAccounts": {
    ///              "type": "array",
    ///              "items": {
    ///                "$ref": "#/components/schemas/ClosedAccountWithOptionalTokenDataV2"
    ///              }
    ///            },
    ///            "openedAccounts": {
    ///              "type": "array",
    ///              "items": {
    ///                "$ref": "#/components/schemas/AccountWithOptionalTokenDataV2"
    ///              }
    ///            }
    ///          },
    ///          "additionalProperties": false
    ///        },
    ///        "transaction": {
    ///          "description": "An encoded confirmed transaction with status meta",
    ///          "type": "object"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetTransactionWithCompressionInfoV2Response {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<
            PostGetTransactionWithCompressionInfoV2ResponseError,
        >,
        ///An ID to identify the response.
        pub id: PostGetTransactionWithCompressionInfoV2ResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetTransactionWithCompressionInfoV2ResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<
            PostGetTransactionWithCompressionInfoV2ResponseResult,
        >,
    }
    impl PostGetTransactionWithCompressionInfoV2Response {
        pub fn builder() -> builder::PostGetTransactionWithCompressionInfoV2Response {
            Default::default()
        }
    }
    ///`PostGetTransactionWithCompressionInfoV2ResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetTransactionWithCompressionInfoV2ResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default
    for PostGetTransactionWithCompressionInfoV2ResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetTransactionWithCompressionInfoV2ResponseError {
        pub fn builder() -> builder::PostGetTransactionWithCompressionInfoV2ResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetTransactionWithCompressionInfoV2ResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetTransactionWithCompressionInfoV2ResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetTransactionWithCompressionInfoV2ResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetTransactionWithCompressionInfoV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetTransactionWithCompressionInfoV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetTransactionWithCompressionInfoV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetTransactionWithCompressionInfoV2ResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetTransactionWithCompressionInfoV2ResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetTransactionWithCompressionInfoV2ResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
    for PostGetTransactionWithCompressionInfoV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetTransactionWithCompressionInfoV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetTransactionWithCompressionInfoV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///A Solana transaction with additional compression information
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A Solana transaction with additional compression information",
    ///  "type": "object",
    ///  "properties": {
    ///    "compression_info": {
    ///      "type": "object",
    ///      "required": [
    ///        "closedAccounts",
    ///        "openedAccounts"
    ///      ],
    ///      "properties": {
    ///        "closedAccounts": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/ClosedAccountWithOptionalTokenDataV2"
    ///          }
    ///        },
    ///        "openedAccounts": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/AccountWithOptionalTokenDataV2"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    "transaction": {
    ///      "description": "An encoded confirmed transaction with status meta",
    ///      "type": "object"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetTransactionWithCompressionInfoV2ResponseResult {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub compression_info: ::std::option::Option<
            PostGetTransactionWithCompressionInfoV2ResponseResultCompressionInfo,
        >,
        ///An encoded confirmed transaction with status meta
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        pub transaction: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    }
    impl ::std::default::Default
    for PostGetTransactionWithCompressionInfoV2ResponseResult {
        fn default() -> Self {
            Self {
                compression_info: Default::default(),
                transaction: Default::default(),
            }
        }
    }
    impl PostGetTransactionWithCompressionInfoV2ResponseResult {
        pub fn builder() -> builder::PostGetTransactionWithCompressionInfoV2ResponseResult {
            Default::default()
        }
    }
    ///`PostGetTransactionWithCompressionInfoV2ResponseResultCompressionInfo`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "closedAccounts",
    ///    "openedAccounts"
    ///  ],
    ///  "properties": {
    ///    "closedAccounts": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ClosedAccountWithOptionalTokenDataV2"
    ///      }
    ///    },
    ///    "openedAccounts": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AccountWithOptionalTokenDataV2"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetTransactionWithCompressionInfoV2ResponseResultCompressionInfo {
        #[serde(rename = "closedAccounts")]
        pub closed_accounts: ::std::vec::Vec<ClosedAccountWithOptionalTokenDataV2>,
        #[serde(rename = "openedAccounts")]
        pub opened_accounts: ::std::vec::Vec<AccountWithOptionalTokenDataV2>,
    }
    impl PostGetTransactionWithCompressionInfoV2ResponseResultCompressionInfo {
        pub fn builder() -> builder::PostGetTransactionWithCompressionInfoV2ResponseResultCompressionInfo {
            Default::default()
        }
    }
    ///`PostGetValidityProofBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getValidityProof"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "properties": {
    ///        "hashes": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/Hash"
    ///          }
    ///        },
    ///        "newAddressesWithTrees": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/AddressWithTree"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetValidityProofBody {
        ///An ID to identify the request.
        pub id: PostGetValidityProofBodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetValidityProofBodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetValidityProofBodyMethod,
        pub params: PostGetValidityProofBodyParams,
    }
    impl PostGetValidityProofBody {
        pub fn builder() -> builder::PostGetValidityProofBody {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetValidityProofBodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetValidityProofBodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetValidityProofBodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetValidityProofBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PostGetValidityProofBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PostGetValidityProofBodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetValidityProofBodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetValidityProofBodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetValidityProofBodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetValidityProofBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetValidityProofBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetValidityProofBodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getValidityProof"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetValidityProofBodyMethod {
        #[serde(rename = "getValidityProof")]
        GetValidityProof,
    }
    impl ::std::fmt::Display for PostGetValidityProofBodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetValidityProof => f.write_str("getValidityProof"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetValidityProofBodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getValidityProof" => Ok(Self::GetValidityProof),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetValidityProofBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetValidityProofBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetValidityProofBodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetValidityProofBodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "hashes": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Hash"
    ///      }
    ///    },
    ///    "newAddressesWithTrees": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AddressWithTree"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetValidityProofBodyParams {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub hashes: ::std::vec::Vec<Hash>,
        #[serde(
            rename = "newAddressesWithTrees",
            default,
            skip_serializing_if = "::std::vec::Vec::is_empty"
        )]
        pub new_addresses_with_trees: ::std::vec::Vec<AddressWithTree>,
    }
    impl ::std::default::Default for PostGetValidityProofBodyParams {
        fn default() -> Self {
            Self {
                hashes: Default::default(),
                new_addresses_with_trees: Default::default(),
            }
        }
    }
    impl PostGetValidityProofBodyParams {
        pub fn builder() -> builder::PostGetValidityProofBodyParams {
            Default::default()
        }
    }
    ///`PostGetValidityProofResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/CompressedProofWithContext"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetValidityProofResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<PostGetValidityProofResponseError>,
        ///An ID to identify the response.
        pub id: PostGetValidityProofResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetValidityProofResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<PostGetValidityProofResponseResult>,
    }
    impl PostGetValidityProofResponse {
        pub fn builder() -> builder::PostGetValidityProofResponse {
            Default::default()
        }
    }
    ///`PostGetValidityProofResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetValidityProofResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetValidityProofResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetValidityProofResponseError {
        pub fn builder() -> builder::PostGetValidityProofResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetValidityProofResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetValidityProofResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetValidityProofResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetValidityProofResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetValidityProofResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetValidityProofResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetValidityProofResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetValidityProofResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetValidityProofResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetValidityProofResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetValidityProofResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetValidityProofResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetValidityProofResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/CompressedProofWithContext"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetValidityProofResponseResult {
        pub context: Context,
        pub value: CompressedProofWithContext,
    }
    impl PostGetValidityProofResponseResult {
        pub fn builder() -> builder::PostGetValidityProofResponseResult {
            Default::default()
        }
    }
    ///`PostGetValidityProofV2Body`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "An ID to identify the request.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "method": {
    ///      "description": "The name of the method to invoke.",
    ///      "type": "string",
    ///      "enum": [
    ///        "getValidityProofV2"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "properties": {
    ///        "hashes": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/Hash"
    ///          }
    ///        },
    ///        "newAddressesWithTrees": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/AddressWithTree"
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetValidityProofV2Body {
        ///An ID to identify the request.
        pub id: PostGetValidityProofV2BodyId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetValidityProofV2BodyJsonrpc,
        ///The name of the method to invoke.
        pub method: PostGetValidityProofV2BodyMethod,
        pub params: PostGetValidityProofV2BodyParams,
    }
    impl PostGetValidityProofV2Body {
        pub fn builder() -> builder::PostGetValidityProofV2Body {
            Default::default()
        }
    }
    ///An ID to identify the request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetValidityProofV2BodyId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetValidityProofV2BodyId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetValidityProofV2BodyId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetValidityProofV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetValidityProofV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetValidityProofV2BodyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetValidityProofV2BodyJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetValidityProofV2BodyJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetValidityProofV2BodyJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetValidityProofV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetValidityProofV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetValidityProofV2BodyJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The name of the method to invoke.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name of the method to invoke.",
    ///  "type": "string",
    ///  "enum": [
    ///    "getValidityProofV2"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetValidityProofV2BodyMethod {
        #[serde(rename = "getValidityProofV2")]
        GetValidityProofV2,
    }
    impl ::std::fmt::Display for PostGetValidityProofV2BodyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GetValidityProofV2 => f.write_str("getValidityProofV2"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetValidityProofV2BodyMethod {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "getValidityProofV2" => Ok(Self::GetValidityProofV2),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetValidityProofV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetValidityProofV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetValidityProofV2BodyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetValidityProofV2BodyParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "hashes": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Hash"
    ///      }
    ///    },
    ///    "newAddressesWithTrees": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AddressWithTree"
    ///      }
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetValidityProofV2BodyParams {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub hashes: ::std::vec::Vec<Hash>,
        #[serde(
            rename = "newAddressesWithTrees",
            default,
            skip_serializing_if = "::std::vec::Vec::is_empty"
        )]
        pub new_addresses_with_trees: ::std::vec::Vec<AddressWithTree>,
    }
    impl ::std::default::Default for PostGetValidityProofV2BodyParams {
        fn default() -> Self {
            Self {
                hashes: Default::default(),
                new_addresses_with_trees: Default::default(),
            }
        }
    }
    impl PostGetValidityProofV2BodyParams {
        pub fn builder() -> builder::PostGetValidityProofV2BodyParams {
            Default::default()
        }
    }
    ///`PostGetValidityProofV2Response`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "jsonrpc"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "object",
    ///      "properties": {
    ///        "code": {
    ///          "type": "integer"
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "description": "An ID to identify the response.",
    ///      "type": "string",
    ///      "enum": [
    ///        "test-account"
    ///      ]
    ///    },
    ///    "jsonrpc": {
    ///      "description": "The version of the JSON-RPC protocol.",
    ///      "type": "string",
    ///      "enum": [
    ///        "2.0"
    ///      ]
    ///    },
    ///    "result": {
    ///      "type": "object",
    ///      "required": [
    ///        "context",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "context": {
    ///          "$ref": "#/components/schemas/Context"
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/CompressedProofWithContextV2"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetValidityProofV2Response {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<PostGetValidityProofV2ResponseError>,
        ///An ID to identify the response.
        pub id: PostGetValidityProofV2ResponseId,
        ///The version of the JSON-RPC protocol.
        pub jsonrpc: PostGetValidityProofV2ResponseJsonrpc,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub result: ::std::option::Option<PostGetValidityProofV2ResponseResult>,
    }
    impl PostGetValidityProofV2Response {
        pub fn builder() -> builder::PostGetValidityProofV2Response {
            Default::default()
        }
    }
    ///`PostGetValidityProofV2ResponseError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "code": {
    ///      "type": "integer"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct PostGetValidityProofV2ResponseError {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub code: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub message: ::std::option::Option<::std::string::String>,
    }
    impl ::std::default::Default for PostGetValidityProofV2ResponseError {
        fn default() -> Self {
            Self {
                code: Default::default(),
                message: Default::default(),
            }
        }
    }
    impl PostGetValidityProofV2ResponseError {
        pub fn builder() -> builder::PostGetValidityProofV2ResponseError {
            Default::default()
        }
    }
    ///An ID to identify the response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An ID to identify the response.",
    ///  "type": "string",
    ///  "enum": [
    ///    "test-account"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetValidityProofV2ResponseId {
        #[serde(rename = "test-account")]
        TestAccount,
    }
    impl ::std::fmt::Display for PostGetValidityProofV2ResponseId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TestAccount => f.write_str("test-account"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetValidityProofV2ResponseId {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "test-account" => Ok(Self::TestAccount),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetValidityProofV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetValidityProofV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetValidityProofV2ResponseId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///The version of the JSON-RPC protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The version of the JSON-RPC protocol.",
    ///  "type": "string",
    ///  "enum": [
    ///    "2.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    pub enum PostGetValidityProofV2ResponseJsonrpc {
        #[serde(rename = "2.0")]
        X20,
    }
    impl ::std::fmt::Display for PostGetValidityProofV2ResponseJsonrpc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X20 => f.write_str("2.0"),
            }
        }
    }
    impl ::std::str::FromStr for PostGetValidityProofV2ResponseJsonrpc {
        type Err = self::error::ConversionError;
        fn from_str(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "2.0" => Ok(Self::X20),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PostGetValidityProofV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &str,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
    for PostGetValidityProofV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
    for PostGetValidityProofV2ResponseJsonrpc {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    ///`PostGetValidityProofV2ResponseResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "context",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "context": {
    ///      "$ref": "#/components/schemas/Context"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/CompressedProofWithContextV2"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PostGetValidityProofV2ResponseResult {
        pub context: Context,
        pub value: CompressedProofWithContextV2,
    }
    impl PostGetValidityProofV2ResponseResult {
        pub fn builder() -> builder::PostGetValidityProofV2ResponseResult {
            Default::default()
        }
    }
    ///`QueueInfo`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "queue",
    ///    "queueSize",
    ///    "queueType",
    ///    "tree"
    ///  ],
    ///  "properties": {
    ///    "queue": {
    ///      "type": "string"
    ///    },
    ///    "queueSize": {
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "queueType": {
    ///      "type": "integer",
    ///      "format": "uint8",
    ///      "minimum": 0.0
    ///    },
    ///    "tree": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct QueueInfo {
        pub queue: ::std::string::String,
        #[serde(rename = "queueSize")]
        pub queue_size: u64,
        #[serde(rename = "queueType")]
        pub queue_type: u8,
        pub tree: ::std::string::String,
    }
    impl QueueInfo {
        pub fn builder() -> builder::QueueInfo {
            Default::default()
        }
    }
    ///Parameters for requesting queue elements
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Parameters for requesting queue elements",
    ///  "type": "object",
    ///  "required": [
    ///    "limit"
    ///  ],
    ///  "properties": {
    ///    "limit": {
    ///      "type": "integer",
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    },
    ///    "startIndex": {
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "zkpBatchSize": {
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct QueueRequest {
        pub limit: u16,
        #[serde(
            rename = "startIndex",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub start_index: ::std::option::Option<u64>,
        #[serde(
            rename = "zkpBatchSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub zkp_batch_size: ::std::option::Option<u16>,
    }
    impl QueueRequest {
        pub fn builder() -> builder::QueueRequest {
            Default::default()
        }
    }
    ///`RootIndex`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "proveByIndex",
    ///    "rootIndex"
    ///  ],
    ///  "properties": {
    ///    "proveByIndex": {
    ///      "type": "boolean"
    ///    },
    ///    "rootIndex": {
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct RootIndex {
        #[serde(rename = "proveByIndex")]
        pub prove_by_index: bool,
        #[serde(rename = "rootIndex")]
        pub root_index: u64,
    }
    impl RootIndex {
        pub fn builder() -> builder::RootIndex {
            Default::default()
        }
    }
    ///A Solana public key represented as a base58 string.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A Solana public key represented as a base58 string.",
    ///  "default": "111FJo4zLAGU9nzTWa6EnbV4VAmtG4FR8kcokrtZYr",
    ///  "examples": [
    ///    "111FJo4zLAGU9nzTWa6EnbV4VAmtG4FR8kcokrtZYr"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    #[serde(transparent)]
    pub struct SerializablePubkey(pub ::std::string::String);
    impl ::std::ops::Deref for SerializablePubkey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SerializablePubkey> for ::std::string::String {
        fn from(value: SerializablePubkey) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<::std::string::String> for SerializablePubkey {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }
    impl ::std::str::FromStr for SerializablePubkey {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::fmt::Display for SerializablePubkey {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    ///A Solana transaction signature.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A Solana transaction signature.",
    ///  "default": "5J8H5sTvEhnGcB4R8K1n7mfoiWUD9RzPVGES7e3WxC7c",
    ///  "examples": [
    ///    "5J8H5sTvEhnGcB4R8K1n7mfoiWUD9RzPVGES7e3WxC7c"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd
    )]
    #[serde(transparent)]
    pub struct SerializableSignature(pub ::std::string::String);
    impl ::std::ops::Deref for SerializableSignature {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SerializableSignature> for ::std::string::String {
        fn from(value: SerializableSignature) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<::std::string::String> for SerializableSignature {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }
    impl ::std::str::FromStr for SerializableSignature {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::fmt::Display for SerializableSignature {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    ///`SignatureInfo`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "blockTime",
    ///    "signature",
    ///    "slot"
    ///  ],
    ///  "properties": {
    ///    "blockTime": {
    ///      "$ref": "#/components/schemas/UnixTimestamp"
    ///    },
    ///    "signature": {
    ///      "$ref": "#/components/schemas/SerializableSignature"
    ///    },
    ///    "slot": {
    ///      "$ref": "#/components/schemas/UnsignedInteger"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignatureInfo {
        #[serde(rename = "blockTime")]
        pub block_time: UnixTimestamp,
        pub signature: SerializableSignature,
        pub slot: UnsignedInteger,
    }
    impl SignatureInfo {
        pub fn builder() -> builder::SignatureInfo {
            Default::default()
        }
    }
    ///`SignatureInfoList`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SignatureInfo"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignatureInfoList {
        pub items: ::std::vec::Vec<SignatureInfo>,
    }
    impl SignatureInfoList {
        pub fn builder() -> builder::SignatureInfoList {
            Default::default()
        }
    }
    ///`SignatureInfoListWithError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SignatureInfoWithError"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignatureInfoListWithError {
        pub items: ::std::vec::Vec<SignatureInfoWithError>,
    }
    impl SignatureInfoListWithError {
        pub fn builder() -> builder::SignatureInfoListWithError {
            Default::default()
        }
    }
    ///`SignatureInfoWithError`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "blockTime",
    ///    "signature",
    ///    "slot"
    ///  ],
    ///  "properties": {
    ///    "blockTime": {
    ///      "$ref": "#/components/schemas/UnixTimestamp"
    ///    },
    ///    "error": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "signature": {
    ///      "$ref": "#/components/schemas/SerializableSignature"
    ///    },
    ///    "slot": {
    ///      "$ref": "#/components/schemas/UnsignedInteger"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SignatureInfoWithError {
        #[serde(rename = "blockTime")]
        pub block_time: UnixTimestamp,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<::std::string::String>,
        pub signature: SerializableSignature,
        pub slot: UnsignedInteger,
    }
    impl SignatureInfoWithError {
        pub fn builder() -> builder::SignatureInfoWithError {
            Default::default()
        }
    }
    ///Nested Solana account fields (matches getAccountInfo shape)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Nested Solana account fields (matches getAccountInfo shape)",
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "executable",
    ///    "lamports",
    ///    "owner",
    ///    "rentEpoch",
    ///    "space"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "$ref": "#/components/schemas/Base64String"
    ///    },
    ///    "executable": {
    ///      "type": "boolean"
    ///    },
    ///    "lamports": {
    ///      "$ref": "#/components/schemas/UnsignedInteger"
    ///    },
    ///    "owner": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "rentEpoch": {
    ///      "$ref": "#/components/schemas/UnsignedInteger"
    ///    },
    ///    "space": {
    ///      "$ref": "#/components/schemas/UnsignedInteger"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct SolanaAccountData {
        pub data: Base64String,
        pub executable: bool,
        pub lamports: UnsignedInteger,
        pub owner: SerializablePubkey,
        #[serde(rename = "rentEpoch")]
        pub rent_epoch: UnsignedInteger,
        pub space: UnsignedInteger,
    }
    impl SolanaAccountData {
        pub fn builder() -> builder::SolanaAccountData {
            Default::default()
        }
    }
    ///State queue data with shared tree nodes for output and input queues
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "State queue data with shared tree nodes for output and input queues",
    ///  "type": "object",
    ///  "required": [
    ///    "initialRoot",
    ///    "rootSeq"
    ///  ],
    ///  "properties": {
    ///    "initialRoot": {
    ///      "$ref": "#/components/schemas/Hash"
    ///    },
    ///    "inputQueue": {
    ///      "$ref": "#/components/schemas/InputQueueData"
    ///    },
    ///    "nodes": {
    ///      "description": "Shared deduplicated tree nodes for state queues (output + input)",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Node"
    ///      }
    ///    },
    ///    "outputQueue": {
    ///      "$ref": "#/components/schemas/OutputQueueData"
    ///    },
    ///    "rootSeq": {
    ///      "description": "Sequence number of the root",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct StateQueueData {
        #[serde(rename = "initialRoot")]
        pub initial_root: Hash,
        #[serde(
            rename = "inputQueue",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub input_queue: ::std::option::Option<InputQueueData>,
        ///Shared deduplicated tree nodes for state queues (output + input)
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub nodes: ::std::vec::Vec<Node>,
        #[serde(
            rename = "outputQueue",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub output_queue: ::std::option::Option<OutputQueueData>,
        ///Sequence number of the root
        #[serde(rename = "rootSeq")]
        pub root_seq: u64,
    }
    impl StateQueueData {
        pub fn builder() -> builder::StateQueueData {
            Default::default()
        }
    }
    ///`TokenAccount`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "account",
    ///    "tokenData"
    ///  ],
    ///  "properties": {
    ///    "account": {
    ///      "$ref": "#/components/schemas/Account"
    ///    },
    ///    "tokenData": {
    ///      "$ref": "#/components/schemas/TokenData"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct TokenAccount {
        pub account: Account,
        #[serde(rename = "tokenData")]
        pub token_data: TokenData,
    }
    impl TokenAccount {
        pub fn builder() -> builder::TokenAccount {
            Default::default()
        }
    }
    ///`TokenAccountBalance`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/UnsignedInteger"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct TokenAccountBalance {
        pub amount: UnsignedInteger,
    }
    impl TokenAccountBalance {
        pub fn builder() -> builder::TokenAccountBalance {
            Default::default()
        }
    }
    ///`TokenAccountList`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "cursor": {
    ///      "$ref": "#/components/schemas/Base58String"
    ///    },
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TokenAccount"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TokenAccountList {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<Base58String>,
        pub items: ::std::vec::Vec<TokenAccount>,
    }
    impl TokenAccountList {
        pub fn builder() -> builder::TokenAccountList {
            Default::default()
        }
    }
    ///`TokenAccountListV2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "cursor": {
    ///      "$ref": "#/components/schemas/Base58String"
    ///    },
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TokenAccountV2"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TokenAccountListV2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<Base58String>,
        pub items: ::std::vec::Vec<TokenAccountV2>,
    }
    impl TokenAccountListV2 {
        pub fn builder() -> builder::TokenAccountListV2 {
            Default::default()
        }
    }
    ///`TokenAccountV2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "account",
    ///    "tokenData"
    ///  ],
    ///  "properties": {
    ///    "account": {
    ///      "$ref": "#/components/schemas/AccountV2"
    ///    },
    ///    "tokenData": {
    ///      "$ref": "#/components/schemas/TokenData"
    ///    }
    ///  },
    ///  "additionalProperties": false
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct TokenAccountV2 {
        pub account: AccountV2,
        #[serde(rename = "tokenData")]
        pub token_data: TokenData,
    }
    impl TokenAccountV2 {
        pub fn builder() -> builder::TokenAccountV2 {
            Default::default()
        }
    }
    ///`TokenBalance`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "balance",
    ///    "mint"
    ///  ],
    ///  "properties": {
    ///    "balance": {
    ///      "$ref": "#/components/schemas/UnsignedInteger"
    ///    },
    ///    "mint": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TokenBalance {
        pub balance: UnsignedInteger,
        pub mint: SerializablePubkey,
    }
    impl TokenBalance {
        pub fn builder() -> builder::TokenBalance {
            Default::default()
        }
    }
    ///`TokenBalanceList`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "token_balances"
    ///  ],
    ///  "properties": {
    ///    "cursor": {
    ///      "$ref": "#/components/schemas/Base58String"
    ///    },
    ///    "token_balances": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TokenBalance"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TokenBalanceList {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<Base58String>,
        pub token_balances: ::std::vec::Vec<TokenBalance>,
    }
    impl TokenBalanceList {
        pub fn builder() -> builder::TokenBalanceList {
            Default::default()
        }
    }
    ///`TokenBalanceListV2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "cursor": {
    ///      "$ref": "#/components/schemas/Base58String"
    ///    },
    ///    "items": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TokenBalance"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TokenBalanceListV2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cursor: ::std::option::Option<Base58String>,
        pub items: ::std::vec::Vec<TokenBalance>,
    }
    impl TokenBalanceListV2 {
        pub fn builder() -> builder::TokenBalanceListV2 {
            Default::default()
        }
    }
    ///`TokenData`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "mint",
    ///    "owner",
    ///    "state"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "$ref": "#/components/schemas/UnsignedInteger"
    ///    },
    ///    "delegate": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "mint": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "owner": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "state": {
    ///      "$ref": "#/components/schemas/AccountState"
    ///    },
    ///    "tlv": {
    ///      "$ref": "#/components/schemas/Base64String"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TokenData {
        pub amount: UnsignedInteger,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub delegate: ::std::option::Option<SerializablePubkey>,
        pub mint: SerializablePubkey,
        pub owner: SerializablePubkey,
        pub state: AccountState,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub tlv: ::std::option::Option<Base64String>,
    }
    impl TokenData {
        pub fn builder() -> builder::TokenData {
            Default::default()
        }
    }
    ///`TreeContextInfo`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "queue",
    ///    "tree",
    ///    "treeType"
    ///  ],
    ///  "properties": {
    ///    "cpiContext": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "queue": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "tree": {
    ///      "$ref": "#/components/schemas/SerializablePubkey"
    ///    },
    ///    "treeType": {
    ///      "type": "integer",
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TreeContextInfo {
        #[serde(
            rename = "cpiContext",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub cpi_context: ::std::option::Option<SerializablePubkey>,
        pub queue: SerializablePubkey,
        pub tree: SerializablePubkey,
        #[serde(rename = "treeType")]
        pub tree_type: u16,
    }
    impl TreeContextInfo {
        pub fn builder() -> builder::TreeContextInfo {
            Default::default()
        }
    }
    ///An Unix timestamp (seconds)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "An Unix timestamp (seconds)",
    ///  "default": 1714081554,
    ///  "examples": [
    ///    1714081554
    ///  ],
    ///  "type": "integer"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct UnixTimestamp(pub i64);
    impl ::std::ops::Deref for UnixTimestamp {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }
    impl ::std::convert::From<UnixTimestamp> for i64 {
        fn from(value: UnixTimestamp) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<i64> for UnixTimestamp {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }
    impl ::std::str::FromStr for UnixTimestamp {
        type Err = <i64 as ::std::str::FromStr>::Err;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }
    impl ::std::convert::TryFrom<&str> for UnixTimestamp {
        type Error = <i64 as ::std::str::FromStr>::Err;
        fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for UnixTimestamp {
        type Error = <i64 as ::std::str::FromStr>::Err;
        fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }
    impl ::std::fmt::Display for UnixTimestamp {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    ///`UnsignedInteger`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "default": 100,
    ///  "examples": [
    ///    100
    ///  ],
    ///  "type": "integer",
    ///  "format": "uint64"
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct UnsignedInteger(pub u64);
    impl ::std::ops::Deref for UnsignedInteger {
        type Target = u64;
        fn deref(&self) -> &u64 {
            &self.0
        }
    }
    impl ::std::convert::From<UnsignedInteger> for u64 {
        fn from(value: UnsignedInteger) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<u64> for UnsignedInteger {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }
    impl ::std::str::FromStr for UnsignedInteger {
        type Err = <u64 as ::std::str::FromStr>::Err;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }
    impl ::std::convert::TryFrom<&str> for UnsignedInteger {
        type Error = <u64 as ::std::str::FromStr>::Err;
        fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<String> for UnsignedInteger {
        type Error = <u64 as ::std::str::FromStr>::Err;
        fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }
    impl ::std::fmt::Display for UnsignedInteger {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    /// Types for composing complex structures.
    pub mod builder {
        #[derive(Clone, Debug)]
        pub struct Account {
            address: ::std::result::Result<
                ::std::option::Option<super::SerializablePubkey>,
                ::std::string::String,
            >,
            data: ::std::result::Result<
                ::std::option::Option<super::AccountData>,
                ::std::string::String,
            >,
            hash: ::std::result::Result<super::Hash, ::std::string::String>,
            lamports: ::std::result::Result<
                super::UnsignedInteger,
                ::std::string::String,
            >,
            leaf_index: ::std::result::Result<
                super::UnsignedInteger,
                ::std::string::String,
            >,
            owner: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
            seq: ::std::result::Result<
                ::std::option::Option<super::UnsignedInteger>,
                ::std::string::String,
            >,
            slot_created: ::std::result::Result<
                super::UnsignedInteger,
                ::std::string::String,
            >,
            tree: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for Account {
            fn default() -> Self {
                Self {
                    address: Ok(Default::default()),
                    data: Ok(Default::default()),
                    hash: Err("no value supplied for hash".to_string()),
                    lamports: Err("no value supplied for lamports".to_string()),
                    leaf_index: Err("no value supplied for leaf_index".to_string()),
                    owner: Err("no value supplied for owner".to_string()),
                    seq: Ok(Default::default()),
                    slot_created: Err("no value supplied for slot_created".to_string()),
                    tree: Err("no value supplied for tree".to_string()),
                }
            }
        }
        impl Account {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::SerializablePubkey>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {e}")
                    });
                self
            }
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::AccountData>>,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for data: {e}")
                    });
                self
            }
            pub fn hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Hash>,
                T::Error: ::std::fmt::Display,
            {
                self.hash = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for hash: {e}")
                    });
                self
            }
            pub fn lamports<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UnsignedInteger>,
                T::Error: ::std::fmt::Display,
            {
                self.lamports = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for lamports: {e}")
                    });
                self
            }
            pub fn leaf_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UnsignedInteger>,
                T::Error: ::std::fmt::Display,
            {
                self.leaf_index = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for leaf_index: {e}")
                    });
                self
            }
            pub fn owner<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.owner = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for owner: {e}")
                    });
                self
            }
            pub fn seq<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::UnsignedInteger>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.seq = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for seq: {e}")
                    });
                self
            }
            pub fn slot_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UnsignedInteger>,
                T::Error: ::std::fmt::Display,
            {
                self.slot_created = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for slot_created: {e}")
                    });
                self
            }
            pub fn tree<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.tree = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for tree: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<Account> for super::Account {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Account,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    data: value.data?,
                    hash: value.hash?,
                    lamports: value.lamports?,
                    leaf_index: value.leaf_index?,
                    owner: value.owner?,
                    seq: value.seq?,
                    slot_created: value.slot_created?,
                    tree: value.tree?,
                })
            }
        }
        impl ::std::convert::From<super::Account> for Account {
            fn from(value: super::Account) -> Self {
                Self {
                    address: Ok(value.address),
                    data: Ok(value.data),
                    hash: Ok(value.hash),
                    lamports: Ok(value.lamports),
                    leaf_index: Ok(value.leaf_index),
                    owner: Ok(value.owner),
                    seq: Ok(value.seq),
                    slot_created: Ok(value.slot_created),
                    tree: Ok(value.tree),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountContext {
            in_output_queue: ::std::result::Result<bool, ::std::string::String>,
            nullified_in_tree: ::std::result::Result<bool, ::std::string::String>,
            nullifier: ::std::result::Result<
                ::std::option::Option<super::Hash>,
                ::std::string::String,
            >,
            nullifier_queue_index: ::std::result::Result<
                ::std::option::Option<super::UnsignedInteger>,
                ::std::string::String,
            >,
            queue: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
            spent: ::std::result::Result<bool, ::std::string::String>,
            tree_type: ::std::result::Result<u16, ::std::string::String>,
            tx_hash: ::std::result::Result<
                ::std::option::Option<super::Hash>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for AccountContext {
            fn default() -> Self {
                Self {
                    in_output_queue: Err(
                        "no value supplied for in_output_queue".to_string(),
                    ),
                    nullified_in_tree: Err(
                        "no value supplied for nullified_in_tree".to_string(),
                    ),
                    nullifier: Ok(Default::default()),
                    nullifier_queue_index: Ok(Default::default()),
                    queue: Err("no value supplied for queue".to_string()),
                    spent: Err("no value supplied for spent".to_string()),
                    tree_type: Err("no value supplied for tree_type".to_string()),
                    tx_hash: Ok(Default::default()),
                }
            }
        }
        impl AccountContext {
            pub fn in_output_queue<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.in_output_queue = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for in_output_queue: {e}"
                        )
                    });
                self
            }
            pub fn nullified_in_tree<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.nullified_in_tree = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for nullified_in_tree: {e}"
                        )
                    });
                self
            }
            pub fn nullifier<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.nullifier = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for nullifier: {e}")
                    });
                self
            }
            pub fn nullifier_queue_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::UnsignedInteger>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.nullifier_queue_index = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for nullifier_queue_index: {e}"
                        )
                    });
                self
            }
            pub fn queue<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.queue = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for queue: {e}")
                    });
                self
            }
            pub fn spent<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.spent = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for spent: {e}")
                    });
                self
            }
            pub fn tree_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u16>,
                T::Error: ::std::fmt::Display,
            {
                self.tree_type = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for tree_type: {e}")
                    });
                self
            }
            pub fn tx_hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.tx_hash = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for tx_hash: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<AccountContext> for super::AccountContext {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountContext,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    in_output_queue: value.in_output_queue?,
                    nullified_in_tree: value.nullified_in_tree?,
                    nullifier: value.nullifier?,
                    nullifier_queue_index: value.nullifier_queue_index?,
                    queue: value.queue?,
                    spent: value.spent?,
                    tree_type: value.tree_type?,
                    tx_hash: value.tx_hash?,
                })
            }
        }
        impl ::std::convert::From<super::AccountContext> for AccountContext {
            fn from(value: super::AccountContext) -> Self {
                Self {
                    in_output_queue: Ok(value.in_output_queue),
                    nullified_in_tree: Ok(value.nullified_in_tree),
                    nullifier: Ok(value.nullifier),
                    nullifier_queue_index: Ok(value.nullifier_queue_index),
                    queue: Ok(value.queue),
                    spent: Ok(value.spent),
                    tree_type: Ok(value.tree_type),
                    tx_hash: Ok(value.tx_hash),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountData {
            data: ::std::result::Result<super::Base64String, ::std::string::String>,
            data_hash: ::std::result::Result<super::Hash, ::std::string::String>,
            discriminator: ::std::result::Result<
                super::UnsignedInteger,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for AccountData {
            fn default() -> Self {
                Self {
                    data: Err("no value supplied for data".to_string()),
                    data_hash: Err("no value supplied for data_hash".to_string()),
                    discriminator: Err("no value supplied for discriminator".to_string()),
                }
            }
        }
        impl AccountData {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Base64String>,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for data: {e}")
                    });
                self
            }
            pub fn data_hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Hash>,
                T::Error: ::std::fmt::Display,
            {
                self.data_hash = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for data_hash: {e}")
                    });
                self
            }
            pub fn discriminator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UnsignedInteger>,
                T::Error: ::std::fmt::Display,
            {
                self.discriminator = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for discriminator: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<AccountData> for super::AccountData {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountData,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    data: value.data?,
                    data_hash: value.data_hash?,
                    discriminator: value.discriminator?,
                })
            }
        }
        impl ::std::convert::From<super::AccountData> for AccountData {
            fn from(value: super::AccountData) -> Self {
                Self {
                    data: Ok(value.data),
                    data_hash: Ok(value.data_hash),
                    discriminator: Ok(value.discriminator),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountInterface {
            account: ::std::result::Result<
                super::SolanaAccountData,
                ::std::string::String,
            >,
            cold: ::std::result::Result<
                ::std::option::Option<::std::vec::Vec<super::AccountV2>>,
                ::std::string::String,
            >,
            key: ::std::result::Result<super::SerializablePubkey, ::std::string::String>,
        }
        impl ::std::default::Default for AccountInterface {
            fn default() -> Self {
                Self {
                    account: Err("no value supplied for account".to_string()),
                    cold: Ok(Default::default()),
                    key: Err("no value supplied for key".to_string()),
                }
            }
        }
        impl AccountInterface {
            pub fn account<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaAccountData>,
                T::Error: ::std::fmt::Display,
            {
                self.account = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for account: {e}")
                    });
                self
            }
            pub fn cold<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<::std::vec::Vec<super::AccountV2>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.cold = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cold: {e}")
                    });
                self
            }
            pub fn key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.key = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for key: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<AccountInterface> for super::AccountInterface {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountInterface,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account: value.account?,
                    cold: value.cold?,
                    key: value.key?,
                })
            }
        }
        impl ::std::convert::From<super::AccountInterface> for AccountInterface {
            fn from(value: super::AccountInterface) -> Self {
                Self {
                    account: Ok(value.account),
                    cold: Ok(value.cold),
                    key: Ok(value.key),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountList {
            items: ::std::result::Result<
                ::std::vec::Vec<::std::option::Option<super::Account>>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for AccountList {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                }
            }
        }
        impl AccountList {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<::std::option::Option<super::Account>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<AccountList> for super::AccountList {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountList,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { items: value.items? })
            }
        }
        impl ::std::convert::From<super::AccountList> for AccountList {
            fn from(value: super::AccountList) -> Self {
                Self { items: Ok(value.items) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountListV2 {
            items: ::std::result::Result<
                ::std::vec::Vec<::std::option::Option<super::AccountV2>>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for AccountListV2 {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                }
            }
        }
        impl AccountListV2 {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<::std::option::Option<super::AccountV2>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<AccountListV2> for super::AccountListV2 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountListV2,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { items: value.items? })
            }
        }
        impl ::std::convert::From<super::AccountListV2> for AccountListV2 {
            fn from(value: super::AccountListV2) -> Self {
                Self { items: Ok(value.items) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountProofInputs {
            hash: ::std::result::Result<::std::string::String, ::std::string::String>,
            leaf_index: ::std::result::Result<u64, ::std::string::String>,
            merkle_context: ::std::result::Result<
                super::MerkleContextV2,
                ::std::string::String,
            >,
            root: ::std::result::Result<::std::string::String, ::std::string::String>,
            root_index: ::std::result::Result<super::RootIndex, ::std::string::String>,
        }
        impl ::std::default::Default for AccountProofInputs {
            fn default() -> Self {
                Self {
                    hash: Err("no value supplied for hash".to_string()),
                    leaf_index: Err("no value supplied for leaf_index".to_string()),
                    merkle_context: Err(
                        "no value supplied for merkle_context".to_string(),
                    ),
                    root: Err("no value supplied for root".to_string()),
                    root_index: Err("no value supplied for root_index".to_string()),
                }
            }
        }
        impl AccountProofInputs {
            pub fn hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.hash = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for hash: {e}")
                    });
                self
            }
            pub fn leaf_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.leaf_index = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for leaf_index: {e}")
                    });
                self
            }
            pub fn merkle_context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::MerkleContextV2>,
                T::Error: ::std::fmt::Display,
            {
                self.merkle_context = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for merkle_context: {e}"
                        )
                    });
                self
            }
            pub fn root<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.root = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for root: {e}")
                    });
                self
            }
            pub fn root_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::RootIndex>,
                T::Error: ::std::fmt::Display,
            {
                self.root_index = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for root_index: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<AccountProofInputs> for super::AccountProofInputs {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountProofInputs,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    hash: value.hash?,
                    leaf_index: value.leaf_index?,
                    merkle_context: value.merkle_context?,
                    root: value.root?,
                    root_index: value.root_index?,
                })
            }
        }
        impl ::std::convert::From<super::AccountProofInputs> for AccountProofInputs {
            fn from(value: super::AccountProofInputs) -> Self {
                Self {
                    hash: Ok(value.hash),
                    leaf_index: Ok(value.leaf_index),
                    merkle_context: Ok(value.merkle_context),
                    root: Ok(value.root),
                    root_index: Ok(value.root_index),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountV2 {
            address: ::std::result::Result<
                ::std::option::Option<super::SerializablePubkey>,
                ::std::string::String,
            >,
            data: ::std::result::Result<
                ::std::option::Option<super::AccountData>,
                ::std::string::String,
            >,
            hash: ::std::result::Result<super::Hash, ::std::string::String>,
            lamports: ::std::result::Result<
                super::UnsignedInteger,
                ::std::string::String,
            >,
            leaf_index: ::std::result::Result<
                super::UnsignedInteger,
                ::std::string::String,
            >,
            merkle_context: ::std::result::Result<
                super::MerkleContextV2,
                ::std::string::String,
            >,
            owner: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
            prove_by_index: ::std::result::Result<bool, ::std::string::String>,
            seq: ::std::result::Result<
                ::std::option::Option<super::UnsignedInteger>,
                ::std::string::String,
            >,
            slot_created: ::std::result::Result<
                super::UnsignedInteger,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for AccountV2 {
            fn default() -> Self {
                Self {
                    address: Ok(Default::default()),
                    data: Ok(Default::default()),
                    hash: Err("no value supplied for hash".to_string()),
                    lamports: Err("no value supplied for lamports".to_string()),
                    leaf_index: Err("no value supplied for leaf_index".to_string()),
                    merkle_context: Err(
                        "no value supplied for merkle_context".to_string(),
                    ),
                    owner: Err("no value supplied for owner".to_string()),
                    prove_by_index: Err(
                        "no value supplied for prove_by_index".to_string(),
                    ),
                    seq: Ok(Default::default()),
                    slot_created: Err("no value supplied for slot_created".to_string()),
                }
            }
        }
        impl AccountV2 {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::SerializablePubkey>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {e}")
                    });
                self
            }
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::AccountData>>,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for data: {e}")
                    });
                self
            }
            pub fn hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Hash>,
                T::Error: ::std::fmt::Display,
            {
                self.hash = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for hash: {e}")
                    });
                self
            }
            pub fn lamports<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UnsignedInteger>,
                T::Error: ::std::fmt::Display,
            {
                self.lamports = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for lamports: {e}")
                    });
                self
            }
            pub fn leaf_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UnsignedInteger>,
                T::Error: ::std::fmt::Display,
            {
                self.leaf_index = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for leaf_index: {e}")
                    });
                self
            }
            pub fn merkle_context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::MerkleContextV2>,
                T::Error: ::std::fmt::Display,
            {
                self.merkle_context = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for merkle_context: {e}"
                        )
                    });
                self
            }
            pub fn owner<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.owner = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for owner: {e}")
                    });
                self
            }
            pub fn prove_by_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.prove_by_index = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for prove_by_index: {e}"
                        )
                    });
                self
            }
            pub fn seq<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::UnsignedInteger>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.seq = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for seq: {e}")
                    });
                self
            }
            pub fn slot_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UnsignedInteger>,
                T::Error: ::std::fmt::Display,
            {
                self.slot_created = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for slot_created: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<AccountV2> for super::AccountV2 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountV2,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    data: value.data?,
                    hash: value.hash?,
                    lamports: value.lamports?,
                    leaf_index: value.leaf_index?,
                    merkle_context: value.merkle_context?,
                    owner: value.owner?,
                    prove_by_index: value.prove_by_index?,
                    seq: value.seq?,
                    slot_created: value.slot_created?,
                })
            }
        }
        impl ::std::convert::From<super::AccountV2> for AccountV2 {
            fn from(value: super::AccountV2) -> Self {
                Self {
                    address: Ok(value.address),
                    data: Ok(value.data),
                    hash: Ok(value.hash),
                    lamports: Ok(value.lamports),
                    leaf_index: Ok(value.leaf_index),
                    merkle_context: Ok(value.merkle_context),
                    owner: Ok(value.owner),
                    prove_by_index: Ok(value.prove_by_index),
                    seq: Ok(value.seq),
                    slot_created: Ok(value.slot_created),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountWithContext {
            account: ::std::result::Result<super::Account, ::std::string::String>,
            context: ::std::result::Result<super::AccountContext, ::std::string::String>,
        }
        impl ::std::default::Default for AccountWithContext {
            fn default() -> Self {
                Self {
                    account: Err("no value supplied for account".to_string()),
                    context: Err("no value supplied for context".to_string()),
                }
            }
        }
        impl AccountWithContext {
            pub fn account<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Account>,
                T::Error: ::std::fmt::Display,
            {
                self.account = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for account: {e}")
                    });
                self
            }
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AccountContext>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<AccountWithContext> for super::AccountWithContext {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountWithContext,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account: value.account?,
                    context: value.context?,
                })
            }
        }
        impl ::std::convert::From<super::AccountWithContext> for AccountWithContext {
            fn from(value: super::AccountWithContext) -> Self {
                Self {
                    account: Ok(value.account),
                    context: Ok(value.context),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountWithOptionalTokenData {
            account: ::std::result::Result<super::Account, ::std::string::String>,
            optional_token_data: ::std::result::Result<
                ::std::option::Option<super::TokenData>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for AccountWithOptionalTokenData {
            fn default() -> Self {
                Self {
                    account: Err("no value supplied for account".to_string()),
                    optional_token_data: Ok(Default::default()),
                }
            }
        }
        impl AccountWithOptionalTokenData {
            pub fn account<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Account>,
                T::Error: ::std::fmt::Display,
            {
                self.account = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for account: {e}")
                    });
                self
            }
            pub fn optional_token_data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::TokenData>>,
                T::Error: ::std::fmt::Display,
            {
                self.optional_token_data = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for optional_token_data: {e}"
                        )
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<AccountWithOptionalTokenData>
        for super::AccountWithOptionalTokenData {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountWithOptionalTokenData,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account: value.account?,
                    optional_token_data: value.optional_token_data?,
                })
            }
        }
        impl ::std::convert::From<super::AccountWithOptionalTokenData>
        for AccountWithOptionalTokenData {
            fn from(value: super::AccountWithOptionalTokenData) -> Self {
                Self {
                    account: Ok(value.account),
                    optional_token_data: Ok(value.optional_token_data),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AccountWithOptionalTokenDataV2 {
            account: ::std::result::Result<super::AccountV2, ::std::string::String>,
            optional_token_data: ::std::result::Result<
                ::std::option::Option<super::TokenData>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for AccountWithOptionalTokenDataV2 {
            fn default() -> Self {
                Self {
                    account: Err("no value supplied for account".to_string()),
                    optional_token_data: Ok(Default::default()),
                }
            }
        }
        impl AccountWithOptionalTokenDataV2 {
            pub fn account<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AccountV2>,
                T::Error: ::std::fmt::Display,
            {
                self.account = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for account: {e}")
                    });
                self
            }
            pub fn optional_token_data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::TokenData>>,
                T::Error: ::std::fmt::Display,
            {
                self.optional_token_data = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for optional_token_data: {e}"
                        )
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<AccountWithOptionalTokenDataV2>
        for super::AccountWithOptionalTokenDataV2 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AccountWithOptionalTokenDataV2,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account: value.account?,
                    optional_token_data: value.optional_token_data?,
                })
            }
        }
        impl ::std::convert::From<super::AccountWithOptionalTokenDataV2>
        for AccountWithOptionalTokenDataV2 {
            fn from(value: super::AccountWithOptionalTokenDataV2) -> Self {
                Self {
                    account: Ok(value.account),
                    optional_token_data: Ok(value.optional_token_data),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AddressProofInputs {
            address: ::std::result::Result<::std::string::String, ::std::string::String>,
            merkle_context: ::std::result::Result<
                super::MerkleContextV2,
                ::std::string::String,
            >,
            root: ::std::result::Result<::std::string::String, ::std::string::String>,
            root_index: ::std::result::Result<u16, ::std::string::String>,
        }
        impl ::std::default::Default for AddressProofInputs {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    merkle_context: Err(
                        "no value supplied for merkle_context".to_string(),
                    ),
                    root: Err("no value supplied for root".to_string()),
                    root_index: Err("no value supplied for root_index".to_string()),
                }
            }
        }
        impl AddressProofInputs {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {e}")
                    });
                self
            }
            pub fn merkle_context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::MerkleContextV2>,
                T::Error: ::std::fmt::Display,
            {
                self.merkle_context = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for merkle_context: {e}"
                        )
                    });
                self
            }
            pub fn root<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.root = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for root: {e}")
                    });
                self
            }
            pub fn root_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u16>,
                T::Error: ::std::fmt::Display,
            {
                self.root_index = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for root_index: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<AddressProofInputs> for super::AddressProofInputs {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AddressProofInputs,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    merkle_context: value.merkle_context?,
                    root: value.root?,
                    root_index: value.root_index?,
                })
            }
        }
        impl ::std::convert::From<super::AddressProofInputs> for AddressProofInputs {
            fn from(value: super::AddressProofInputs) -> Self {
                Self {
                    address: Ok(value.address),
                    merkle_context: Ok(value.merkle_context),
                    root: Ok(value.root),
                    root_index: Ok(value.root_index),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AddressQueueData {
            addresses: ::std::result::Result<
                ::std::vec::Vec<super::SerializablePubkey>,
                ::std::string::String,
            >,
            initial_root: ::std::result::Result<super::Hash, ::std::string::String>,
            leaves_hash_chains: ::std::result::Result<
                ::std::vec::Vec<super::Hash>,
                ::std::string::String,
            >,
            low_element_indices: ::std::result::Result<
                ::std::vec::Vec<u64>,
                ::std::string::String,
            >,
            low_element_next_indices: ::std::result::Result<
                ::std::vec::Vec<u64>,
                ::std::string::String,
            >,
            low_element_next_values: ::std::result::Result<
                ::std::vec::Vec<super::Hash>,
                ::std::string::String,
            >,
            low_element_values: ::std::result::Result<
                ::std::vec::Vec<super::Hash>,
                ::std::string::String,
            >,
            nodes: ::std::result::Result<
                ::std::vec::Vec<super::Node>,
                ::std::string::String,
            >,
            queue_indices: ::std::result::Result<
                ::std::vec::Vec<u64>,
                ::std::string::String,
            >,
            root_seq: ::std::result::Result<u64, ::std::string::String>,
            start_index: ::std::result::Result<u64, ::std::string::String>,
            subtrees: ::std::result::Result<
                ::std::vec::Vec<super::Hash>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for AddressQueueData {
            fn default() -> Self {
                Self {
                    addresses: Err("no value supplied for addresses".to_string()),
                    initial_root: Err("no value supplied for initial_root".to_string()),
                    leaves_hash_chains: Err(
                        "no value supplied for leaves_hash_chains".to_string(),
                    ),
                    low_element_indices: Err(
                        "no value supplied for low_element_indices".to_string(),
                    ),
                    low_element_next_indices: Err(
                        "no value supplied for low_element_next_indices".to_string(),
                    ),
                    low_element_next_values: Err(
                        "no value supplied for low_element_next_values".to_string(),
                    ),
                    low_element_values: Err(
                        "no value supplied for low_element_values".to_string(),
                    ),
                    nodes: Err("no value supplied for nodes".to_string()),
                    queue_indices: Err(
                        "no value supplied for queue_indices".to_string(),
                    ),
                    root_seq: Err("no value supplied for root_seq".to_string()),
                    start_index: Err("no value supplied for start_index".to_string()),
                    subtrees: Err("no value supplied for subtrees".to_string()),
                }
            }
        }
        impl AddressQueueData {
            pub fn addresses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SerializablePubkey>>,
                T::Error: ::std::fmt::Display,
            {
                self.addresses = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for addresses: {e}")
                    });
                self
            }
            pub fn initial_root<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Hash>,
                T::Error: ::std::fmt::Display,
            {
                self.initial_root = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for initial_root: {e}")
                    });
                self
            }
            pub fn leaves_hash_chains<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.leaves_hash_chains = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for leaves_hash_chains: {e}"
                        )
                    });
                self
            }
            pub fn low_element_indices<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<u64>>,
                T::Error: ::std::fmt::Display,
            {
                self.low_element_indices = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for low_element_indices: {e}"
                        )
                    });
                self
            }
            pub fn low_element_next_indices<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<u64>>,
                T::Error: ::std::fmt::Display,
            {
                self.low_element_next_indices = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for low_element_next_indices: {e}"
                        )
                    });
                self
            }
            pub fn low_element_next_values<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.low_element_next_values = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for low_element_next_values: {e}"
                        )
                    });
                self
            }
            pub fn low_element_values<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.low_element_values = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for low_element_values: {e}"
                        )
                    });
                self
            }
            pub fn nodes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Node>>,
                T::Error: ::std::fmt::Display,
            {
                self.nodes = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for nodes: {e}")
                    });
                self
            }
            pub fn queue_indices<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<u64>>,
                T::Error: ::std::fmt::Display,
            {
                self.queue_indices = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for queue_indices: {e}")
                    });
                self
            }
            pub fn root_seq<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.root_seq = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for root_seq: {e}")
                    });
                self
            }
            pub fn start_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.start_index = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for start_index: {e}")
                    });
                self
            }
            pub fn subtrees<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.subtrees = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for subtrees: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<AddressQueueData> for super::AddressQueueData {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AddressQueueData,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    addresses: value.addresses?,
                    initial_root: value.initial_root?,
                    leaves_hash_chains: value.leaves_hash_chains?,
                    low_element_indices: value.low_element_indices?,
                    low_element_next_indices: value.low_element_next_indices?,
                    low_element_next_values: value.low_element_next_values?,
                    low_element_values: value.low_element_values?,
                    nodes: value.nodes?,
                    queue_indices: value.queue_indices?,
                    root_seq: value.root_seq?,
                    start_index: value.start_index?,
                    subtrees: value.subtrees?,
                })
            }
        }
        impl ::std::convert::From<super::AddressQueueData> for AddressQueueData {
            fn from(value: super::AddressQueueData) -> Self {
                Self {
                    addresses: Ok(value.addresses),
                    initial_root: Ok(value.initial_root),
                    leaves_hash_chains: Ok(value.leaves_hash_chains),
                    low_element_indices: Ok(value.low_element_indices),
                    low_element_next_indices: Ok(value.low_element_next_indices),
                    low_element_next_values: Ok(value.low_element_next_values),
                    low_element_values: Ok(value.low_element_values),
                    nodes: Ok(value.nodes),
                    queue_indices: Ok(value.queue_indices),
                    root_seq: Ok(value.root_seq),
                    start_index: Ok(value.start_index),
                    subtrees: Ok(value.subtrees),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct AddressWithTree {
            address: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
            tree: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for AddressWithTree {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    tree: Err("no value supplied for tree".to_string()),
                }
            }
        }
        impl AddressWithTree {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {e}")
                    });
                self
            }
            pub fn tree<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.tree = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for tree: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<AddressWithTree> for super::AddressWithTree {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AddressWithTree,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    tree: value.tree?,
                })
            }
        }
        impl ::std::convert::From<super::AddressWithTree> for AddressWithTree {
            fn from(value: super::AddressWithTree) -> Self {
                Self {
                    address: Ok(value.address),
                    tree: Ok(value.tree),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ClosedAccountV2 {
            account: ::std::result::Result<super::AccountV2, ::std::string::String>,
            nullifier: ::std::result::Result<super::Hash, ::std::string::String>,
            tx_hash: ::std::result::Result<super::Hash, ::std::string::String>,
        }
        impl ::std::default::Default for ClosedAccountV2 {
            fn default() -> Self {
                Self {
                    account: Err("no value supplied for account".to_string()),
                    nullifier: Err("no value supplied for nullifier".to_string()),
                    tx_hash: Err("no value supplied for tx_hash".to_string()),
                }
            }
        }
        impl ClosedAccountV2 {
            pub fn account<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AccountV2>,
                T::Error: ::std::fmt::Display,
            {
                self.account = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for account: {e}")
                    });
                self
            }
            pub fn nullifier<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Hash>,
                T::Error: ::std::fmt::Display,
            {
                self.nullifier = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for nullifier: {e}")
                    });
                self
            }
            pub fn tx_hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Hash>,
                T::Error: ::std::fmt::Display,
            {
                self.tx_hash = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for tx_hash: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<ClosedAccountV2> for super::ClosedAccountV2 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ClosedAccountV2,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account: value.account?,
                    nullifier: value.nullifier?,
                    tx_hash: value.tx_hash?,
                })
            }
        }
        impl ::std::convert::From<super::ClosedAccountV2> for ClosedAccountV2 {
            fn from(value: super::ClosedAccountV2) -> Self {
                Self {
                    account: Ok(value.account),
                    nullifier: Ok(value.nullifier),
                    tx_hash: Ok(value.tx_hash),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ClosedAccountWithOptionalTokenDataV2 {
            account: ::std::result::Result<
                super::ClosedAccountV2,
                ::std::string::String,
            >,
            optional_token_data: ::std::result::Result<
                ::std::option::Option<super::TokenData>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ClosedAccountWithOptionalTokenDataV2 {
            fn default() -> Self {
                Self {
                    account: Err("no value supplied for account".to_string()),
                    optional_token_data: Ok(Default::default()),
                }
            }
        }
        impl ClosedAccountWithOptionalTokenDataV2 {
            pub fn account<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ClosedAccountV2>,
                T::Error: ::std::fmt::Display,
            {
                self.account = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for account: {e}")
                    });
                self
            }
            pub fn optional_token_data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::TokenData>>,
                T::Error: ::std::fmt::Display,
            {
                self.optional_token_data = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for optional_token_data: {e}"
                        )
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<ClosedAccountWithOptionalTokenDataV2>
        for super::ClosedAccountWithOptionalTokenDataV2 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ClosedAccountWithOptionalTokenDataV2,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account: value.account?,
                    optional_token_data: value.optional_token_data?,
                })
            }
        }
        impl ::std::convert::From<super::ClosedAccountWithOptionalTokenDataV2>
        for ClosedAccountWithOptionalTokenDataV2 {
            fn from(value: super::ClosedAccountWithOptionalTokenDataV2) -> Self {
                Self {
                    account: Ok(value.account),
                    optional_token_data: Ok(value.optional_token_data),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CompressedProof {
            a: ::std::result::Result<::std::vec::Vec<i64>, ::std::string::String>,
            b: ::std::result::Result<::std::vec::Vec<i64>, ::std::string::String>,
            c: ::std::result::Result<::std::vec::Vec<i64>, ::std::string::String>,
        }
        impl ::std::default::Default for CompressedProof {
            fn default() -> Self {
                Self {
                    a: Err("no value supplied for a".to_string()),
                    b: Err("no value supplied for b".to_string()),
                    c: Err("no value supplied for c".to_string()),
                }
            }
        }
        impl CompressedProof {
            pub fn a<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.a = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for a: {e}"));
                self
            }
            pub fn b<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.b = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for b: {e}"));
                self
            }
            pub fn c<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.c = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for c: {e}"));
                self
            }
        }
        impl ::std::convert::TryFrom<CompressedProof> for super::CompressedProof {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CompressedProof,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    a: value.a?,
                    b: value.b?,
                    c: value.c?,
                })
            }
        }
        impl ::std::convert::From<super::CompressedProof> for CompressedProof {
            fn from(value: super::CompressedProof) -> Self {
                Self {
                    a: Ok(value.a),
                    b: Ok(value.b),
                    c: Ok(value.c),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CompressedProofWithContext {
            compressed_proof: ::std::result::Result<
                super::CompressedProof,
                ::std::string::String,
            >,
            leaf_indices: ::std::result::Result<
                ::std::vec::Vec<u32>,
                ::std::string::String,
            >,
            leaves: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            merkle_trees: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            root_indices: ::std::result::Result<
                ::std::vec::Vec<u64>,
                ::std::string::String,
            >,
            roots: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CompressedProofWithContext {
            fn default() -> Self {
                Self {
                    compressed_proof: Err(
                        "no value supplied for compressed_proof".to_string(),
                    ),
                    leaf_indices: Err("no value supplied for leaf_indices".to_string()),
                    leaves: Err("no value supplied for leaves".to_string()),
                    merkle_trees: Err("no value supplied for merkle_trees".to_string()),
                    root_indices: Err("no value supplied for root_indices".to_string()),
                    roots: Err("no value supplied for roots".to_string()),
                }
            }
        }
        impl CompressedProofWithContext {
            pub fn compressed_proof<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CompressedProof>,
                T::Error: ::std::fmt::Display,
            {
                self.compressed_proof = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for compressed_proof: {e}"
                        )
                    });
                self
            }
            pub fn leaf_indices<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<u32>>,
                T::Error: ::std::fmt::Display,
            {
                self.leaf_indices = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for leaf_indices: {e}")
                    });
                self
            }
            pub fn leaves<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.leaves = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for leaves: {e}")
                    });
                self
            }
            pub fn merkle_trees<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.merkle_trees = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for merkle_trees: {e}")
                    });
                self
            }
            pub fn root_indices<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<u64>>,
                T::Error: ::std::fmt::Display,
            {
                self.root_indices = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for root_indices: {e}")
                    });
                self
            }
            pub fn roots<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.roots = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for roots: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<CompressedProofWithContext>
        for super::CompressedProofWithContext {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CompressedProofWithContext,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    compressed_proof: value.compressed_proof?,
                    leaf_indices: value.leaf_indices?,
                    leaves: value.leaves?,
                    merkle_trees: value.merkle_trees?,
                    root_indices: value.root_indices?,
                    roots: value.roots?,
                })
            }
        }
        impl ::std::convert::From<super::CompressedProofWithContext>
        for CompressedProofWithContext {
            fn from(value: super::CompressedProofWithContext) -> Self {
                Self {
                    compressed_proof: Ok(value.compressed_proof),
                    leaf_indices: Ok(value.leaf_indices),
                    leaves: Ok(value.leaves),
                    merkle_trees: Ok(value.merkle_trees),
                    root_indices: Ok(value.root_indices),
                    roots: Ok(value.roots),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CompressedProofWithContextV2 {
            accounts: ::std::result::Result<
                ::std::vec::Vec<super::AccountProofInputs>,
                ::std::string::String,
            >,
            addresses: ::std::result::Result<
                ::std::vec::Vec<super::AddressProofInputs>,
                ::std::string::String,
            >,
            compressed_proof: ::std::result::Result<
                ::std::option::Option<super::CompressedProof>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CompressedProofWithContextV2 {
            fn default() -> Self {
                Self {
                    accounts: Err("no value supplied for accounts".to_string()),
                    addresses: Err("no value supplied for addresses".to_string()),
                    compressed_proof: Ok(Default::default()),
                }
            }
        }
        impl CompressedProofWithContextV2 {
            pub fn accounts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::AccountProofInputs>>,
                T::Error: ::std::fmt::Display,
            {
                self.accounts = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for accounts: {e}")
                    });
                self
            }
            pub fn addresses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::AddressProofInputs>>,
                T::Error: ::std::fmt::Display,
            {
                self.addresses = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for addresses: {e}")
                    });
                self
            }
            pub fn compressed_proof<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CompressedProof>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.compressed_proof = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for compressed_proof: {e}"
                        )
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<CompressedProofWithContextV2>
        for super::CompressedProofWithContextV2 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CompressedProofWithContextV2,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    accounts: value.accounts?,
                    addresses: value.addresses?,
                    compressed_proof: value.compressed_proof?,
                })
            }
        }
        impl ::std::convert::From<super::CompressedProofWithContextV2>
        for CompressedProofWithContextV2 {
            fn from(value: super::CompressedProofWithContextV2) -> Self {
                Self {
                    accounts: Ok(value.accounts),
                    addresses: Ok(value.addresses),
                    compressed_proof: Ok(value.compressed_proof),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CompressionInfoV2 {
            closed_accounts: ::std::result::Result<
                ::std::vec::Vec<super::ClosedAccountWithOptionalTokenDataV2>,
                ::std::string::String,
            >,
            opened_accounts: ::std::result::Result<
                ::std::vec::Vec<super::AccountWithOptionalTokenDataV2>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CompressionInfoV2 {
            fn default() -> Self {
                Self {
                    closed_accounts: Err(
                        "no value supplied for closed_accounts".to_string(),
                    ),
                    opened_accounts: Err(
                        "no value supplied for opened_accounts".to_string(),
                    ),
                }
            }
        }
        impl CompressionInfoV2 {
            pub fn closed_accounts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::ClosedAccountWithOptionalTokenDataV2>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.closed_accounts = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for closed_accounts: {e}"
                        )
                    });
                self
            }
            pub fn opened_accounts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::AccountWithOptionalTokenDataV2>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.opened_accounts = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for opened_accounts: {e}"
                        )
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<CompressionInfoV2> for super::CompressionInfoV2 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CompressionInfoV2,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    closed_accounts: value.closed_accounts?,
                    opened_accounts: value.opened_accounts?,
                })
            }
        }
        impl ::std::convert::From<super::CompressionInfoV2> for CompressionInfoV2 {
            fn from(value: super::CompressionInfoV2) -> Self {
                Self {
                    closed_accounts: Ok(value.closed_accounts),
                    opened_accounts: Ok(value.opened_accounts),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct Context {
            slot: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for Context {
            fn default() -> Self {
                Self {
                    slot: Err("no value supplied for slot".to_string()),
                }
            }
        }
        impl Context {
            pub fn slot<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.slot = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for slot: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<Context> for super::Context {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Context,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { slot: value.slot? })
            }
        }
        impl ::std::convert::From<super::Context> for Context {
            fn from(value: super::Context) -> Self {
                Self { slot: Ok(value.slot) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DataSlice {
            length: ::std::result::Result<u64, ::std::string::String>,
            offset: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for DataSlice {
            fn default() -> Self {
                Self {
                    length: Err("no value supplied for length".to_string()),
                    offset: Err("no value supplied for offset".to_string()),
                }
            }
        }
        impl DataSlice {
            pub fn length<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.length = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for length: {e}")
                    });
                self
            }
            pub fn offset<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.offset = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for offset: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<DataSlice> for super::DataSlice {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DataSlice,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    length: value.length?,
                    offset: value.offset?,
                })
            }
        }
        impl ::std::convert::From<super::DataSlice> for DataSlice {
            fn from(value: super::DataSlice) -> Self {
                Self {
                    length: Ok(value.length),
                    offset: Ok(value.offset),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct FilterSelector {
            memcmp: ::std::result::Result<
                ::std::option::Option<super::Memcmp>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for FilterSelector {
            fn default() -> Self {
                Self {
                    memcmp: Ok(Default::default()),
                }
            }
        }
        impl FilterSelector {
            pub fn memcmp<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Memcmp>>,
                T::Error: ::std::fmt::Display,
            {
                self.memcmp = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for memcmp: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<FilterSelector> for super::FilterSelector {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FilterSelector,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { memcmp: value.memcmp? })
            }
        }
        impl ::std::convert::From<super::FilterSelector> for FilterSelector {
            fn from(value: super::FilterSelector) -> Self {
                Self { memcmp: Ok(value.memcmp) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GetCompressedAccountProofResponseValue {
            hash: ::std::result::Result<super::Hash, ::std::string::String>,
            leaf_index: ::std::result::Result<u32, ::std::string::String>,
            merkle_tree: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
            proof: ::std::result::Result<
                ::std::vec::Vec<super::Hash>,
                ::std::string::String,
            >,
            root: ::std::result::Result<super::Hash, ::std::string::String>,
            root_seq: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for GetCompressedAccountProofResponseValue {
            fn default() -> Self {
                Self {
                    hash: Err("no value supplied for hash".to_string()),
                    leaf_index: Err("no value supplied for leaf_index".to_string()),
                    merkle_tree: Err("no value supplied for merkle_tree".to_string()),
                    proof: Err("no value supplied for proof".to_string()),
                    root: Err("no value supplied for root".to_string()),
                    root_seq: Err("no value supplied for root_seq".to_string()),
                }
            }
        }
        impl GetCompressedAccountProofResponseValue {
            pub fn hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Hash>,
                T::Error: ::std::fmt::Display,
            {
                self.hash = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for hash: {e}")
                    });
                self
            }
            pub fn leaf_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.leaf_index = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for leaf_index: {e}")
                    });
                self
            }
            pub fn merkle_tree<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.merkle_tree = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for merkle_tree: {e}")
                    });
                self
            }
            pub fn proof<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.proof = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for proof: {e}")
                    });
                self
            }
            pub fn root<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Hash>,
                T::Error: ::std::fmt::Display,
            {
                self.root = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for root: {e}")
                    });
                self
            }
            pub fn root_seq<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.root_seq = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for root_seq: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<GetCompressedAccountProofResponseValue>
        for super::GetCompressedAccountProofResponseValue {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GetCompressedAccountProofResponseValue,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    hash: value.hash?,
                    leaf_index: value.leaf_index?,
                    merkle_tree: value.merkle_tree?,
                    proof: value.proof?,
                    root: value.root?,
                    root_seq: value.root_seq?,
                })
            }
        }
        impl ::std::convert::From<super::GetCompressedAccountProofResponseValue>
        for GetCompressedAccountProofResponseValue {
            fn from(value: super::GetCompressedAccountProofResponseValue) -> Self {
                Self {
                    hash: Ok(value.hash),
                    leaf_index: Ok(value.leaf_index),
                    merkle_tree: Ok(value.merkle_tree),
                    proof: Ok(value.proof),
                    root: Ok(value.root),
                    root_seq: Ok(value.root_seq),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GetCompressedAccountProofResponseValueV2 {
            hash: ::std::result::Result<super::Hash, ::std::string::String>,
            leaf_index: ::std::result::Result<u32, ::std::string::String>,
            proof: ::std::result::Result<
                ::std::vec::Vec<super::Hash>,
                ::std::string::String,
            >,
            prove_by_index: ::std::result::Result<bool, ::std::string::String>,
            root: ::std::result::Result<super::Hash, ::std::string::String>,
            root_seq: ::std::result::Result<u64, ::std::string::String>,
            tree_context: ::std::result::Result<
                super::TreeContextInfo,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for GetCompressedAccountProofResponseValueV2 {
            fn default() -> Self {
                Self {
                    hash: Err("no value supplied for hash".to_string()),
                    leaf_index: Err("no value supplied for leaf_index".to_string()),
                    proof: Err("no value supplied for proof".to_string()),
                    prove_by_index: Err(
                        "no value supplied for prove_by_index".to_string(),
                    ),
                    root: Err("no value supplied for root".to_string()),
                    root_seq: Err("no value supplied for root_seq".to_string()),
                    tree_context: Err("no value supplied for tree_context".to_string()),
                }
            }
        }
        impl GetCompressedAccountProofResponseValueV2 {
            pub fn hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Hash>,
                T::Error: ::std::fmt::Display,
            {
                self.hash = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for hash: {e}")
                    });
                self
            }
            pub fn leaf_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.leaf_index = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for leaf_index: {e}")
                    });
                self
            }
            pub fn proof<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.proof = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for proof: {e}")
                    });
                self
            }
            pub fn prove_by_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.prove_by_index = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for prove_by_index: {e}"
                        )
                    });
                self
            }
            pub fn root<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Hash>,
                T::Error: ::std::fmt::Display,
            {
                self.root = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for root: {e}")
                    });
                self
            }
            pub fn root_seq<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.root_seq = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for root_seq: {e}")
                    });
                self
            }
            pub fn tree_context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TreeContextInfo>,
                T::Error: ::std::fmt::Display,
            {
                self.tree_context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for tree_context: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<GetCompressedAccountProofResponseValueV2>
        for super::GetCompressedAccountProofResponseValueV2 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GetCompressedAccountProofResponseValueV2,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    hash: value.hash?,
                    leaf_index: value.leaf_index?,
                    proof: value.proof?,
                    prove_by_index: value.prove_by_index?,
                    root: value.root?,
                    root_seq: value.root_seq?,
                    tree_context: value.tree_context?,
                })
            }
        }
        impl ::std::convert::From<super::GetCompressedAccountProofResponseValueV2>
        for GetCompressedAccountProofResponseValueV2 {
            fn from(value: super::GetCompressedAccountProofResponseValueV2) -> Self {
                Self {
                    hash: Ok(value.hash),
                    leaf_index: Ok(value.leaf_index),
                    proof: Ok(value.proof),
                    prove_by_index: Ok(value.prove_by_index),
                    root: Ok(value.root),
                    root_seq: Ok(value.root_seq),
                    tree_context: Ok(value.tree_context),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct InputQueueData {
            account_hashes: ::std::result::Result<
                ::std::vec::Vec<super::Hash>,
                ::std::string::String,
            >,
            first_queue_index: ::std::result::Result<u64, ::std::string::String>,
            leaf_indices: ::std::result::Result<
                ::std::vec::Vec<u64>,
                ::std::string::String,
            >,
            leaves: ::std::result::Result<
                ::std::vec::Vec<super::Hash>,
                ::std::string::String,
            >,
            leaves_hash_chains: ::std::result::Result<
                ::std::vec::Vec<super::Hash>,
                ::std::string::String,
            >,
            nullifiers: ::std::result::Result<
                ::std::vec::Vec<super::Hash>,
                ::std::string::String,
            >,
            tx_hashes: ::std::result::Result<
                ::std::vec::Vec<super::Hash>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for InputQueueData {
            fn default() -> Self {
                Self {
                    account_hashes: Err(
                        "no value supplied for account_hashes".to_string(),
                    ),
                    first_queue_index: Err(
                        "no value supplied for first_queue_index".to_string(),
                    ),
                    leaf_indices: Err("no value supplied for leaf_indices".to_string()),
                    leaves: Err("no value supplied for leaves".to_string()),
                    leaves_hash_chains: Err(
                        "no value supplied for leaves_hash_chains".to_string(),
                    ),
                    nullifiers: Err("no value supplied for nullifiers".to_string()),
                    tx_hashes: Err("no value supplied for tx_hashes".to_string()),
                }
            }
        }
        impl InputQueueData {
            pub fn account_hashes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.account_hashes = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for account_hashes: {e}"
                        )
                    });
                self
            }
            pub fn first_queue_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.first_queue_index = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for first_queue_index: {e}"
                        )
                    });
                self
            }
            pub fn leaf_indices<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<u64>>,
                T::Error: ::std::fmt::Display,
            {
                self.leaf_indices = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for leaf_indices: {e}")
                    });
                self
            }
            pub fn leaves<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.leaves = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for leaves: {e}")
                    });
                self
            }
            pub fn leaves_hash_chains<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.leaves_hash_chains = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for leaves_hash_chains: {e}"
                        )
                    });
                self
            }
            pub fn nullifiers<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.nullifiers = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for nullifiers: {e}")
                    });
                self
            }
            pub fn tx_hashes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.tx_hashes = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for tx_hashes: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<InputQueueData> for super::InputQueueData {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InputQueueData,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account_hashes: value.account_hashes?,
                    first_queue_index: value.first_queue_index?,
                    leaf_indices: value.leaf_indices?,
                    leaves: value.leaves?,
                    leaves_hash_chains: value.leaves_hash_chains?,
                    nullifiers: value.nullifiers?,
                    tx_hashes: value.tx_hashes?,
                })
            }
        }
        impl ::std::convert::From<super::InputQueueData> for InputQueueData {
            fn from(value: super::InputQueueData) -> Self {
                Self {
                    account_hashes: Ok(value.account_hashes),
                    first_queue_index: Ok(value.first_queue_index),
                    leaf_indices: Ok(value.leaf_indices),
                    leaves: Ok(value.leaves),
                    leaves_hash_chains: Ok(value.leaves_hash_chains),
                    nullifiers: Ok(value.nullifiers),
                    tx_hashes: Ok(value.tx_hashes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct Memcmp {
            bytes: ::std::result::Result<super::Base58String, ::std::string::String>,
            offset: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for Memcmp {
            fn default() -> Self {
                Self {
                    bytes: Err("no value supplied for bytes".to_string()),
                    offset: Err("no value supplied for offset".to_string()),
                }
            }
        }
        impl Memcmp {
            pub fn bytes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Base58String>,
                T::Error: ::std::fmt::Display,
            {
                self.bytes = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for bytes: {e}")
                    });
                self
            }
            pub fn offset<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.offset = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for offset: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<Memcmp> for super::Memcmp {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Memcmp,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    bytes: value.bytes?,
                    offset: value.offset?,
                })
            }
        }
        impl ::std::convert::From<super::Memcmp> for Memcmp {
            fn from(value: super::Memcmp) -> Self {
                Self {
                    bytes: Ok(value.bytes),
                    offset: Ok(value.offset),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MerkleContextV2 {
            cpi_context: ::std::result::Result<
                ::std::option::Option<super::SerializablePubkey>,
                ::std::string::String,
            >,
            next_tree_context: ::std::result::Result<
                ::std::option::Option<super::TreeContextInfo>,
                ::std::string::String,
            >,
            queue: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
            tree: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
            tree_type: ::std::result::Result<u16, ::std::string::String>,
        }
        impl ::std::default::Default for MerkleContextV2 {
            fn default() -> Self {
                Self {
                    cpi_context: Ok(Default::default()),
                    next_tree_context: Ok(Default::default()),
                    queue: Err("no value supplied for queue".to_string()),
                    tree: Err("no value supplied for tree".to_string()),
                    tree_type: Err("no value supplied for tree_type".to_string()),
                }
            }
        }
        impl MerkleContextV2 {
            pub fn cpi_context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::SerializablePubkey>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.cpi_context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cpi_context: {e}")
                    });
                self
            }
            pub fn next_tree_context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::TreeContextInfo>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.next_tree_context = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for next_tree_context: {e}"
                        )
                    });
                self
            }
            pub fn queue<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.queue = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for queue: {e}")
                    });
                self
            }
            pub fn tree<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.tree = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for tree: {e}")
                    });
                self
            }
            pub fn tree_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u16>,
                T::Error: ::std::fmt::Display,
            {
                self.tree_type = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for tree_type: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<MerkleContextV2> for super::MerkleContextV2 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MerkleContextV2,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cpi_context: value.cpi_context?,
                    next_tree_context: value.next_tree_context?,
                    queue: value.queue?,
                    tree: value.tree?,
                    tree_type: value.tree_type?,
                })
            }
        }
        impl ::std::convert::From<super::MerkleContextV2> for MerkleContextV2 {
            fn from(value: super::MerkleContextV2) -> Self {
                Self {
                    cpi_context: Ok(value.cpi_context),
                    next_tree_context: Ok(value.next_tree_context),
                    queue: Ok(value.queue),
                    tree: Ok(value.tree),
                    tree_type: Ok(value.tree_type),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct MerkleContextWithNewAddressProof {
            address: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
            higher_range_address: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
            low_element_leaf_index: ::std::result::Result<u32, ::std::string::String>,
            lower_range_address: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
            merkle_tree: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
            next_index: ::std::result::Result<u32, ::std::string::String>,
            proof: ::std::result::Result<
                ::std::vec::Vec<super::Hash>,
                ::std::string::String,
            >,
            root: ::std::result::Result<super::Hash, ::std::string::String>,
            root_seq: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for MerkleContextWithNewAddressProof {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    higher_range_address: Err(
                        "no value supplied for higher_range_address".to_string(),
                    ),
                    low_element_leaf_index: Err(
                        "no value supplied for low_element_leaf_index".to_string(),
                    ),
                    lower_range_address: Err(
                        "no value supplied for lower_range_address".to_string(),
                    ),
                    merkle_tree: Err("no value supplied for merkle_tree".to_string()),
                    next_index: Err("no value supplied for next_index".to_string()),
                    proof: Err("no value supplied for proof".to_string()),
                    root: Err("no value supplied for root".to_string()),
                    root_seq: Err("no value supplied for root_seq".to_string()),
                }
            }
        }
        impl MerkleContextWithNewAddressProof {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {e}")
                    });
                self
            }
            pub fn higher_range_address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.higher_range_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for higher_range_address: {e}"
                        )
                    });
                self
            }
            pub fn low_element_leaf_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.low_element_leaf_index = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for low_element_leaf_index: {e}"
                        )
                    });
                self
            }
            pub fn lower_range_address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.lower_range_address = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for lower_range_address: {e}"
                        )
                    });
                self
            }
            pub fn merkle_tree<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.merkle_tree = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for merkle_tree: {e}")
                    });
                self
            }
            pub fn next_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.next_index = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_index: {e}")
                    });
                self
            }
            pub fn proof<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.proof = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for proof: {e}")
                    });
                self
            }
            pub fn root<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Hash>,
                T::Error: ::std::fmt::Display,
            {
                self.root = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for root: {e}")
                    });
                self
            }
            pub fn root_seq<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.root_seq = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for root_seq: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<MerkleContextWithNewAddressProof>
        for super::MerkleContextWithNewAddressProof {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MerkleContextWithNewAddressProof,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    higher_range_address: value.higher_range_address?,
                    low_element_leaf_index: value.low_element_leaf_index?,
                    lower_range_address: value.lower_range_address?,
                    merkle_tree: value.merkle_tree?,
                    next_index: value.next_index?,
                    proof: value.proof?,
                    root: value.root?,
                    root_seq: value.root_seq?,
                })
            }
        }
        impl ::std::convert::From<super::MerkleContextWithNewAddressProof>
        for MerkleContextWithNewAddressProof {
            fn from(value: super::MerkleContextWithNewAddressProof) -> Self {
                Self {
                    address: Ok(value.address),
                    higher_range_address: Ok(value.higher_range_address),
                    low_element_leaf_index: Ok(value.low_element_leaf_index),
                    lower_range_address: Ok(value.lower_range_address),
                    merkle_tree: Ok(value.merkle_tree),
                    next_index: Ok(value.next_index),
                    proof: Ok(value.proof),
                    root: Ok(value.root),
                    root_seq: Ok(value.root_seq),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct Node {
            hash: ::std::result::Result<super::Hash, ::std::string::String>,
            index: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for Node {
            fn default() -> Self {
                Self {
                    hash: Err("no value supplied for hash".to_string()),
                    index: Err("no value supplied for index".to_string()),
                }
            }
        }
        impl Node {
            pub fn hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Hash>,
                T::Error: ::std::fmt::Display,
            {
                self.hash = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for hash: {e}")
                    });
                self
            }
            pub fn index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.index = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for index: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<Node> for super::Node {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Node,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    hash: value.hash?,
                    index: value.index?,
                })
            }
        }
        impl ::std::convert::From<super::Node> for Node {
            fn from(value: super::Node) -> Self {
                Self {
                    hash: Ok(value.hash),
                    index: Ok(value.index),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct OutputQueueData {
            account_hashes: ::std::result::Result<
                ::std::vec::Vec<super::Hash>,
                ::std::string::String,
            >,
            first_queue_index: ::std::result::Result<u64, ::std::string::String>,
            leaf_indices: ::std::result::Result<
                ::std::vec::Vec<u64>,
                ::std::string::String,
            >,
            leaves: ::std::result::Result<
                ::std::vec::Vec<super::Hash>,
                ::std::string::String,
            >,
            leaves_hash_chains: ::std::result::Result<
                ::std::vec::Vec<super::Hash>,
                ::std::string::String,
            >,
            next_index: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for OutputQueueData {
            fn default() -> Self {
                Self {
                    account_hashes: Err(
                        "no value supplied for account_hashes".to_string(),
                    ),
                    first_queue_index: Err(
                        "no value supplied for first_queue_index".to_string(),
                    ),
                    leaf_indices: Err("no value supplied for leaf_indices".to_string()),
                    leaves: Err("no value supplied for leaves".to_string()),
                    leaves_hash_chains: Err(
                        "no value supplied for leaves_hash_chains".to_string(),
                    ),
                    next_index: Err("no value supplied for next_index".to_string()),
                }
            }
        }
        impl OutputQueueData {
            pub fn account_hashes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.account_hashes = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for account_hashes: {e}"
                        )
                    });
                self
            }
            pub fn first_queue_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.first_queue_index = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for first_queue_index: {e}"
                        )
                    });
                self
            }
            pub fn leaf_indices<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<u64>>,
                T::Error: ::std::fmt::Display,
            {
                self.leaf_indices = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for leaf_indices: {e}")
                    });
                self
            }
            pub fn leaves<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.leaves = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for leaves: {e}")
                    });
                self
            }
            pub fn leaves_hash_chains<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.leaves_hash_chains = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for leaves_hash_chains: {e}"
                        )
                    });
                self
            }
            pub fn next_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.next_index = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for next_index: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<OutputQueueData> for super::OutputQueueData {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OutputQueueData,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account_hashes: value.account_hashes?,
                    first_queue_index: value.first_queue_index?,
                    leaf_indices: value.leaf_indices?,
                    leaves: value.leaves?,
                    leaves_hash_chains: value.leaves_hash_chains?,
                    next_index: value.next_index?,
                })
            }
        }
        impl ::std::convert::From<super::OutputQueueData> for OutputQueueData {
            fn from(value: super::OutputQueueData) -> Self {
                Self {
                    account_hashes: Ok(value.account_hashes),
                    first_queue_index: Ok(value.first_queue_index),
                    leaf_indices: Ok(value.leaf_indices),
                    leaves: Ok(value.leaves),
                    leaves_hash_chains: Ok(value.leaves_hash_chains),
                    next_index: Ok(value.next_index),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct OwnerBalance {
            balance: ::std::result::Result<
                super::UnsignedInteger,
                ::std::string::String,
            >,
            owner: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for OwnerBalance {
            fn default() -> Self {
                Self {
                    balance: Err("no value supplied for balance".to_string()),
                    owner: Err("no value supplied for owner".to_string()),
                }
            }
        }
        impl OwnerBalance {
            pub fn balance<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UnsignedInteger>,
                T::Error: ::std::fmt::Display,
            {
                self.balance = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for balance: {e}")
                    });
                self
            }
            pub fn owner<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.owner = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for owner: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<OwnerBalance> for super::OwnerBalance {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OwnerBalance,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    balance: value.balance?,
                    owner: value.owner?,
                })
            }
        }
        impl ::std::convert::From<super::OwnerBalance> for OwnerBalance {
            fn from(value: super::OwnerBalance) -> Self {
                Self {
                    balance: Ok(value.balance),
                    owner: Ok(value.owner),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct OwnerBalanceList {
            cursor: ::std::result::Result<
                ::std::option::Option<super::Base58String>,
                ::std::string::String,
            >,
            items: ::std::result::Result<
                ::std::vec::Vec<super::OwnerBalance>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for OwnerBalanceList {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    items: Err("no value supplied for items".to_string()),
                }
            }
        }
        impl OwnerBalanceList {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Base58String>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::OwnerBalance>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<OwnerBalanceList> for super::OwnerBalanceList {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OwnerBalanceList,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    items: value.items?,
                })
            }
        }
        impl ::std::convert::From<super::OwnerBalanceList> for OwnerBalanceList {
            fn from(value: super::OwnerBalanceList) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    items: Ok(value.items),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct OwnerBalancesResponse {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<super::OwnerBalanceList, ::std::string::String>,
        }
        impl ::std::default::Default for OwnerBalancesResponse {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl OwnerBalancesResponse {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::OwnerBalanceList>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<OwnerBalancesResponse>
        for super::OwnerBalancesResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OwnerBalancesResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::OwnerBalancesResponse>
        for OwnerBalancesResponse {
            fn from(value: super::OwnerBalancesResponse) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PaginatedAccountList {
            cursor: ::std::result::Result<
                ::std::option::Option<super::Hash>,
                ::std::string::String,
            >,
            items: ::std::result::Result<
                ::std::vec::Vec<super::Account>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PaginatedAccountList {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    items: Err("no value supplied for items".to_string()),
                }
            }
        }
        impl PaginatedAccountList {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Account>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PaginatedAccountList>
        for super::PaginatedAccountList {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PaginatedAccountList,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    items: value.items?,
                })
            }
        }
        impl ::std::convert::From<super::PaginatedAccountList> for PaginatedAccountList {
            fn from(value: super::PaginatedAccountList) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    items: Ok(value.items),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PaginatedAccountListV2 {
            cursor: ::std::result::Result<
                ::std::option::Option<super::Hash>,
                ::std::string::String,
            >,
            items: ::std::result::Result<
                ::std::vec::Vec<super::AccountV2>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PaginatedAccountListV2 {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    items: Err("no value supplied for items".to_string()),
                }
            }
        }
        impl PaginatedAccountListV2 {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::AccountV2>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PaginatedAccountListV2>
        for super::PaginatedAccountListV2 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PaginatedAccountListV2,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    items: value.items?,
                })
            }
        }
        impl ::std::convert::From<super::PaginatedAccountListV2>
        for PaginatedAccountListV2 {
            fn from(value: super::PaginatedAccountListV2) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    items: Ok(value.items),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PaginatedSignatureInfoList {
            cursor: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            items: ::std::result::Result<
                ::std::vec::Vec<super::SignatureInfo>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PaginatedSignatureInfoList {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    items: Err("no value supplied for items".to_string()),
                }
            }
        }
        impl PaginatedSignatureInfoList {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SignatureInfo>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PaginatedSignatureInfoList>
        for super::PaginatedSignatureInfoList {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PaginatedSignatureInfoList,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    items: value.items?,
                })
            }
        }
        impl ::std::convert::From<super::PaginatedSignatureInfoList>
        for PaginatedSignatureInfoList {
            fn from(value: super::PaginatedSignatureInfoList) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    items: Ok(value.items),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetAccountInterfaceBody {
            id: ::std::result::Result<
                super::PostGetAccountInterfaceBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetAccountInterfaceBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetAccountInterfaceBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetAccountInterfaceBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetAccountInterfaceBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetAccountInterfaceBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetAccountInterfaceBodyId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetAccountInterfaceBodyJsonrpc>,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetAccountInterfaceBodyMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetAccountInterfaceBodyParams>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetAccountInterfaceBody>
        for super::PostGetAccountInterfaceBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetAccountInterfaceBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetAccountInterfaceBody>
        for PostGetAccountInterfaceBody {
            fn from(value: super::PostGetAccountInterfaceBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetAccountInterfaceBodyParams {
            address: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetAccountInterfaceBodyParams {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                }
            }
        }
        impl PostGetAccountInterfaceBodyParams {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetAccountInterfaceBodyParams>
        for super::PostGetAccountInterfaceBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetAccountInterfaceBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { address: value.address? })
            }
        }
        impl ::std::convert::From<super::PostGetAccountInterfaceBodyParams>
        for PostGetAccountInterfaceBodyParams {
            fn from(value: super::PostGetAccountInterfaceBodyParams) -> Self {
                Self { address: Ok(value.address) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetAccountInterfaceResponse {
            error: ::std::result::Result<
                ::std::option::Option<super::PostGetAccountInterfaceResponseError>,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetAccountInterfaceResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetAccountInterfaceResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<super::PostGetAccountInterfaceResponseResult>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetAccountInterfaceResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetAccountInterfaceResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::PostGetAccountInterfaceResponseError>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetAccountInterfaceResponseId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetAccountInterfaceResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::PostGetAccountInterfaceResponseResult>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetAccountInterfaceResponse>
        for super::PostGetAccountInterfaceResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetAccountInterfaceResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetAccountInterfaceResponse>
        for PostGetAccountInterfaceResponse {
            fn from(value: super::PostGetAccountInterfaceResponse) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetAccountInterfaceResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetAccountInterfaceResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetAccountInterfaceResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetAccountInterfaceResponseError>
        for super::PostGetAccountInterfaceResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetAccountInterfaceResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetAccountInterfaceResponseError>
        for PostGetAccountInterfaceResponseError {
            fn from(value: super::PostGetAccountInterfaceResponseError) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetAccountInterfaceResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                ::std::option::Option<super::AccountInterface>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetAccountInterfaceResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Ok(Default::default()),
                }
            }
        }
        impl PostGetAccountInterfaceResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::AccountInterface>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetAccountInterfaceResponseResult>
        for super::PostGetAccountInterfaceResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetAccountInterfaceResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetAccountInterfaceResponseResult>
        for PostGetAccountInterfaceResponseResult {
            fn from(value: super::PostGetAccountInterfaceResponseResult) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountBalanceBody {
            id: ::std::result::Result<
                super::PostGetCompressedAccountBalanceBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedAccountBalanceBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetCompressedAccountBalanceBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetCompressedAccountBalanceBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountBalanceBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetCompressedAccountBalanceBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetCompressedAccountBalanceBodyId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountBalanceBodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountBalanceBodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountBalanceBodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountBalanceBody>
        for super::PostGetCompressedAccountBalanceBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountBalanceBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountBalanceBody>
        for PostGetCompressedAccountBalanceBody {
            fn from(value: super::PostGetCompressedAccountBalanceBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountBalanceBodyParams {
            address: ::std::result::Result<
                ::std::option::Option<super::SerializablePubkey>,
                ::std::string::String,
            >,
            hash: ::std::result::Result<
                ::std::option::Option<super::Hash>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountBalanceBodyParams {
            fn default() -> Self {
                Self {
                    address: Ok(Default::default()),
                    hash: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedAccountBalanceBodyParams {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::SerializablePubkey>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {e}")
                    });
                self
            }
            pub fn hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.hash = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for hash: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountBalanceBodyParams>
        for super::PostGetCompressedAccountBalanceBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountBalanceBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    hash: value.hash?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountBalanceBodyParams>
        for PostGetCompressedAccountBalanceBodyParams {
            fn from(value: super::PostGetCompressedAccountBalanceBodyParams) -> Self {
                Self {
                    address: Ok(value.address),
                    hash: Ok(value.hash),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountBalanceResponse {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedAccountBalanceResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetCompressedAccountBalanceResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedAccountBalanceResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedAccountBalanceResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountBalanceResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedAccountBalanceResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedAccountBalanceResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountBalanceResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountBalanceResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedAccountBalanceResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountBalanceResponse>
        for super::PostGetCompressedAccountBalanceResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountBalanceResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountBalanceResponse>
        for PostGetCompressedAccountBalanceResponse {
            fn from(value: super::PostGetCompressedAccountBalanceResponse) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountBalanceResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountBalanceResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedAccountBalanceResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountBalanceResponseError>
        for super::PostGetCompressedAccountBalanceResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountBalanceResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountBalanceResponseError>
        for PostGetCompressedAccountBalanceResponseError {
            fn from(value: super::PostGetCompressedAccountBalanceResponseError) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountBalanceResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<super::UnsignedInteger, ::std::string::String>,
        }
        impl ::std::default::Default for PostGetCompressedAccountBalanceResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetCompressedAccountBalanceResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UnsignedInteger>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountBalanceResponseResult>
        for super::PostGetCompressedAccountBalanceResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountBalanceResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountBalanceResponseResult>
        for PostGetCompressedAccountBalanceResponseResult {
            fn from(
                value: super::PostGetCompressedAccountBalanceResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountBody {
            id: ::std::result::Result<
                super::PostGetCompressedAccountBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedAccountBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetCompressedAccountBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetCompressedAccountBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetCompressedAccountBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetCompressedAccountBodyId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetCompressedAccountBodyJsonrpc>,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetCompressedAccountBodyMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetCompressedAccountBodyParams>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountBody>
        for super::PostGetCompressedAccountBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountBody>
        for PostGetCompressedAccountBody {
            fn from(value: super::PostGetCompressedAccountBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountBodyParams {
            address: ::std::result::Result<
                ::std::option::Option<super::SerializablePubkey>,
                ::std::string::String,
            >,
            hash: ::std::result::Result<
                ::std::option::Option<super::Hash>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountBodyParams {
            fn default() -> Self {
                Self {
                    address: Ok(Default::default()),
                    hash: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedAccountBodyParams {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::SerializablePubkey>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {e}")
                    });
                self
            }
            pub fn hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.hash = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for hash: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountBodyParams>
        for super::PostGetCompressedAccountBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    hash: value.hash?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountBodyParams>
        for PostGetCompressedAccountBodyParams {
            fn from(value: super::PostGetCompressedAccountBodyParams) -> Self {
                Self {
                    address: Ok(value.address),
                    hash: Ok(value.hash),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountProofBody {
            id: ::std::result::Result<
                super::PostGetCompressedAccountProofBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedAccountProofBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetCompressedAccountProofBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetCompressedAccountProofBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountProofBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetCompressedAccountProofBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetCompressedAccountProofBodyId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountProofBodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountProofBodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountProofBodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountProofBody>
        for super::PostGetCompressedAccountProofBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountProofBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountProofBody>
        for PostGetCompressedAccountProofBody {
            fn from(value: super::PostGetCompressedAccountProofBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountProofBodyParams {
            hash: ::std::result::Result<super::Hash, ::std::string::String>,
        }
        impl ::std::default::Default for PostGetCompressedAccountProofBodyParams {
            fn default() -> Self {
                Self {
                    hash: Err("no value supplied for hash".to_string()),
                }
            }
        }
        impl PostGetCompressedAccountProofBodyParams {
            pub fn hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Hash>,
                T::Error: ::std::fmt::Display,
            {
                self.hash = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for hash: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountProofBodyParams>
        for super::PostGetCompressedAccountProofBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountProofBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { hash: value.hash? })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountProofBodyParams>
        for PostGetCompressedAccountProofBodyParams {
            fn from(value: super::PostGetCompressedAccountProofBodyParams) -> Self {
                Self { hash: Ok(value.hash) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountProofResponse {
            error: ::std::result::Result<
                ::std::option::Option<super::PostGetCompressedAccountProofResponseError>,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetCompressedAccountProofResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedAccountProofResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedAccountProofResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountProofResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedAccountProofResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedAccountProofResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountProofResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountProofResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedAccountProofResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountProofResponse>
        for super::PostGetCompressedAccountProofResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountProofResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountProofResponse>
        for PostGetCompressedAccountProofResponse {
            fn from(value: super::PostGetCompressedAccountProofResponse) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountProofResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountProofResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedAccountProofResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountProofResponseError>
        for super::PostGetCompressedAccountProofResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountProofResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountProofResponseError>
        for PostGetCompressedAccountProofResponseError {
            fn from(value: super::PostGetCompressedAccountProofResponseError) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountProofResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                super::GetCompressedAccountProofResponseValue,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountProofResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetCompressedAccountProofResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::GetCompressedAccountProofResponseValue,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountProofResponseResult>
        for super::PostGetCompressedAccountProofResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountProofResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountProofResponseResult>
        for PostGetCompressedAccountProofResponseResult {
            fn from(value: super::PostGetCompressedAccountProofResponseResult) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountProofV2Body {
            id: ::std::result::Result<
                super::PostGetCompressedAccountProofV2BodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedAccountProofV2BodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetCompressedAccountProofV2BodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetCompressedAccountProofV2BodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountProofV2Body {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetCompressedAccountProofV2Body {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetCompressedAccountProofV2BodyId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountProofV2BodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountProofV2BodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountProofV2BodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountProofV2Body>
        for super::PostGetCompressedAccountProofV2Body {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountProofV2Body,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountProofV2Body>
        for PostGetCompressedAccountProofV2Body {
            fn from(value: super::PostGetCompressedAccountProofV2Body) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountProofV2BodyParams {
            hash: ::std::result::Result<super::Hash, ::std::string::String>,
        }
        impl ::std::default::Default for PostGetCompressedAccountProofV2BodyParams {
            fn default() -> Self {
                Self {
                    hash: Err("no value supplied for hash".to_string()),
                }
            }
        }
        impl PostGetCompressedAccountProofV2BodyParams {
            pub fn hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Hash>,
                T::Error: ::std::fmt::Display,
            {
                self.hash = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for hash: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountProofV2BodyParams>
        for super::PostGetCompressedAccountProofV2BodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountProofV2BodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { hash: value.hash? })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountProofV2BodyParams>
        for PostGetCompressedAccountProofV2BodyParams {
            fn from(value: super::PostGetCompressedAccountProofV2BodyParams) -> Self {
                Self { hash: Ok(value.hash) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountProofV2Response {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedAccountProofV2ResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetCompressedAccountProofV2ResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedAccountProofV2ResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedAccountProofV2ResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountProofV2Response {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedAccountProofV2Response {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedAccountProofV2ResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountProofV2ResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountProofV2ResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedAccountProofV2ResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountProofV2Response>
        for super::PostGetCompressedAccountProofV2Response {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountProofV2Response,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountProofV2Response>
        for PostGetCompressedAccountProofV2Response {
            fn from(value: super::PostGetCompressedAccountProofV2Response) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountProofV2ResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountProofV2ResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedAccountProofV2ResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountProofV2ResponseError>
        for super::PostGetCompressedAccountProofV2ResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountProofV2ResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountProofV2ResponseError>
        for PostGetCompressedAccountProofV2ResponseError {
            fn from(value: super::PostGetCompressedAccountProofV2ResponseError) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountProofV2ResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                super::GetCompressedAccountProofResponseValueV2,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountProofV2ResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetCompressedAccountProofV2ResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::GetCompressedAccountProofResponseValueV2,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountProofV2ResponseResult>
        for super::PostGetCompressedAccountProofV2ResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountProofV2ResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountProofV2ResponseResult>
        for PostGetCompressedAccountProofV2ResponseResult {
            fn from(
                value: super::PostGetCompressedAccountProofV2ResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountResponse {
            error: ::std::result::Result<
                ::std::option::Option<super::PostGetCompressedAccountResponseError>,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetCompressedAccountResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedAccountResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<super::PostGetCompressedAccountResponseResult>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedAccountResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::PostGetCompressedAccountResponseError>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetCompressedAccountResponseId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::PostGetCompressedAccountResponseResult>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountResponse>
        for super::PostGetCompressedAccountResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountResponse>
        for PostGetCompressedAccountResponse {
            fn from(value: super::PostGetCompressedAccountResponse) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedAccountResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountResponseError>
        for super::PostGetCompressedAccountResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountResponseError>
        for PostGetCompressedAccountResponseError {
            fn from(value: super::PostGetCompressedAccountResponseError) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                ::std::option::Option<super::Account>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedAccountResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Account>>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountResponseResult>
        for super::PostGetCompressedAccountResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountResponseResult>
        for PostGetCompressedAccountResponseResult {
            fn from(value: super::PostGetCompressedAccountResponseResult) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountV2Body {
            id: ::std::result::Result<
                super::PostGetCompressedAccountV2BodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedAccountV2BodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetCompressedAccountV2BodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetCompressedAccountV2BodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountV2Body {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetCompressedAccountV2Body {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetCompressedAccountV2BodyId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetCompressedAccountV2BodyJsonrpc>,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetCompressedAccountV2BodyMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetCompressedAccountV2BodyParams>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountV2Body>
        for super::PostGetCompressedAccountV2Body {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountV2Body,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountV2Body>
        for PostGetCompressedAccountV2Body {
            fn from(value: super::PostGetCompressedAccountV2Body) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountV2BodyParams {
            address: ::std::result::Result<
                ::std::option::Option<super::SerializablePubkey>,
                ::std::string::String,
            >,
            hash: ::std::result::Result<
                ::std::option::Option<super::Hash>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountV2BodyParams {
            fn default() -> Self {
                Self {
                    address: Ok(Default::default()),
                    hash: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedAccountV2BodyParams {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::SerializablePubkey>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {e}")
                    });
                self
            }
            pub fn hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.hash = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for hash: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountV2BodyParams>
        for super::PostGetCompressedAccountV2BodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountV2BodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    hash: value.hash?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountV2BodyParams>
        for PostGetCompressedAccountV2BodyParams {
            fn from(value: super::PostGetCompressedAccountV2BodyParams) -> Self {
                Self {
                    address: Ok(value.address),
                    hash: Ok(value.hash),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountV2Response {
            error: ::std::result::Result<
                ::std::option::Option<super::PostGetCompressedAccountV2ResponseError>,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetCompressedAccountV2ResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedAccountV2ResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<super::PostGetCompressedAccountV2ResponseResult>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountV2Response {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedAccountV2Response {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::PostGetCompressedAccountV2ResponseError>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetCompressedAccountV2ResponseId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountV2ResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedAccountV2ResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountV2Response>
        for super::PostGetCompressedAccountV2Response {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountV2Response,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountV2Response>
        for PostGetCompressedAccountV2Response {
            fn from(value: super::PostGetCompressedAccountV2Response) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountV2ResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountV2ResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedAccountV2ResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountV2ResponseError>
        for super::PostGetCompressedAccountV2ResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountV2ResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountV2ResponseError>
        for PostGetCompressedAccountV2ResponseError {
            fn from(value: super::PostGetCompressedAccountV2ResponseError) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountV2ResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                ::std::option::Option<super::AccountV2>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountV2ResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedAccountV2ResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::AccountV2>>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountV2ResponseResult>
        for super::PostGetCompressedAccountV2ResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountV2ResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountV2ResponseResult>
        for PostGetCompressedAccountV2ResponseResult {
            fn from(value: super::PostGetCompressedAccountV2ResponseResult) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountsByOwnerBody {
            id: ::std::result::Result<
                super::PostGetCompressedAccountsByOwnerBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedAccountsByOwnerBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetCompressedAccountsByOwnerBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetCompressedAccountsByOwnerBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountsByOwnerBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetCompressedAccountsByOwnerBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountsByOwnerBodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountsByOwnerBodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountsByOwnerBodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountsByOwnerBodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountsByOwnerBody>
        for super::PostGetCompressedAccountsByOwnerBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountsByOwnerBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountsByOwnerBody>
        for PostGetCompressedAccountsByOwnerBody {
            fn from(value: super::PostGetCompressedAccountsByOwnerBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountsByOwnerBodyParams {
            cursor: ::std::result::Result<
                ::std::option::Option<super::Hash>,
                ::std::string::String,
            >,
            data_slice: ::std::result::Result<
                ::std::option::Option<super::DataSlice>,
                ::std::string::String,
            >,
            filters: ::std::result::Result<
                ::std::vec::Vec<super::FilterSelector>,
                ::std::string::String,
            >,
            limit: ::std::result::Result<
                ::std::option::Option<super::Limit>,
                ::std::string::String,
            >,
            owner: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountsByOwnerBodyParams {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    data_slice: Ok(Default::default()),
                    filters: Ok(Default::default()),
                    limit: Ok(Default::default()),
                    owner: Err("no value supplied for owner".to_string()),
                }
            }
        }
        impl PostGetCompressedAccountsByOwnerBodyParams {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn data_slice<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::DataSlice>>,
                T::Error: ::std::fmt::Display,
            {
                self.data_slice = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for data_slice: {e}")
                    });
                self
            }
            pub fn filters<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::FilterSelector>>,
                T::Error: ::std::fmt::Display,
            {
                self.filters = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for filters: {e}")
                    });
                self
            }
            pub fn limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Limit>>,
                T::Error: ::std::fmt::Display,
            {
                self.limit = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for limit: {e}")
                    });
                self
            }
            pub fn owner<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.owner = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for owner: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountsByOwnerBodyParams>
        for super::PostGetCompressedAccountsByOwnerBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountsByOwnerBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    data_slice: value.data_slice?,
                    filters: value.filters?,
                    limit: value.limit?,
                    owner: value.owner?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountsByOwnerBodyParams>
        for PostGetCompressedAccountsByOwnerBodyParams {
            fn from(value: super::PostGetCompressedAccountsByOwnerBodyParams) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    data_slice: Ok(value.data_slice),
                    filters: Ok(value.filters),
                    limit: Ok(value.limit),
                    owner: Ok(value.owner),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountsByOwnerResponse {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedAccountsByOwnerResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetCompressedAccountsByOwnerResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedAccountsByOwnerResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedAccountsByOwnerResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountsByOwnerResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedAccountsByOwnerResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedAccountsByOwnerResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountsByOwnerResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountsByOwnerResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedAccountsByOwnerResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountsByOwnerResponse>
        for super::PostGetCompressedAccountsByOwnerResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountsByOwnerResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountsByOwnerResponse>
        for PostGetCompressedAccountsByOwnerResponse {
            fn from(value: super::PostGetCompressedAccountsByOwnerResponse) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountsByOwnerResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountsByOwnerResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedAccountsByOwnerResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountsByOwnerResponseError>
        for super::PostGetCompressedAccountsByOwnerResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountsByOwnerResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountsByOwnerResponseError>
        for PostGetCompressedAccountsByOwnerResponseError {
            fn from(
                value: super::PostGetCompressedAccountsByOwnerResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountsByOwnerResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                super::PaginatedAccountList,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountsByOwnerResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetCompressedAccountsByOwnerResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PaginatedAccountList>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountsByOwnerResponseResult>
        for super::PostGetCompressedAccountsByOwnerResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountsByOwnerResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountsByOwnerResponseResult>
        for PostGetCompressedAccountsByOwnerResponseResult {
            fn from(
                value: super::PostGetCompressedAccountsByOwnerResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountsByOwnerV2Body {
            id: ::std::result::Result<
                super::PostGetCompressedAccountsByOwnerV2BodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedAccountsByOwnerV2BodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetCompressedAccountsByOwnerV2BodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetCompressedAccountsByOwnerV2BodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountsByOwnerV2Body {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetCompressedAccountsByOwnerV2Body {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountsByOwnerV2BodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountsByOwnerV2BodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountsByOwnerV2BodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountsByOwnerV2BodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountsByOwnerV2Body>
        for super::PostGetCompressedAccountsByOwnerV2Body {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountsByOwnerV2Body,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountsByOwnerV2Body>
        for PostGetCompressedAccountsByOwnerV2Body {
            fn from(value: super::PostGetCompressedAccountsByOwnerV2Body) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountsByOwnerV2BodyParams {
            cursor: ::std::result::Result<
                ::std::option::Option<super::Hash>,
                ::std::string::String,
            >,
            data_slice: ::std::result::Result<
                ::std::option::Option<super::DataSlice>,
                ::std::string::String,
            >,
            filters: ::std::result::Result<
                ::std::vec::Vec<super::FilterSelector>,
                ::std::string::String,
            >,
            limit: ::std::result::Result<
                ::std::option::Option<super::Limit>,
                ::std::string::String,
            >,
            owner: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountsByOwnerV2BodyParams {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    data_slice: Ok(Default::default()),
                    filters: Ok(Default::default()),
                    limit: Ok(Default::default()),
                    owner: Err("no value supplied for owner".to_string()),
                }
            }
        }
        impl PostGetCompressedAccountsByOwnerV2BodyParams {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn data_slice<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::DataSlice>>,
                T::Error: ::std::fmt::Display,
            {
                self.data_slice = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for data_slice: {e}")
                    });
                self
            }
            pub fn filters<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::FilterSelector>>,
                T::Error: ::std::fmt::Display,
            {
                self.filters = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for filters: {e}")
                    });
                self
            }
            pub fn limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Limit>>,
                T::Error: ::std::fmt::Display,
            {
                self.limit = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for limit: {e}")
                    });
                self
            }
            pub fn owner<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.owner = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for owner: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountsByOwnerV2BodyParams>
        for super::PostGetCompressedAccountsByOwnerV2BodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountsByOwnerV2BodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    data_slice: value.data_slice?,
                    filters: value.filters?,
                    limit: value.limit?,
                    owner: value.owner?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountsByOwnerV2BodyParams>
        for PostGetCompressedAccountsByOwnerV2BodyParams {
            fn from(value: super::PostGetCompressedAccountsByOwnerV2BodyParams) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    data_slice: Ok(value.data_slice),
                    filters: Ok(value.filters),
                    limit: Ok(value.limit),
                    owner: Ok(value.owner),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountsByOwnerV2Response {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedAccountsByOwnerV2ResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetCompressedAccountsByOwnerV2ResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedAccountsByOwnerV2ResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedAccountsByOwnerV2ResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedAccountsByOwnerV2Response {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedAccountsByOwnerV2Response {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedAccountsByOwnerV2ResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountsByOwnerV2ResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedAccountsByOwnerV2ResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedAccountsByOwnerV2ResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountsByOwnerV2Response>
        for super::PostGetCompressedAccountsByOwnerV2Response {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountsByOwnerV2Response,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountsByOwnerV2Response>
        for PostGetCompressedAccountsByOwnerV2Response {
            fn from(value: super::PostGetCompressedAccountsByOwnerV2Response) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountsByOwnerV2ResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedAccountsByOwnerV2ResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedAccountsByOwnerV2ResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountsByOwnerV2ResponseError>
        for super::PostGetCompressedAccountsByOwnerV2ResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountsByOwnerV2ResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedAccountsByOwnerV2ResponseError>
        for PostGetCompressedAccountsByOwnerV2ResponseError {
            fn from(
                value: super::PostGetCompressedAccountsByOwnerV2ResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedAccountsByOwnerV2ResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                super::PaginatedAccountListV2,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedAccountsByOwnerV2ResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetCompressedAccountsByOwnerV2ResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PaginatedAccountListV2>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedAccountsByOwnerV2ResponseResult>
        for super::PostGetCompressedAccountsByOwnerV2ResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedAccountsByOwnerV2ResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressedAccountsByOwnerV2ResponseResult,
        > for PostGetCompressedAccountsByOwnerV2ResponseResult {
            fn from(
                value: super::PostGetCompressedAccountsByOwnerV2ResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedBalanceByOwnerBody {
            id: ::std::result::Result<
                super::PostGetCompressedBalanceByOwnerBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedBalanceByOwnerBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetCompressedBalanceByOwnerBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetCompressedBalanceByOwnerBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedBalanceByOwnerBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetCompressedBalanceByOwnerBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetCompressedBalanceByOwnerBodyId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedBalanceByOwnerBodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedBalanceByOwnerBodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedBalanceByOwnerBodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedBalanceByOwnerBody>
        for super::PostGetCompressedBalanceByOwnerBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedBalanceByOwnerBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedBalanceByOwnerBody>
        for PostGetCompressedBalanceByOwnerBody {
            fn from(value: super::PostGetCompressedBalanceByOwnerBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedBalanceByOwnerBodyParams {
            owner: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedBalanceByOwnerBodyParams {
            fn default() -> Self {
                Self {
                    owner: Err("no value supplied for owner".to_string()),
                }
            }
        }
        impl PostGetCompressedBalanceByOwnerBodyParams {
            pub fn owner<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.owner = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for owner: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedBalanceByOwnerBodyParams>
        for super::PostGetCompressedBalanceByOwnerBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedBalanceByOwnerBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { owner: value.owner? })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedBalanceByOwnerBodyParams>
        for PostGetCompressedBalanceByOwnerBodyParams {
            fn from(value: super::PostGetCompressedBalanceByOwnerBodyParams) -> Self {
                Self { owner: Ok(value.owner) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedBalanceByOwnerResponse {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedBalanceByOwnerResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetCompressedBalanceByOwnerResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedBalanceByOwnerResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedBalanceByOwnerResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedBalanceByOwnerResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedBalanceByOwnerResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedBalanceByOwnerResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedBalanceByOwnerResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedBalanceByOwnerResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedBalanceByOwnerResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedBalanceByOwnerResponse>
        for super::PostGetCompressedBalanceByOwnerResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedBalanceByOwnerResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedBalanceByOwnerResponse>
        for PostGetCompressedBalanceByOwnerResponse {
            fn from(value: super::PostGetCompressedBalanceByOwnerResponse) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedBalanceByOwnerResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedBalanceByOwnerResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedBalanceByOwnerResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedBalanceByOwnerResponseError>
        for super::PostGetCompressedBalanceByOwnerResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedBalanceByOwnerResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedBalanceByOwnerResponseError>
        for PostGetCompressedBalanceByOwnerResponseError {
            fn from(value: super::PostGetCompressedBalanceByOwnerResponseError) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedBalanceByOwnerResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<super::UnsignedInteger, ::std::string::String>,
        }
        impl ::std::default::Default for PostGetCompressedBalanceByOwnerResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetCompressedBalanceByOwnerResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UnsignedInteger>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedBalanceByOwnerResponseResult>
        for super::PostGetCompressedBalanceByOwnerResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedBalanceByOwnerResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedBalanceByOwnerResponseResult>
        for PostGetCompressedBalanceByOwnerResponseResult {
            fn from(
                value: super::PostGetCompressedBalanceByOwnerResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedMintTokenHoldersBody {
            id: ::std::result::Result<
                super::PostGetCompressedMintTokenHoldersBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedMintTokenHoldersBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetCompressedMintTokenHoldersBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetCompressedMintTokenHoldersBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedMintTokenHoldersBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetCompressedMintTokenHoldersBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedMintTokenHoldersBodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedMintTokenHoldersBodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedMintTokenHoldersBodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedMintTokenHoldersBodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedMintTokenHoldersBody>
        for super::PostGetCompressedMintTokenHoldersBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedMintTokenHoldersBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedMintTokenHoldersBody>
        for PostGetCompressedMintTokenHoldersBody {
            fn from(value: super::PostGetCompressedMintTokenHoldersBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedMintTokenHoldersBodyParams {
            cursor: ::std::result::Result<
                ::std::option::Option<super::Base58String>,
                ::std::string::String,
            >,
            limit: ::std::result::Result<
                ::std::option::Option<super::Limit>,
                ::std::string::String,
            >,
            mint: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedMintTokenHoldersBodyParams {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    limit: Ok(Default::default()),
                    mint: Err("no value supplied for mint".to_string()),
                }
            }
        }
        impl PostGetCompressedMintTokenHoldersBodyParams {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Base58String>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Limit>>,
                T::Error: ::std::fmt::Display,
            {
                self.limit = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for limit: {e}")
                    });
                self
            }
            pub fn mint<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.mint = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for mint: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedMintTokenHoldersBodyParams>
        for super::PostGetCompressedMintTokenHoldersBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedMintTokenHoldersBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    limit: value.limit?,
                    mint: value.mint?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedMintTokenHoldersBodyParams>
        for PostGetCompressedMintTokenHoldersBodyParams {
            fn from(value: super::PostGetCompressedMintTokenHoldersBodyParams) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    limit: Ok(value.limit),
                    mint: Ok(value.mint),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedMintTokenHoldersResponse {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedMintTokenHoldersResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetCompressedMintTokenHoldersResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedMintTokenHoldersResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedMintTokenHoldersResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedMintTokenHoldersResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedMintTokenHoldersResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedMintTokenHoldersResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedMintTokenHoldersResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedMintTokenHoldersResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedMintTokenHoldersResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedMintTokenHoldersResponse>
        for super::PostGetCompressedMintTokenHoldersResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedMintTokenHoldersResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedMintTokenHoldersResponse>
        for PostGetCompressedMintTokenHoldersResponse {
            fn from(value: super::PostGetCompressedMintTokenHoldersResponse) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedMintTokenHoldersResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedMintTokenHoldersResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedMintTokenHoldersResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedMintTokenHoldersResponseError>
        for super::PostGetCompressedMintTokenHoldersResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedMintTokenHoldersResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedMintTokenHoldersResponseError>
        for PostGetCompressedMintTokenHoldersResponseError {
            fn from(
                value: super::PostGetCompressedMintTokenHoldersResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedMintTokenHoldersResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<super::OwnerBalanceList, ::std::string::String>,
        }
        impl ::std::default::Default
        for PostGetCompressedMintTokenHoldersResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetCompressedMintTokenHoldersResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::OwnerBalanceList>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedMintTokenHoldersResponseResult>
        for super::PostGetCompressedMintTokenHoldersResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedMintTokenHoldersResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedMintTokenHoldersResponseResult>
        for PostGetCompressedMintTokenHoldersResponseResult {
            fn from(
                value: super::PostGetCompressedMintTokenHoldersResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountBalanceBody {
            id: ::std::result::Result<
                super::PostGetCompressedTokenAccountBalanceBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedTokenAccountBalanceBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetCompressedTokenAccountBalanceBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetCompressedTokenAccountBalanceBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedTokenAccountBalanceBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetCompressedTokenAccountBalanceBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountBalanceBodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountBalanceBodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountBalanceBodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountBalanceBodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenAccountBalanceBody>
        for super::PostGetCompressedTokenAccountBalanceBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountBalanceBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedTokenAccountBalanceBody>
        for PostGetCompressedTokenAccountBalanceBody {
            fn from(value: super::PostGetCompressedTokenAccountBalanceBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountBalanceBodyParams {
            address: ::std::result::Result<
                ::std::option::Option<super::SerializablePubkey>,
                ::std::string::String,
            >,
            hash: ::std::result::Result<
                ::std::option::Option<super::Hash>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedTokenAccountBalanceBodyParams {
            fn default() -> Self {
                Self {
                    address: Ok(Default::default()),
                    hash: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedTokenAccountBalanceBodyParams {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::SerializablePubkey>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {e}")
                    });
                self
            }
            pub fn hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.hash = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for hash: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenAccountBalanceBodyParams>
        for super::PostGetCompressedTokenAccountBalanceBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountBalanceBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    hash: value.hash?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedTokenAccountBalanceBodyParams>
        for PostGetCompressedTokenAccountBalanceBodyParams {
            fn from(
                value: super::PostGetCompressedTokenAccountBalanceBodyParams,
            ) -> Self {
                Self {
                    address: Ok(value.address),
                    hash: Ok(value.hash),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountBalanceResponse {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedTokenAccountBalanceResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetCompressedTokenAccountBalanceResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedTokenAccountBalanceResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedTokenAccountBalanceResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedTokenAccountBalanceResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedTokenAccountBalanceResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedTokenAccountBalanceResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountBalanceResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountBalanceResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedTokenAccountBalanceResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenAccountBalanceResponse>
        for super::PostGetCompressedTokenAccountBalanceResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountBalanceResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedTokenAccountBalanceResponse>
        for PostGetCompressedTokenAccountBalanceResponse {
            fn from(value: super::PostGetCompressedTokenAccountBalanceResponse) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountBalanceResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenAccountBalanceResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedTokenAccountBalanceResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenAccountBalanceResponseError>
        for super::PostGetCompressedTokenAccountBalanceResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountBalanceResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressedTokenAccountBalanceResponseError,
        > for PostGetCompressedTokenAccountBalanceResponseError {
            fn from(
                value: super::PostGetCompressedTokenAccountBalanceResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountBalanceResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                super::TokenAccountBalance,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenAccountBalanceResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetCompressedTokenAccountBalanceResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TokenAccountBalance>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenAccountBalanceResponseResult>
        for super::PostGetCompressedTokenAccountBalanceResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountBalanceResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressedTokenAccountBalanceResponseResult,
        > for PostGetCompressedTokenAccountBalanceResponseResult {
            fn from(
                value: super::PostGetCompressedTokenAccountBalanceResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountsByDelegateBody {
            id: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByDelegateBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByDelegateBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByDelegateBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByDelegateBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedTokenAccountsByDelegateBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetCompressedTokenAccountsByDelegateBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByDelegateBodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByDelegateBodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByDelegateBodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByDelegateBodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenAccountsByDelegateBody>
        for super::PostGetCompressedTokenAccountsByDelegateBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountsByDelegateBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedTokenAccountsByDelegateBody>
        for PostGetCompressedTokenAccountsByDelegateBody {
            fn from(value: super::PostGetCompressedTokenAccountsByDelegateBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountsByDelegateBodyParams {
            cursor: ::std::result::Result<
                ::std::option::Option<super::Base58String>,
                ::std::string::String,
            >,
            delegate: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
            limit: ::std::result::Result<
                ::std::option::Option<super::Limit>,
                ::std::string::String,
            >,
            mint: ::std::result::Result<
                ::std::option::Option<super::SerializablePubkey>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenAccountsByDelegateBodyParams {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    delegate: Err("no value supplied for delegate".to_string()),
                    limit: Ok(Default::default()),
                    mint: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedTokenAccountsByDelegateBodyParams {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Base58String>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn delegate<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.delegate = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for delegate: {e}")
                    });
                self
            }
            pub fn limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Limit>>,
                T::Error: ::std::fmt::Display,
            {
                self.limit = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for limit: {e}")
                    });
                self
            }
            pub fn mint<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::SerializablePubkey>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.mint = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for mint: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenAccountsByDelegateBodyParams>
        for super::PostGetCompressedTokenAccountsByDelegateBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountsByDelegateBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    delegate: value.delegate?,
                    limit: value.limit?,
                    mint: value.mint?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressedTokenAccountsByDelegateBodyParams,
        > for PostGetCompressedTokenAccountsByDelegateBodyParams {
            fn from(
                value: super::PostGetCompressedTokenAccountsByDelegateBodyParams,
            ) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    delegate: Ok(value.delegate),
                    limit: Ok(value.limit),
                    mint: Ok(value.mint),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountsByDelegateResponse {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedTokenAccountsByDelegateResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByDelegateResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByDelegateResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedTokenAccountsByDelegateResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenAccountsByDelegateResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedTokenAccountsByDelegateResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedTokenAccountsByDelegateResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByDelegateResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByDelegateResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedTokenAccountsByDelegateResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenAccountsByDelegateResponse>
        for super::PostGetCompressedTokenAccountsByDelegateResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountsByDelegateResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressedTokenAccountsByDelegateResponse,
        > for PostGetCompressedTokenAccountsByDelegateResponse {
            fn from(
                value: super::PostGetCompressedTokenAccountsByDelegateResponse,
            ) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountsByDelegateResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenAccountsByDelegateResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedTokenAccountsByDelegateResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<
            PostGetCompressedTokenAccountsByDelegateResponseError,
        > for super::PostGetCompressedTokenAccountsByDelegateResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountsByDelegateResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressedTokenAccountsByDelegateResponseError,
        > for PostGetCompressedTokenAccountsByDelegateResponseError {
            fn from(
                value: super::PostGetCompressedTokenAccountsByDelegateResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountsByDelegateResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<super::TokenAccountList, ::std::string::String>,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenAccountsByDelegateResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetCompressedTokenAccountsByDelegateResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TokenAccountList>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<
            PostGetCompressedTokenAccountsByDelegateResponseResult,
        > for super::PostGetCompressedTokenAccountsByDelegateResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountsByDelegateResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressedTokenAccountsByDelegateResponseResult,
        > for PostGetCompressedTokenAccountsByDelegateResponseResult {
            fn from(
                value: super::PostGetCompressedTokenAccountsByDelegateResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountsByDelegateV2Body {
            id: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByDelegateV2BodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByDelegateV2BodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByDelegateV2BodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByDelegateV2BodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedTokenAccountsByDelegateV2Body {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetCompressedTokenAccountsByDelegateV2Body {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByDelegateV2BodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByDelegateV2BodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByDelegateV2BodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByDelegateV2BodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenAccountsByDelegateV2Body>
        for super::PostGetCompressedTokenAccountsByDelegateV2Body {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountsByDelegateV2Body,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedTokenAccountsByDelegateV2Body>
        for PostGetCompressedTokenAccountsByDelegateV2Body {
            fn from(
                value: super::PostGetCompressedTokenAccountsByDelegateV2Body,
            ) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountsByDelegateV2BodyParams {
            cursor: ::std::result::Result<
                ::std::option::Option<super::Base58String>,
                ::std::string::String,
            >,
            delegate: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
            limit: ::std::result::Result<
                ::std::option::Option<super::Limit>,
                ::std::string::String,
            >,
            mint: ::std::result::Result<
                ::std::option::Option<super::SerializablePubkey>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenAccountsByDelegateV2BodyParams {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    delegate: Err("no value supplied for delegate".to_string()),
                    limit: Ok(Default::default()),
                    mint: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedTokenAccountsByDelegateV2BodyParams {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Base58String>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn delegate<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.delegate = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for delegate: {e}")
                    });
                self
            }
            pub fn limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Limit>>,
                T::Error: ::std::fmt::Display,
            {
                self.limit = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for limit: {e}")
                    });
                self
            }
            pub fn mint<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::SerializablePubkey>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.mint = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for mint: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<
            PostGetCompressedTokenAccountsByDelegateV2BodyParams,
        > for super::PostGetCompressedTokenAccountsByDelegateV2BodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountsByDelegateV2BodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    delegate: value.delegate?,
                    limit: value.limit?,
                    mint: value.mint?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressedTokenAccountsByDelegateV2BodyParams,
        > for PostGetCompressedTokenAccountsByDelegateV2BodyParams {
            fn from(
                value: super::PostGetCompressedTokenAccountsByDelegateV2BodyParams,
            ) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    delegate: Ok(value.delegate),
                    limit: Ok(value.limit),
                    mint: Ok(value.mint),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountsByDelegateV2Response {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedTokenAccountsByDelegateV2ResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByDelegateV2ResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByDelegateV2ResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedTokenAccountsByDelegateV2ResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenAccountsByDelegateV2Response {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedTokenAccountsByDelegateV2Response {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedTokenAccountsByDelegateV2ResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByDelegateV2ResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByDelegateV2ResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedTokenAccountsByDelegateV2ResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenAccountsByDelegateV2Response>
        for super::PostGetCompressedTokenAccountsByDelegateV2Response {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountsByDelegateV2Response,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressedTokenAccountsByDelegateV2Response,
        > for PostGetCompressedTokenAccountsByDelegateV2Response {
            fn from(
                value: super::PostGetCompressedTokenAccountsByDelegateV2Response,
            ) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountsByDelegateV2ResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenAccountsByDelegateV2ResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedTokenAccountsByDelegateV2ResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<
            PostGetCompressedTokenAccountsByDelegateV2ResponseError,
        > for super::PostGetCompressedTokenAccountsByDelegateV2ResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountsByDelegateV2ResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressedTokenAccountsByDelegateV2ResponseError,
        > for PostGetCompressedTokenAccountsByDelegateV2ResponseError {
            fn from(
                value: super::PostGetCompressedTokenAccountsByDelegateV2ResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountsByDelegateV2ResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                super::TokenAccountListV2,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenAccountsByDelegateV2ResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetCompressedTokenAccountsByDelegateV2ResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TokenAccountListV2>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<
            PostGetCompressedTokenAccountsByDelegateV2ResponseResult,
        > for super::PostGetCompressedTokenAccountsByDelegateV2ResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountsByDelegateV2ResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressedTokenAccountsByDelegateV2ResponseResult,
        > for PostGetCompressedTokenAccountsByDelegateV2ResponseResult {
            fn from(
                value: super::PostGetCompressedTokenAccountsByDelegateV2ResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountsByOwnerBody {
            id: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByOwnerBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByOwnerBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByOwnerBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByOwnerBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedTokenAccountsByOwnerBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetCompressedTokenAccountsByOwnerBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByOwnerBodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByOwnerBodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByOwnerBodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByOwnerBodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenAccountsByOwnerBody>
        for super::PostGetCompressedTokenAccountsByOwnerBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountsByOwnerBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedTokenAccountsByOwnerBody>
        for PostGetCompressedTokenAccountsByOwnerBody {
            fn from(value: super::PostGetCompressedTokenAccountsByOwnerBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountsByOwnerBodyParams {
            cursor: ::std::result::Result<
                ::std::option::Option<super::Base58String>,
                ::std::string::String,
            >,
            limit: ::std::result::Result<
                ::std::option::Option<super::Limit>,
                ::std::string::String,
            >,
            mint: ::std::result::Result<
                ::std::option::Option<super::SerializablePubkey>,
                ::std::string::String,
            >,
            owner: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenAccountsByOwnerBodyParams {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    limit: Ok(Default::default()),
                    mint: Ok(Default::default()),
                    owner: Err("no value supplied for owner".to_string()),
                }
            }
        }
        impl PostGetCompressedTokenAccountsByOwnerBodyParams {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Base58String>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Limit>>,
                T::Error: ::std::fmt::Display,
            {
                self.limit = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for limit: {e}")
                    });
                self
            }
            pub fn mint<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::SerializablePubkey>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.mint = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for mint: {e}")
                    });
                self
            }
            pub fn owner<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.owner = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for owner: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenAccountsByOwnerBodyParams>
        for super::PostGetCompressedTokenAccountsByOwnerBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountsByOwnerBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    limit: value.limit?,
                    mint: value.mint?,
                    owner: value.owner?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedTokenAccountsByOwnerBodyParams>
        for PostGetCompressedTokenAccountsByOwnerBodyParams {
            fn from(
                value: super::PostGetCompressedTokenAccountsByOwnerBodyParams,
            ) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    limit: Ok(value.limit),
                    mint: Ok(value.mint),
                    owner: Ok(value.owner),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountsByOwnerResponse {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedTokenAccountsByOwnerResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByOwnerResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByOwnerResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedTokenAccountsByOwnerResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedTokenAccountsByOwnerResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedTokenAccountsByOwnerResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedTokenAccountsByOwnerResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByOwnerResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByOwnerResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedTokenAccountsByOwnerResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenAccountsByOwnerResponse>
        for super::PostGetCompressedTokenAccountsByOwnerResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountsByOwnerResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedTokenAccountsByOwnerResponse>
        for PostGetCompressedTokenAccountsByOwnerResponse {
            fn from(
                value: super::PostGetCompressedTokenAccountsByOwnerResponse,
            ) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountsByOwnerResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenAccountsByOwnerResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedTokenAccountsByOwnerResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenAccountsByOwnerResponseError>
        for super::PostGetCompressedTokenAccountsByOwnerResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountsByOwnerResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressedTokenAccountsByOwnerResponseError,
        > for PostGetCompressedTokenAccountsByOwnerResponseError {
            fn from(
                value: super::PostGetCompressedTokenAccountsByOwnerResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountsByOwnerResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<super::TokenAccountList, ::std::string::String>,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenAccountsByOwnerResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetCompressedTokenAccountsByOwnerResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TokenAccountList>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenAccountsByOwnerResponseResult>
        for super::PostGetCompressedTokenAccountsByOwnerResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountsByOwnerResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressedTokenAccountsByOwnerResponseResult,
        > for PostGetCompressedTokenAccountsByOwnerResponseResult {
            fn from(
                value: super::PostGetCompressedTokenAccountsByOwnerResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountsByOwnerV2Body {
            id: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByOwnerV2BodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByOwnerV2BodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByOwnerV2BodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByOwnerV2BodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedTokenAccountsByOwnerV2Body {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetCompressedTokenAccountsByOwnerV2Body {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByOwnerV2BodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByOwnerV2BodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByOwnerV2BodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByOwnerV2BodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenAccountsByOwnerV2Body>
        for super::PostGetCompressedTokenAccountsByOwnerV2Body {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountsByOwnerV2Body,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedTokenAccountsByOwnerV2Body>
        for PostGetCompressedTokenAccountsByOwnerV2Body {
            fn from(value: super::PostGetCompressedTokenAccountsByOwnerV2Body) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountsByOwnerV2BodyParams {
            cursor: ::std::result::Result<
                ::std::option::Option<super::Base58String>,
                ::std::string::String,
            >,
            limit: ::std::result::Result<
                ::std::option::Option<super::Limit>,
                ::std::string::String,
            >,
            mint: ::std::result::Result<
                ::std::option::Option<super::SerializablePubkey>,
                ::std::string::String,
            >,
            owner: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenAccountsByOwnerV2BodyParams {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    limit: Ok(Default::default()),
                    mint: Ok(Default::default()),
                    owner: Err("no value supplied for owner".to_string()),
                }
            }
        }
        impl PostGetCompressedTokenAccountsByOwnerV2BodyParams {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Base58String>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Limit>>,
                T::Error: ::std::fmt::Display,
            {
                self.limit = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for limit: {e}")
                    });
                self
            }
            pub fn mint<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::SerializablePubkey>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.mint = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for mint: {e}")
                    });
                self
            }
            pub fn owner<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.owner = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for owner: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenAccountsByOwnerV2BodyParams>
        for super::PostGetCompressedTokenAccountsByOwnerV2BodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountsByOwnerV2BodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    limit: value.limit?,
                    mint: value.mint?,
                    owner: value.owner?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressedTokenAccountsByOwnerV2BodyParams,
        > for PostGetCompressedTokenAccountsByOwnerV2BodyParams {
            fn from(
                value: super::PostGetCompressedTokenAccountsByOwnerV2BodyParams,
            ) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    limit: Ok(value.limit),
                    mint: Ok(value.mint),
                    owner: Ok(value.owner),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountsByOwnerV2Response {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedTokenAccountsByOwnerV2ResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByOwnerV2ResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedTokenAccountsByOwnerV2ResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedTokenAccountsByOwnerV2ResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenAccountsByOwnerV2Response {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedTokenAccountsByOwnerV2Response {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedTokenAccountsByOwnerV2ResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByOwnerV2ResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenAccountsByOwnerV2ResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedTokenAccountsByOwnerV2ResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenAccountsByOwnerV2Response>
        for super::PostGetCompressedTokenAccountsByOwnerV2Response {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountsByOwnerV2Response,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedTokenAccountsByOwnerV2Response>
        for PostGetCompressedTokenAccountsByOwnerV2Response {
            fn from(
                value: super::PostGetCompressedTokenAccountsByOwnerV2Response,
            ) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountsByOwnerV2ResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenAccountsByOwnerV2ResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedTokenAccountsByOwnerV2ResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<
            PostGetCompressedTokenAccountsByOwnerV2ResponseError,
        > for super::PostGetCompressedTokenAccountsByOwnerV2ResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountsByOwnerV2ResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressedTokenAccountsByOwnerV2ResponseError,
        > for PostGetCompressedTokenAccountsByOwnerV2ResponseError {
            fn from(
                value: super::PostGetCompressedTokenAccountsByOwnerV2ResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenAccountsByOwnerV2ResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                super::TokenAccountListV2,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenAccountsByOwnerV2ResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetCompressedTokenAccountsByOwnerV2ResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TokenAccountListV2>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<
            PostGetCompressedTokenAccountsByOwnerV2ResponseResult,
        > for super::PostGetCompressedTokenAccountsByOwnerV2ResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenAccountsByOwnerV2ResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressedTokenAccountsByOwnerV2ResponseResult,
        > for PostGetCompressedTokenAccountsByOwnerV2ResponseResult {
            fn from(
                value: super::PostGetCompressedTokenAccountsByOwnerV2ResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenBalancesByOwnerBody {
            id: ::std::result::Result<
                super::PostGetCompressedTokenBalancesByOwnerBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedTokenBalancesByOwnerBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetCompressedTokenBalancesByOwnerBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetCompressedTokenBalancesByOwnerBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedTokenBalancesByOwnerBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetCompressedTokenBalancesByOwnerBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenBalancesByOwnerBodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenBalancesByOwnerBodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenBalancesByOwnerBodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenBalancesByOwnerBodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenBalancesByOwnerBody>
        for super::PostGetCompressedTokenBalancesByOwnerBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenBalancesByOwnerBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedTokenBalancesByOwnerBody>
        for PostGetCompressedTokenBalancesByOwnerBody {
            fn from(value: super::PostGetCompressedTokenBalancesByOwnerBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenBalancesByOwnerBodyParams {
            cursor: ::std::result::Result<
                ::std::option::Option<super::Base58String>,
                ::std::string::String,
            >,
            limit: ::std::result::Result<
                ::std::option::Option<super::Limit>,
                ::std::string::String,
            >,
            mint: ::std::result::Result<
                ::std::option::Option<super::SerializablePubkey>,
                ::std::string::String,
            >,
            owner: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenBalancesByOwnerBodyParams {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    limit: Ok(Default::default()),
                    mint: Ok(Default::default()),
                    owner: Err("no value supplied for owner".to_string()),
                }
            }
        }
        impl PostGetCompressedTokenBalancesByOwnerBodyParams {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Base58String>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Limit>>,
                T::Error: ::std::fmt::Display,
            {
                self.limit = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for limit: {e}")
                    });
                self
            }
            pub fn mint<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::SerializablePubkey>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.mint = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for mint: {e}")
                    });
                self
            }
            pub fn owner<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.owner = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for owner: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenBalancesByOwnerBodyParams>
        for super::PostGetCompressedTokenBalancesByOwnerBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenBalancesByOwnerBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    limit: value.limit?,
                    mint: value.mint?,
                    owner: value.owner?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedTokenBalancesByOwnerBodyParams>
        for PostGetCompressedTokenBalancesByOwnerBodyParams {
            fn from(
                value: super::PostGetCompressedTokenBalancesByOwnerBodyParams,
            ) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    limit: Ok(value.limit),
                    mint: Ok(value.mint),
                    owner: Ok(value.owner),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenBalancesByOwnerResponse {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedTokenBalancesByOwnerResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetCompressedTokenBalancesByOwnerResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedTokenBalancesByOwnerResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedTokenBalancesByOwnerResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedTokenBalancesByOwnerResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedTokenBalancesByOwnerResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedTokenBalancesByOwnerResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenBalancesByOwnerResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenBalancesByOwnerResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedTokenBalancesByOwnerResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenBalancesByOwnerResponse>
        for super::PostGetCompressedTokenBalancesByOwnerResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenBalancesByOwnerResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedTokenBalancesByOwnerResponse>
        for PostGetCompressedTokenBalancesByOwnerResponse {
            fn from(
                value: super::PostGetCompressedTokenBalancesByOwnerResponse,
            ) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenBalancesByOwnerResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenBalancesByOwnerResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedTokenBalancesByOwnerResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenBalancesByOwnerResponseError>
        for super::PostGetCompressedTokenBalancesByOwnerResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenBalancesByOwnerResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressedTokenBalancesByOwnerResponseError,
        > for PostGetCompressedTokenBalancesByOwnerResponseError {
            fn from(
                value: super::PostGetCompressedTokenBalancesByOwnerResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenBalancesByOwnerResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<super::TokenBalanceList, ::std::string::String>,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenBalancesByOwnerResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetCompressedTokenBalancesByOwnerResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TokenBalanceList>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenBalancesByOwnerResponseResult>
        for super::PostGetCompressedTokenBalancesByOwnerResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenBalancesByOwnerResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressedTokenBalancesByOwnerResponseResult,
        > for PostGetCompressedTokenBalancesByOwnerResponseResult {
            fn from(
                value: super::PostGetCompressedTokenBalancesByOwnerResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenBalancesByOwnerV2Body {
            id: ::std::result::Result<
                super::PostGetCompressedTokenBalancesByOwnerV2BodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedTokenBalancesByOwnerV2BodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetCompressedTokenBalancesByOwnerV2BodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetCompressedTokenBalancesByOwnerV2BodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressedTokenBalancesByOwnerV2Body {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetCompressedTokenBalancesByOwnerV2Body {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenBalancesByOwnerV2BodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenBalancesByOwnerV2BodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenBalancesByOwnerV2BodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenBalancesByOwnerV2BodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenBalancesByOwnerV2Body>
        for super::PostGetCompressedTokenBalancesByOwnerV2Body {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenBalancesByOwnerV2Body,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedTokenBalancesByOwnerV2Body>
        for PostGetCompressedTokenBalancesByOwnerV2Body {
            fn from(value: super::PostGetCompressedTokenBalancesByOwnerV2Body) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenBalancesByOwnerV2BodyParams {
            cursor: ::std::result::Result<
                ::std::option::Option<super::Base58String>,
                ::std::string::String,
            >,
            limit: ::std::result::Result<
                ::std::option::Option<super::Limit>,
                ::std::string::String,
            >,
            mint: ::std::result::Result<
                ::std::option::Option<super::SerializablePubkey>,
                ::std::string::String,
            >,
            owner: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenBalancesByOwnerV2BodyParams {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    limit: Ok(Default::default()),
                    mint: Ok(Default::default()),
                    owner: Err("no value supplied for owner".to_string()),
                }
            }
        }
        impl PostGetCompressedTokenBalancesByOwnerV2BodyParams {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Base58String>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Limit>>,
                T::Error: ::std::fmt::Display,
            {
                self.limit = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for limit: {e}")
                    });
                self
            }
            pub fn mint<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::SerializablePubkey>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.mint = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for mint: {e}")
                    });
                self
            }
            pub fn owner<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.owner = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for owner: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenBalancesByOwnerV2BodyParams>
        for super::PostGetCompressedTokenBalancesByOwnerV2BodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenBalancesByOwnerV2BodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    limit: value.limit?,
                    mint: value.mint?,
                    owner: value.owner?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressedTokenBalancesByOwnerV2BodyParams,
        > for PostGetCompressedTokenBalancesByOwnerV2BodyParams {
            fn from(
                value: super::PostGetCompressedTokenBalancesByOwnerV2BodyParams,
            ) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    limit: Ok(value.limit),
                    mint: Ok(value.mint),
                    owner: Ok(value.owner),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenBalancesByOwnerV2Response {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedTokenBalancesByOwnerV2ResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetCompressedTokenBalancesByOwnerV2ResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressedTokenBalancesByOwnerV2ResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressedTokenBalancesByOwnerV2ResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenBalancesByOwnerV2Response {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedTokenBalancesByOwnerV2Response {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedTokenBalancesByOwnerV2ResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenBalancesByOwnerV2ResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressedTokenBalancesByOwnerV2ResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressedTokenBalancesByOwnerV2ResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressedTokenBalancesByOwnerV2Response>
        for super::PostGetCompressedTokenBalancesByOwnerV2Response {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenBalancesByOwnerV2Response,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressedTokenBalancesByOwnerV2Response>
        for PostGetCompressedTokenBalancesByOwnerV2Response {
            fn from(
                value: super::PostGetCompressedTokenBalancesByOwnerV2Response,
            ) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenBalancesByOwnerV2ResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenBalancesByOwnerV2ResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressedTokenBalancesByOwnerV2ResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<
            PostGetCompressedTokenBalancesByOwnerV2ResponseError,
        > for super::PostGetCompressedTokenBalancesByOwnerV2ResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenBalancesByOwnerV2ResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressedTokenBalancesByOwnerV2ResponseError,
        > for PostGetCompressedTokenBalancesByOwnerV2ResponseError {
            fn from(
                value: super::PostGetCompressedTokenBalancesByOwnerV2ResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressedTokenBalancesByOwnerV2ResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                super::TokenBalanceListV2,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressedTokenBalancesByOwnerV2ResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetCompressedTokenBalancesByOwnerV2ResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TokenBalanceListV2>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<
            PostGetCompressedTokenBalancesByOwnerV2ResponseResult,
        > for super::PostGetCompressedTokenBalancesByOwnerV2ResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressedTokenBalancesByOwnerV2ResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressedTokenBalancesByOwnerV2ResponseResult,
        > for PostGetCompressedTokenBalancesByOwnerV2ResponseResult {
            fn from(
                value: super::PostGetCompressedTokenBalancesByOwnerV2ResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressionSignaturesForAccountBody {
            id: ::std::result::Result<
                super::PostGetCompressionSignaturesForAccountBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressionSignaturesForAccountBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetCompressionSignaturesForAccountBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetCompressionSignaturesForAccountBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressionSignaturesForAccountBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetCompressionSignaturesForAccountBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForAccountBodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForAccountBodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForAccountBodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForAccountBodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressionSignaturesForAccountBody>
        for super::PostGetCompressionSignaturesForAccountBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressionSignaturesForAccountBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressionSignaturesForAccountBody>
        for PostGetCompressionSignaturesForAccountBody {
            fn from(value: super::PostGetCompressionSignaturesForAccountBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressionSignaturesForAccountBodyParams {
            hash: ::std::result::Result<super::Hash, ::std::string::String>,
        }
        impl ::std::default::Default
        for PostGetCompressionSignaturesForAccountBodyParams {
            fn default() -> Self {
                Self {
                    hash: Err("no value supplied for hash".to_string()),
                }
            }
        }
        impl PostGetCompressionSignaturesForAccountBodyParams {
            pub fn hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Hash>,
                T::Error: ::std::fmt::Display,
            {
                self.hash = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for hash: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressionSignaturesForAccountBodyParams>
        for super::PostGetCompressionSignaturesForAccountBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressionSignaturesForAccountBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { hash: value.hash? })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressionSignaturesForAccountBodyParams,
        > for PostGetCompressionSignaturesForAccountBodyParams {
            fn from(
                value: super::PostGetCompressionSignaturesForAccountBodyParams,
            ) -> Self {
                Self { hash: Ok(value.hash) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressionSignaturesForAccountResponse {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressionSignaturesForAccountResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetCompressionSignaturesForAccountResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressionSignaturesForAccountResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressionSignaturesForAccountResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressionSignaturesForAccountResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressionSignaturesForAccountResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressionSignaturesForAccountResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForAccountResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForAccountResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressionSignaturesForAccountResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressionSignaturesForAccountResponse>
        for super::PostGetCompressionSignaturesForAccountResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressionSignaturesForAccountResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressionSignaturesForAccountResponse>
        for PostGetCompressionSignaturesForAccountResponse {
            fn from(
                value: super::PostGetCompressionSignaturesForAccountResponse,
            ) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressionSignaturesForAccountResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressionSignaturesForAccountResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressionSignaturesForAccountResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressionSignaturesForAccountResponseError>
        for super::PostGetCompressionSignaturesForAccountResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressionSignaturesForAccountResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressionSignaturesForAccountResponseError,
        > for PostGetCompressionSignaturesForAccountResponseError {
            fn from(
                value: super::PostGetCompressionSignaturesForAccountResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressionSignaturesForAccountResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                super::SignatureInfoList,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressionSignaturesForAccountResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetCompressionSignaturesForAccountResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignatureInfoList>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<
            PostGetCompressionSignaturesForAccountResponseResult,
        > for super::PostGetCompressionSignaturesForAccountResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressionSignaturesForAccountResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressionSignaturesForAccountResponseResult,
        > for PostGetCompressionSignaturesForAccountResponseResult {
            fn from(
                value: super::PostGetCompressionSignaturesForAccountResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressionSignaturesForAddressBody {
            id: ::std::result::Result<
                super::PostGetCompressionSignaturesForAddressBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressionSignaturesForAddressBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetCompressionSignaturesForAddressBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetCompressionSignaturesForAddressBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressionSignaturesForAddressBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetCompressionSignaturesForAddressBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForAddressBodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForAddressBodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForAddressBodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForAddressBodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressionSignaturesForAddressBody>
        for super::PostGetCompressionSignaturesForAddressBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressionSignaturesForAddressBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressionSignaturesForAddressBody>
        for PostGetCompressionSignaturesForAddressBody {
            fn from(value: super::PostGetCompressionSignaturesForAddressBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressionSignaturesForAddressBodyParams {
            address: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
            cursor: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            limit: ::std::result::Result<
                ::std::option::Option<super::Limit>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressionSignaturesForAddressBodyParams {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    cursor: Ok(Default::default()),
                    limit: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressionSignaturesForAddressBodyParams {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address: {e}")
                    });
                self
            }
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Limit>>,
                T::Error: ::std::fmt::Display,
            {
                self.limit = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for limit: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressionSignaturesForAddressBodyParams>
        for super::PostGetCompressionSignaturesForAddressBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressionSignaturesForAddressBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    cursor: value.cursor?,
                    limit: value.limit?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressionSignaturesForAddressBodyParams,
        > for PostGetCompressionSignaturesForAddressBodyParams {
            fn from(
                value: super::PostGetCompressionSignaturesForAddressBodyParams,
            ) -> Self {
                Self {
                    address: Ok(value.address),
                    cursor: Ok(value.cursor),
                    limit: Ok(value.limit),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressionSignaturesForAddressResponse {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressionSignaturesForAddressResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetCompressionSignaturesForAddressResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressionSignaturesForAddressResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressionSignaturesForAddressResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressionSignaturesForAddressResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressionSignaturesForAddressResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressionSignaturesForAddressResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForAddressResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForAddressResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressionSignaturesForAddressResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressionSignaturesForAddressResponse>
        for super::PostGetCompressionSignaturesForAddressResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressionSignaturesForAddressResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressionSignaturesForAddressResponse>
        for PostGetCompressionSignaturesForAddressResponse {
            fn from(
                value: super::PostGetCompressionSignaturesForAddressResponse,
            ) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressionSignaturesForAddressResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressionSignaturesForAddressResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressionSignaturesForAddressResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressionSignaturesForAddressResponseError>
        for super::PostGetCompressionSignaturesForAddressResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressionSignaturesForAddressResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressionSignaturesForAddressResponseError,
        > for PostGetCompressionSignaturesForAddressResponseError {
            fn from(
                value: super::PostGetCompressionSignaturesForAddressResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressionSignaturesForAddressResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                super::PaginatedSignatureInfoList,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressionSignaturesForAddressResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetCompressionSignaturesForAddressResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PaginatedSignatureInfoList>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<
            PostGetCompressionSignaturesForAddressResponseResult,
        > for super::PostGetCompressionSignaturesForAddressResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressionSignaturesForAddressResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressionSignaturesForAddressResponseResult,
        > for PostGetCompressionSignaturesForAddressResponseResult {
            fn from(
                value: super::PostGetCompressionSignaturesForAddressResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressionSignaturesForOwnerBody {
            id: ::std::result::Result<
                super::PostGetCompressionSignaturesForOwnerBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressionSignaturesForOwnerBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetCompressionSignaturesForOwnerBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetCompressionSignaturesForOwnerBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressionSignaturesForOwnerBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetCompressionSignaturesForOwnerBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForOwnerBodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForOwnerBodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForOwnerBodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForOwnerBodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressionSignaturesForOwnerBody>
        for super::PostGetCompressionSignaturesForOwnerBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressionSignaturesForOwnerBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressionSignaturesForOwnerBody>
        for PostGetCompressionSignaturesForOwnerBody {
            fn from(value: super::PostGetCompressionSignaturesForOwnerBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressionSignaturesForOwnerBodyParams {
            cursor: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            limit: ::std::result::Result<
                ::std::option::Option<super::Limit>,
                ::std::string::String,
            >,
            owner: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressionSignaturesForOwnerBodyParams {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    limit: Ok(Default::default()),
                    owner: Err("no value supplied for owner".to_string()),
                }
            }
        }
        impl PostGetCompressionSignaturesForOwnerBodyParams {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Limit>>,
                T::Error: ::std::fmt::Display,
            {
                self.limit = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for limit: {e}")
                    });
                self
            }
            pub fn owner<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.owner = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for owner: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressionSignaturesForOwnerBodyParams>
        for super::PostGetCompressionSignaturesForOwnerBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressionSignaturesForOwnerBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    limit: value.limit?,
                    owner: value.owner?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressionSignaturesForOwnerBodyParams>
        for PostGetCompressionSignaturesForOwnerBodyParams {
            fn from(
                value: super::PostGetCompressionSignaturesForOwnerBodyParams,
            ) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    limit: Ok(value.limit),
                    owner: Ok(value.owner),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressionSignaturesForOwnerResponse {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressionSignaturesForOwnerResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetCompressionSignaturesForOwnerResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressionSignaturesForOwnerResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressionSignaturesForOwnerResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressionSignaturesForOwnerResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressionSignaturesForOwnerResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressionSignaturesForOwnerResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForOwnerResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForOwnerResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressionSignaturesForOwnerResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressionSignaturesForOwnerResponse>
        for super::PostGetCompressionSignaturesForOwnerResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressionSignaturesForOwnerResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressionSignaturesForOwnerResponse>
        for PostGetCompressionSignaturesForOwnerResponse {
            fn from(value: super::PostGetCompressionSignaturesForOwnerResponse) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressionSignaturesForOwnerResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressionSignaturesForOwnerResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressionSignaturesForOwnerResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressionSignaturesForOwnerResponseError>
        for super::PostGetCompressionSignaturesForOwnerResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressionSignaturesForOwnerResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressionSignaturesForOwnerResponseError,
        > for PostGetCompressionSignaturesForOwnerResponseError {
            fn from(
                value: super::PostGetCompressionSignaturesForOwnerResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressionSignaturesForOwnerResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                super::PaginatedSignatureInfoList,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressionSignaturesForOwnerResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetCompressionSignaturesForOwnerResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PaginatedSignatureInfoList>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressionSignaturesForOwnerResponseResult>
        for super::PostGetCompressionSignaturesForOwnerResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressionSignaturesForOwnerResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressionSignaturesForOwnerResponseResult,
        > for PostGetCompressionSignaturesForOwnerResponseResult {
            fn from(
                value: super::PostGetCompressionSignaturesForOwnerResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressionSignaturesForTokenOwnerBody {
            id: ::std::result::Result<
                super::PostGetCompressionSignaturesForTokenOwnerBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressionSignaturesForTokenOwnerBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetCompressionSignaturesForTokenOwnerBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetCompressionSignaturesForTokenOwnerBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetCompressionSignaturesForTokenOwnerBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetCompressionSignaturesForTokenOwnerBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForTokenOwnerBodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForTokenOwnerBodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForTokenOwnerBodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForTokenOwnerBodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressionSignaturesForTokenOwnerBody>
        for super::PostGetCompressionSignaturesForTokenOwnerBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressionSignaturesForTokenOwnerBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetCompressionSignaturesForTokenOwnerBody>
        for PostGetCompressionSignaturesForTokenOwnerBody {
            fn from(
                value: super::PostGetCompressionSignaturesForTokenOwnerBody,
            ) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressionSignaturesForTokenOwnerBodyParams {
            cursor: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            limit: ::std::result::Result<
                ::std::option::Option<super::Limit>,
                ::std::string::String,
            >,
            owner: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressionSignaturesForTokenOwnerBodyParams {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    limit: Ok(Default::default()),
                    owner: Err("no value supplied for owner".to_string()),
                }
            }
        }
        impl PostGetCompressionSignaturesForTokenOwnerBodyParams {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Limit>>,
                T::Error: ::std::fmt::Display,
            {
                self.limit = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for limit: {e}")
                    });
                self
            }
            pub fn owner<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.owner = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for owner: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressionSignaturesForTokenOwnerBodyParams>
        for super::PostGetCompressionSignaturesForTokenOwnerBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressionSignaturesForTokenOwnerBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    limit: value.limit?,
                    owner: value.owner?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressionSignaturesForTokenOwnerBodyParams,
        > for PostGetCompressionSignaturesForTokenOwnerBodyParams {
            fn from(
                value: super::PostGetCompressionSignaturesForTokenOwnerBodyParams,
            ) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    limit: Ok(value.limit),
                    owner: Ok(value.owner),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressionSignaturesForTokenOwnerResponse {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressionSignaturesForTokenOwnerResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetCompressionSignaturesForTokenOwnerResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetCompressionSignaturesForTokenOwnerResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetCompressionSignaturesForTokenOwnerResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressionSignaturesForTokenOwnerResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressionSignaturesForTokenOwnerResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressionSignaturesForTokenOwnerResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForTokenOwnerResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetCompressionSignaturesForTokenOwnerResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetCompressionSignaturesForTokenOwnerResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetCompressionSignaturesForTokenOwnerResponse>
        for super::PostGetCompressionSignaturesForTokenOwnerResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressionSignaturesForTokenOwnerResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressionSignaturesForTokenOwnerResponse,
        > for PostGetCompressionSignaturesForTokenOwnerResponse {
            fn from(
                value: super::PostGetCompressionSignaturesForTokenOwnerResponse,
            ) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressionSignaturesForTokenOwnerResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressionSignaturesForTokenOwnerResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetCompressionSignaturesForTokenOwnerResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<
            PostGetCompressionSignaturesForTokenOwnerResponseError,
        > for super::PostGetCompressionSignaturesForTokenOwnerResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressionSignaturesForTokenOwnerResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressionSignaturesForTokenOwnerResponseError,
        > for PostGetCompressionSignaturesForTokenOwnerResponseError {
            fn from(
                value: super::PostGetCompressionSignaturesForTokenOwnerResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetCompressionSignaturesForTokenOwnerResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                super::PaginatedSignatureInfoList,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetCompressionSignaturesForTokenOwnerResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetCompressionSignaturesForTokenOwnerResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PaginatedSignatureInfoList>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<
            PostGetCompressionSignaturesForTokenOwnerResponseResult,
        > for super::PostGetCompressionSignaturesForTokenOwnerResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetCompressionSignaturesForTokenOwnerResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetCompressionSignaturesForTokenOwnerResponseResult,
        > for PostGetCompressionSignaturesForTokenOwnerResponseResult {
            fn from(
                value: super::PostGetCompressionSignaturesForTokenOwnerResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetIndexerHealthBody {
            id: ::std::result::Result<
                super::PostGetIndexerHealthBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetIndexerHealthBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetIndexerHealthBodyMethod,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetIndexerHealthBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                }
            }
        }
        impl PostGetIndexerHealthBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetIndexerHealthBodyId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetIndexerHealthBodyJsonrpc>,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetIndexerHealthBodyMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetIndexerHealthBody>
        for super::PostGetIndexerHealthBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetIndexerHealthBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetIndexerHealthBody>
        for PostGetIndexerHealthBody {
            fn from(value: super::PostGetIndexerHealthBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetIndexerHealthResponse {
            error: ::std::result::Result<
                ::std::option::Option<super::PostGetIndexerHealthResponseError>,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetIndexerHealthResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetIndexerHealthResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                super::PostGetIndexerHealthResponseResult,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetIndexerHealthResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(
                        super::defaults::post_get_indexer_health_response_result(),
                    ),
                }
            }
        }
        impl PostGetIndexerHealthResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::PostGetIndexerHealthResponseError>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetIndexerHealthResponseId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetIndexerHealthResponseJsonrpc>,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetIndexerHealthResponseResult>,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetIndexerHealthResponse>
        for super::PostGetIndexerHealthResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetIndexerHealthResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetIndexerHealthResponse>
        for PostGetIndexerHealthResponse {
            fn from(value: super::PostGetIndexerHealthResponse) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetIndexerHealthResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetIndexerHealthResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetIndexerHealthResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetIndexerHealthResponseError>
        for super::PostGetIndexerHealthResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetIndexerHealthResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetIndexerHealthResponseError>
        for PostGetIndexerHealthResponseError {
            fn from(value: super::PostGetIndexerHealthResponseError) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetIndexerSlotBody {
            id: ::std::result::Result<
                super::PostGetIndexerSlotBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetIndexerSlotBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetIndexerSlotBodyMethod,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetIndexerSlotBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                }
            }
        }
        impl PostGetIndexerSlotBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetIndexerSlotBodyId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetIndexerSlotBodyJsonrpc>,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetIndexerSlotBodyMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetIndexerSlotBody>
        for super::PostGetIndexerSlotBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetIndexerSlotBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetIndexerSlotBody>
        for PostGetIndexerSlotBody {
            fn from(value: super::PostGetIndexerSlotBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetIndexerSlotResponse {
            error: ::std::result::Result<
                ::std::option::Option<super::PostGetIndexerSlotResponseError>,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetIndexerSlotResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetIndexerSlotResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for PostGetIndexerSlotResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(super::defaults::default_u64::<u64, 100>()),
                }
            }
        }
        impl PostGetIndexerSlotResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::PostGetIndexerSlotResponseError>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetIndexerSlotResponseId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetIndexerSlotResponseJsonrpc>,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetIndexerSlotResponse>
        for super::PostGetIndexerSlotResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetIndexerSlotResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetIndexerSlotResponse>
        for PostGetIndexerSlotResponse {
            fn from(value: super::PostGetIndexerSlotResponse) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetIndexerSlotResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetIndexerSlotResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetIndexerSlotResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetIndexerSlotResponseError>
        for super::PostGetIndexerSlotResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetIndexerSlotResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetIndexerSlotResponseError>
        for PostGetIndexerSlotResponseError {
            fn from(value: super::PostGetIndexerSlotResponseError) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetLatestCompressionSignaturesBody {
            id: ::std::result::Result<
                super::PostGetLatestCompressionSignaturesBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetLatestCompressionSignaturesBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetLatestCompressionSignaturesBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetLatestCompressionSignaturesBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetLatestCompressionSignaturesBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetLatestCompressionSignaturesBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetLatestCompressionSignaturesBodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetLatestCompressionSignaturesBodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetLatestCompressionSignaturesBodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetLatestCompressionSignaturesBodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetLatestCompressionSignaturesBody>
        for super::PostGetLatestCompressionSignaturesBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetLatestCompressionSignaturesBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetLatestCompressionSignaturesBody>
        for PostGetLatestCompressionSignaturesBody {
            fn from(value: super::PostGetLatestCompressionSignaturesBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetLatestCompressionSignaturesBodyParams {
            cursor: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            limit: ::std::result::Result<
                ::std::option::Option<super::Limit>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetLatestCompressionSignaturesBodyParams {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    limit: Ok(Default::default()),
                }
            }
        }
        impl PostGetLatestCompressionSignaturesBodyParams {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Limit>>,
                T::Error: ::std::fmt::Display,
            {
                self.limit = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for limit: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetLatestCompressionSignaturesBodyParams>
        for super::PostGetLatestCompressionSignaturesBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetLatestCompressionSignaturesBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    limit: value.limit?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetLatestCompressionSignaturesBodyParams>
        for PostGetLatestCompressionSignaturesBodyParams {
            fn from(value: super::PostGetLatestCompressionSignaturesBodyParams) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    limit: Ok(value.limit),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetLatestCompressionSignaturesResponse {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetLatestCompressionSignaturesResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetLatestCompressionSignaturesResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetLatestCompressionSignaturesResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetLatestCompressionSignaturesResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetLatestCompressionSignaturesResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetLatestCompressionSignaturesResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetLatestCompressionSignaturesResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetLatestCompressionSignaturesResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetLatestCompressionSignaturesResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetLatestCompressionSignaturesResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetLatestCompressionSignaturesResponse>
        for super::PostGetLatestCompressionSignaturesResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetLatestCompressionSignaturesResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetLatestCompressionSignaturesResponse>
        for PostGetLatestCompressionSignaturesResponse {
            fn from(value: super::PostGetLatestCompressionSignaturesResponse) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetLatestCompressionSignaturesResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetLatestCompressionSignaturesResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetLatestCompressionSignaturesResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetLatestCompressionSignaturesResponseError>
        for super::PostGetLatestCompressionSignaturesResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetLatestCompressionSignaturesResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetLatestCompressionSignaturesResponseError>
        for PostGetLatestCompressionSignaturesResponseError {
            fn from(
                value: super::PostGetLatestCompressionSignaturesResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetLatestCompressionSignaturesResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                super::PaginatedSignatureInfoList,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetLatestCompressionSignaturesResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetLatestCompressionSignaturesResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PaginatedSignatureInfoList>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetLatestCompressionSignaturesResponseResult>
        for super::PostGetLatestCompressionSignaturesResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetLatestCompressionSignaturesResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetLatestCompressionSignaturesResponseResult,
        > for PostGetLatestCompressionSignaturesResponseResult {
            fn from(
                value: super::PostGetLatestCompressionSignaturesResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetLatestNonVotingSignaturesBody {
            id: ::std::result::Result<
                super::PostGetLatestNonVotingSignaturesBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetLatestNonVotingSignaturesBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetLatestNonVotingSignaturesBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetLatestNonVotingSignaturesBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetLatestNonVotingSignaturesBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetLatestNonVotingSignaturesBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetLatestNonVotingSignaturesBodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetLatestNonVotingSignaturesBodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetLatestNonVotingSignaturesBodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetLatestNonVotingSignaturesBodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetLatestNonVotingSignaturesBody>
        for super::PostGetLatestNonVotingSignaturesBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetLatestNonVotingSignaturesBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetLatestNonVotingSignaturesBody>
        for PostGetLatestNonVotingSignaturesBody {
            fn from(value: super::PostGetLatestNonVotingSignaturesBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetLatestNonVotingSignaturesBodyParams {
            cursor: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            limit: ::std::result::Result<
                ::std::option::Option<super::Limit>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetLatestNonVotingSignaturesBodyParams {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    limit: Ok(Default::default()),
                }
            }
        }
        impl PostGetLatestNonVotingSignaturesBodyParams {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Limit>>,
                T::Error: ::std::fmt::Display,
            {
                self.limit = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for limit: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetLatestNonVotingSignaturesBodyParams>
        for super::PostGetLatestNonVotingSignaturesBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetLatestNonVotingSignaturesBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    limit: value.limit?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetLatestNonVotingSignaturesBodyParams>
        for PostGetLatestNonVotingSignaturesBodyParams {
            fn from(value: super::PostGetLatestNonVotingSignaturesBodyParams) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    limit: Ok(value.limit),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetLatestNonVotingSignaturesResponse {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetLatestNonVotingSignaturesResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetLatestNonVotingSignaturesResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetLatestNonVotingSignaturesResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetLatestNonVotingSignaturesResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetLatestNonVotingSignaturesResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetLatestNonVotingSignaturesResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetLatestNonVotingSignaturesResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetLatestNonVotingSignaturesResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetLatestNonVotingSignaturesResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetLatestNonVotingSignaturesResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetLatestNonVotingSignaturesResponse>
        for super::PostGetLatestNonVotingSignaturesResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetLatestNonVotingSignaturesResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetLatestNonVotingSignaturesResponse>
        for PostGetLatestNonVotingSignaturesResponse {
            fn from(value: super::PostGetLatestNonVotingSignaturesResponse) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetLatestNonVotingSignaturesResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetLatestNonVotingSignaturesResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetLatestNonVotingSignaturesResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetLatestNonVotingSignaturesResponseError>
        for super::PostGetLatestNonVotingSignaturesResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetLatestNonVotingSignaturesResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetLatestNonVotingSignaturesResponseError>
        for PostGetLatestNonVotingSignaturesResponseError {
            fn from(
                value: super::PostGetLatestNonVotingSignaturesResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetLatestNonVotingSignaturesResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                super::SignatureInfoListWithError,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetLatestNonVotingSignaturesResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetLatestNonVotingSignaturesResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SignatureInfoListWithError>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetLatestNonVotingSignaturesResponseResult>
        for super::PostGetLatestNonVotingSignaturesResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetLatestNonVotingSignaturesResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetLatestNonVotingSignaturesResponseResult>
        for PostGetLatestNonVotingSignaturesResponseResult {
            fn from(
                value: super::PostGetLatestNonVotingSignaturesResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleAccountInterfacesBody {
            id: ::std::result::Result<
                super::PostGetMultipleAccountInterfacesBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetMultipleAccountInterfacesBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetMultipleAccountInterfacesBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetMultipleAccountInterfacesBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleAccountInterfacesBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetMultipleAccountInterfacesBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleAccountInterfacesBodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleAccountInterfacesBodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleAccountInterfacesBodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleAccountInterfacesBodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleAccountInterfacesBody>
        for super::PostGetMultipleAccountInterfacesBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleAccountInterfacesBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleAccountInterfacesBody>
        for PostGetMultipleAccountInterfacesBody {
            fn from(value: super::PostGetMultipleAccountInterfacesBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleAccountInterfacesBodyParams {
            addresses: ::std::result::Result<
                ::std::vec::Vec<super::SerializablePubkey>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleAccountInterfacesBodyParams {
            fn default() -> Self {
                Self {
                    addresses: Err("no value supplied for addresses".to_string()),
                }
            }
        }
        impl PostGetMultipleAccountInterfacesBodyParams {
            pub fn addresses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SerializablePubkey>>,
                T::Error: ::std::fmt::Display,
            {
                self.addresses = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for addresses: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleAccountInterfacesBodyParams>
        for super::PostGetMultipleAccountInterfacesBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleAccountInterfacesBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    addresses: value.addresses?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleAccountInterfacesBodyParams>
        for PostGetMultipleAccountInterfacesBodyParams {
            fn from(value: super::PostGetMultipleAccountInterfacesBodyParams) -> Self {
                Self {
                    addresses: Ok(value.addresses),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleAccountInterfacesResponse {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetMultipleAccountInterfacesResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetMultipleAccountInterfacesResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetMultipleAccountInterfacesResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetMultipleAccountInterfacesResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleAccountInterfacesResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetMultipleAccountInterfacesResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetMultipleAccountInterfacesResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleAccountInterfacesResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleAccountInterfacesResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetMultipleAccountInterfacesResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleAccountInterfacesResponse>
        for super::PostGetMultipleAccountInterfacesResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleAccountInterfacesResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleAccountInterfacesResponse>
        for PostGetMultipleAccountInterfacesResponse {
            fn from(value: super::PostGetMultipleAccountInterfacesResponse) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleAccountInterfacesResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleAccountInterfacesResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetMultipleAccountInterfacesResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleAccountInterfacesResponseError>
        for super::PostGetMultipleAccountInterfacesResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleAccountInterfacesResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleAccountInterfacesResponseError>
        for PostGetMultipleAccountInterfacesResponseError {
            fn from(
                value: super::PostGetMultipleAccountInterfacesResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleAccountInterfacesResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                ::std::vec::Vec<::std::option::Option<super::AccountInterface>>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleAccountInterfacesResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetMultipleAccountInterfacesResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<::std::option::Option<super::AccountInterface>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleAccountInterfacesResponseResult>
        for super::PostGetMultipleAccountInterfacesResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleAccountInterfacesResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleAccountInterfacesResponseResult>
        for PostGetMultipleAccountInterfacesResponseResult {
            fn from(
                value: super::PostGetMultipleAccountInterfacesResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleCompressedAccountProofsBody {
            id: ::std::result::Result<
                super::PostGetMultipleCompressedAccountProofsBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetMultipleCompressedAccountProofsBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetMultipleCompressedAccountProofsBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                ::std::vec::Vec<super::Hash>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleCompressedAccountProofsBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetMultipleCompressedAccountProofsBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountProofsBodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountProofsBodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountProofsBodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleCompressedAccountProofsBody>
        for super::PostGetMultipleCompressedAccountProofsBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleCompressedAccountProofsBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleCompressedAccountProofsBody>
        for PostGetMultipleCompressedAccountProofsBody {
            fn from(value: super::PostGetMultipleCompressedAccountProofsBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleCompressedAccountProofsResponse {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetMultipleCompressedAccountProofsResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetMultipleCompressedAccountProofsResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetMultipleCompressedAccountProofsResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetMultipleCompressedAccountProofsResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleCompressedAccountProofsResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetMultipleCompressedAccountProofsResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetMultipleCompressedAccountProofsResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountProofsResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountProofsResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetMultipleCompressedAccountProofsResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleCompressedAccountProofsResponse>
        for super::PostGetMultipleCompressedAccountProofsResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleCompressedAccountProofsResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleCompressedAccountProofsResponse>
        for PostGetMultipleCompressedAccountProofsResponse {
            fn from(
                value: super::PostGetMultipleCompressedAccountProofsResponse,
            ) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleCompressedAccountProofsResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetMultipleCompressedAccountProofsResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetMultipleCompressedAccountProofsResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleCompressedAccountProofsResponseError>
        for super::PostGetMultipleCompressedAccountProofsResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleCompressedAccountProofsResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetMultipleCompressedAccountProofsResponseError,
        > for PostGetMultipleCompressedAccountProofsResponseError {
            fn from(
                value: super::PostGetMultipleCompressedAccountProofsResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleCompressedAccountProofsResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                ::std::vec::Vec<super::GetCompressedAccountProofResponseValue>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetMultipleCompressedAccountProofsResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetMultipleCompressedAccountProofsResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::GetCompressedAccountProofResponseValue>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<
            PostGetMultipleCompressedAccountProofsResponseResult,
        > for super::PostGetMultipleCompressedAccountProofsResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleCompressedAccountProofsResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetMultipleCompressedAccountProofsResponseResult,
        > for PostGetMultipleCompressedAccountProofsResponseResult {
            fn from(
                value: super::PostGetMultipleCompressedAccountProofsResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleCompressedAccountProofsV2Body {
            id: ::std::result::Result<
                super::PostGetMultipleCompressedAccountProofsV2BodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetMultipleCompressedAccountProofsV2BodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetMultipleCompressedAccountProofsV2BodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                ::std::vec::Vec<super::Hash>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleCompressedAccountProofsV2Body {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetMultipleCompressedAccountProofsV2Body {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountProofsV2BodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountProofsV2BodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountProofsV2BodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleCompressedAccountProofsV2Body>
        for super::PostGetMultipleCompressedAccountProofsV2Body {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleCompressedAccountProofsV2Body,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleCompressedAccountProofsV2Body>
        for PostGetMultipleCompressedAccountProofsV2Body {
            fn from(value: super::PostGetMultipleCompressedAccountProofsV2Body) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleCompressedAccountProofsV2Response {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetMultipleCompressedAccountProofsV2ResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetMultipleCompressedAccountProofsV2ResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetMultipleCompressedAccountProofsV2ResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetMultipleCompressedAccountProofsV2ResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetMultipleCompressedAccountProofsV2Response {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetMultipleCompressedAccountProofsV2Response {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetMultipleCompressedAccountProofsV2ResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountProofsV2ResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountProofsV2ResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetMultipleCompressedAccountProofsV2ResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleCompressedAccountProofsV2Response>
        for super::PostGetMultipleCompressedAccountProofsV2Response {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleCompressedAccountProofsV2Response,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetMultipleCompressedAccountProofsV2Response,
        > for PostGetMultipleCompressedAccountProofsV2Response {
            fn from(
                value: super::PostGetMultipleCompressedAccountProofsV2Response,
            ) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleCompressedAccountProofsV2ResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetMultipleCompressedAccountProofsV2ResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetMultipleCompressedAccountProofsV2ResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<
            PostGetMultipleCompressedAccountProofsV2ResponseError,
        > for super::PostGetMultipleCompressedAccountProofsV2ResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleCompressedAccountProofsV2ResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetMultipleCompressedAccountProofsV2ResponseError,
        > for PostGetMultipleCompressedAccountProofsV2ResponseError {
            fn from(
                value: super::PostGetMultipleCompressedAccountProofsV2ResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleCompressedAccountProofsV2ResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                ::std::vec::Vec<super::GetCompressedAccountProofResponseValueV2>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetMultipleCompressedAccountProofsV2ResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetMultipleCompressedAccountProofsV2ResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::GetCompressedAccountProofResponseValueV2>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<
            PostGetMultipleCompressedAccountProofsV2ResponseResult,
        > for super::PostGetMultipleCompressedAccountProofsV2ResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleCompressedAccountProofsV2ResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetMultipleCompressedAccountProofsV2ResponseResult,
        > for PostGetMultipleCompressedAccountProofsV2ResponseResult {
            fn from(
                value: super::PostGetMultipleCompressedAccountProofsV2ResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleCompressedAccountsBody {
            id: ::std::result::Result<
                super::PostGetMultipleCompressedAccountsBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetMultipleCompressedAccountsBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetMultipleCompressedAccountsBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetMultipleCompressedAccountsBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleCompressedAccountsBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetMultipleCompressedAccountsBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountsBodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountsBodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountsBodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountsBodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleCompressedAccountsBody>
        for super::PostGetMultipleCompressedAccountsBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleCompressedAccountsBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleCompressedAccountsBody>
        for PostGetMultipleCompressedAccountsBody {
            fn from(value: super::PostGetMultipleCompressedAccountsBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleCompressedAccountsBodyParams {
            addresses: ::std::result::Result<
                ::std::option::Option<::std::vec::Vec<super::SerializablePubkey>>,
                ::std::string::String,
            >,
            hashes: ::std::result::Result<
                ::std::option::Option<::std::vec::Vec<super::Hash>>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleCompressedAccountsBodyParams {
            fn default() -> Self {
                Self {
                    addresses: Ok(Default::default()),
                    hashes: Ok(Default::default()),
                }
            }
        }
        impl PostGetMultipleCompressedAccountsBodyParams {
            pub fn addresses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<::std::vec::Vec<super::SerializablePubkey>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.addresses = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for addresses: {e}")
                    });
                self
            }
            pub fn hashes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<::std::vec::Vec<super::Hash>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.hashes = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for hashes: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleCompressedAccountsBodyParams>
        for super::PostGetMultipleCompressedAccountsBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleCompressedAccountsBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    addresses: value.addresses?,
                    hashes: value.hashes?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleCompressedAccountsBodyParams>
        for PostGetMultipleCompressedAccountsBodyParams {
            fn from(value: super::PostGetMultipleCompressedAccountsBodyParams) -> Self {
                Self {
                    addresses: Ok(value.addresses),
                    hashes: Ok(value.hashes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleCompressedAccountsResponse {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetMultipleCompressedAccountsResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetMultipleCompressedAccountsResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetMultipleCompressedAccountsResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetMultipleCompressedAccountsResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleCompressedAccountsResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetMultipleCompressedAccountsResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetMultipleCompressedAccountsResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountsResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountsResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetMultipleCompressedAccountsResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleCompressedAccountsResponse>
        for super::PostGetMultipleCompressedAccountsResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleCompressedAccountsResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleCompressedAccountsResponse>
        for PostGetMultipleCompressedAccountsResponse {
            fn from(value: super::PostGetMultipleCompressedAccountsResponse) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleCompressedAccountsResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleCompressedAccountsResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetMultipleCompressedAccountsResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleCompressedAccountsResponseError>
        for super::PostGetMultipleCompressedAccountsResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleCompressedAccountsResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleCompressedAccountsResponseError>
        for PostGetMultipleCompressedAccountsResponseError {
            fn from(
                value: super::PostGetMultipleCompressedAccountsResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleCompressedAccountsResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<super::AccountList, ::std::string::String>,
        }
        impl ::std::default::Default
        for PostGetMultipleCompressedAccountsResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetMultipleCompressedAccountsResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AccountList>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleCompressedAccountsResponseResult>
        for super::PostGetMultipleCompressedAccountsResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleCompressedAccountsResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleCompressedAccountsResponseResult>
        for PostGetMultipleCompressedAccountsResponseResult {
            fn from(
                value: super::PostGetMultipleCompressedAccountsResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleCompressedAccountsV2Body {
            id: ::std::result::Result<
                super::PostGetMultipleCompressedAccountsV2BodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetMultipleCompressedAccountsV2BodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetMultipleCompressedAccountsV2BodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetMultipleCompressedAccountsV2BodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleCompressedAccountsV2Body {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetMultipleCompressedAccountsV2Body {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountsV2BodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountsV2BodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountsV2BodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountsV2BodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleCompressedAccountsV2Body>
        for super::PostGetMultipleCompressedAccountsV2Body {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleCompressedAccountsV2Body,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleCompressedAccountsV2Body>
        for PostGetMultipleCompressedAccountsV2Body {
            fn from(value: super::PostGetMultipleCompressedAccountsV2Body) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleCompressedAccountsV2BodyParams {
            addresses: ::std::result::Result<
                ::std::option::Option<::std::vec::Vec<super::SerializablePubkey>>,
                ::std::string::String,
            >,
            hashes: ::std::result::Result<
                ::std::option::Option<::std::vec::Vec<super::Hash>>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleCompressedAccountsV2BodyParams {
            fn default() -> Self {
                Self {
                    addresses: Ok(Default::default()),
                    hashes: Ok(Default::default()),
                }
            }
        }
        impl PostGetMultipleCompressedAccountsV2BodyParams {
            pub fn addresses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<::std::vec::Vec<super::SerializablePubkey>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.addresses = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for addresses: {e}")
                    });
                self
            }
            pub fn hashes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<::std::vec::Vec<super::Hash>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.hashes = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for hashes: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleCompressedAccountsV2BodyParams>
        for super::PostGetMultipleCompressedAccountsV2BodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleCompressedAccountsV2BodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    addresses: value.addresses?,
                    hashes: value.hashes?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleCompressedAccountsV2BodyParams>
        for PostGetMultipleCompressedAccountsV2BodyParams {
            fn from(
                value: super::PostGetMultipleCompressedAccountsV2BodyParams,
            ) -> Self {
                Self {
                    addresses: Ok(value.addresses),
                    hashes: Ok(value.hashes),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleCompressedAccountsV2Response {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetMultipleCompressedAccountsV2ResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetMultipleCompressedAccountsV2ResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetMultipleCompressedAccountsV2ResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetMultipleCompressedAccountsV2ResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleCompressedAccountsV2Response {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetMultipleCompressedAccountsV2Response {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetMultipleCompressedAccountsV2ResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountsV2ResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleCompressedAccountsV2ResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetMultipleCompressedAccountsV2ResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleCompressedAccountsV2Response>
        for super::PostGetMultipleCompressedAccountsV2Response {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleCompressedAccountsV2Response,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleCompressedAccountsV2Response>
        for PostGetMultipleCompressedAccountsV2Response {
            fn from(value: super::PostGetMultipleCompressedAccountsV2Response) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleCompressedAccountsV2ResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetMultipleCompressedAccountsV2ResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetMultipleCompressedAccountsV2ResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleCompressedAccountsV2ResponseError>
        for super::PostGetMultipleCompressedAccountsV2ResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleCompressedAccountsV2ResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetMultipleCompressedAccountsV2ResponseError,
        > for PostGetMultipleCompressedAccountsV2ResponseError {
            fn from(
                value: super::PostGetMultipleCompressedAccountsV2ResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleCompressedAccountsV2ResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<super::AccountListV2, ::std::string::String>,
        }
        impl ::std::default::Default
        for PostGetMultipleCompressedAccountsV2ResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetMultipleCompressedAccountsV2ResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AccountListV2>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleCompressedAccountsV2ResponseResult>
        for super::PostGetMultipleCompressedAccountsV2ResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleCompressedAccountsV2ResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetMultipleCompressedAccountsV2ResponseResult,
        > for PostGetMultipleCompressedAccountsV2ResponseResult {
            fn from(
                value: super::PostGetMultipleCompressedAccountsV2ResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleNewAddressProofsBody {
            id: ::std::result::Result<
                super::PostGetMultipleNewAddressProofsBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetMultipleNewAddressProofsBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetMultipleNewAddressProofsBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                ::std::vec::Vec<super::SerializablePubkey>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleNewAddressProofsBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetMultipleNewAddressProofsBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetMultipleNewAddressProofsBodyId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleNewAddressProofsBodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleNewAddressProofsBodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SerializablePubkey>>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleNewAddressProofsBody>
        for super::PostGetMultipleNewAddressProofsBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleNewAddressProofsBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleNewAddressProofsBody>
        for PostGetMultipleNewAddressProofsBody {
            fn from(value: super::PostGetMultipleNewAddressProofsBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleNewAddressProofsResponse {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetMultipleNewAddressProofsResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetMultipleNewAddressProofsResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetMultipleNewAddressProofsResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetMultipleNewAddressProofsResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleNewAddressProofsResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetMultipleNewAddressProofsResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetMultipleNewAddressProofsResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleNewAddressProofsResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleNewAddressProofsResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetMultipleNewAddressProofsResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleNewAddressProofsResponse>
        for super::PostGetMultipleNewAddressProofsResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleNewAddressProofsResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleNewAddressProofsResponse>
        for PostGetMultipleNewAddressProofsResponse {
            fn from(value: super::PostGetMultipleNewAddressProofsResponse) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleNewAddressProofsResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleNewAddressProofsResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetMultipleNewAddressProofsResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleNewAddressProofsResponseError>
        for super::PostGetMultipleNewAddressProofsResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleNewAddressProofsResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleNewAddressProofsResponseError>
        for PostGetMultipleNewAddressProofsResponseError {
            fn from(value: super::PostGetMultipleNewAddressProofsResponseError) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleNewAddressProofsResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                ::std::vec::Vec<super::MerkleContextWithNewAddressProof>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleNewAddressProofsResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetMultipleNewAddressProofsResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::MerkleContextWithNewAddressProof>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleNewAddressProofsResponseResult>
        for super::PostGetMultipleNewAddressProofsResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleNewAddressProofsResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleNewAddressProofsResponseResult>
        for PostGetMultipleNewAddressProofsResponseResult {
            fn from(
                value: super::PostGetMultipleNewAddressProofsResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleNewAddressProofsV2Body {
            id: ::std::result::Result<
                super::PostGetMultipleNewAddressProofsV2BodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetMultipleNewAddressProofsV2BodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetMultipleNewAddressProofsV2BodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                ::std::vec::Vec<super::AddressWithTree>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleNewAddressProofsV2Body {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetMultipleNewAddressProofsV2Body {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleNewAddressProofsV2BodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleNewAddressProofsV2BodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleNewAddressProofsV2BodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::AddressWithTree>>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleNewAddressProofsV2Body>
        for super::PostGetMultipleNewAddressProofsV2Body {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleNewAddressProofsV2Body,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleNewAddressProofsV2Body>
        for PostGetMultipleNewAddressProofsV2Body {
            fn from(value: super::PostGetMultipleNewAddressProofsV2Body) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleNewAddressProofsV2Response {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetMultipleNewAddressProofsV2ResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetMultipleNewAddressProofsV2ResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetMultipleNewAddressProofsV2ResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetMultipleNewAddressProofsV2ResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleNewAddressProofsV2Response {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetMultipleNewAddressProofsV2Response {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetMultipleNewAddressProofsV2ResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleNewAddressProofsV2ResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetMultipleNewAddressProofsV2ResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetMultipleNewAddressProofsV2ResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleNewAddressProofsV2Response>
        for super::PostGetMultipleNewAddressProofsV2Response {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleNewAddressProofsV2Response,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleNewAddressProofsV2Response>
        for PostGetMultipleNewAddressProofsV2Response {
            fn from(value: super::PostGetMultipleNewAddressProofsV2Response) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleNewAddressProofsV2ResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetMultipleNewAddressProofsV2ResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetMultipleNewAddressProofsV2ResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleNewAddressProofsV2ResponseError>
        for super::PostGetMultipleNewAddressProofsV2ResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleNewAddressProofsV2ResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleNewAddressProofsV2ResponseError>
        for PostGetMultipleNewAddressProofsV2ResponseError {
            fn from(
                value: super::PostGetMultipleNewAddressProofsV2ResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetMultipleNewAddressProofsV2ResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                ::std::vec::Vec<super::MerkleContextWithNewAddressProof>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetMultipleNewAddressProofsV2ResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetMultipleNewAddressProofsV2ResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::MerkleContextWithNewAddressProof>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetMultipleNewAddressProofsV2ResponseResult>
        for super::PostGetMultipleNewAddressProofsV2ResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetMultipleNewAddressProofsV2ResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetMultipleNewAddressProofsV2ResponseResult>
        for PostGetMultipleNewAddressProofsV2ResponseResult {
            fn from(
                value: super::PostGetMultipleNewAddressProofsV2ResponseResult,
            ) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetQueueElementsBody {
            id: ::std::result::Result<
                super::PostGetQueueElementsBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetQueueElementsBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetQueueElementsBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetQueueElementsBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetQueueElementsBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetQueueElementsBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetQueueElementsBodyId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetQueueElementsBodyJsonrpc>,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetQueueElementsBodyMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetQueueElementsBodyParams>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetQueueElementsBody>
        for super::PostGetQueueElementsBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetQueueElementsBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetQueueElementsBody>
        for PostGetQueueElementsBody {
            fn from(value: super::PostGetQueueElementsBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetQueueElementsBodyParams {
            address_queue: ::std::result::Result<
                ::std::option::Option<super::QueueRequest>,
                ::std::string::String,
            >,
            input_queue: ::std::result::Result<
                ::std::option::Option<super::QueueRequest>,
                ::std::string::String,
            >,
            output_queue: ::std::result::Result<
                ::std::option::Option<super::QueueRequest>,
                ::std::string::String,
            >,
            tree: ::std::result::Result<super::Hash, ::std::string::String>,
        }
        impl ::std::default::Default for PostGetQueueElementsBodyParams {
            fn default() -> Self {
                Self {
                    address_queue: Ok(Default::default()),
                    input_queue: Ok(Default::default()),
                    output_queue: Ok(Default::default()),
                    tree: Err("no value supplied for tree".to_string()),
                }
            }
        }
        impl PostGetQueueElementsBodyParams {
            pub fn address_queue<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::QueueRequest>>,
                T::Error: ::std::fmt::Display,
            {
                self.address_queue = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address_queue: {e}")
                    });
                self
            }
            pub fn input_queue<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::QueueRequest>>,
                T::Error: ::std::fmt::Display,
            {
                self.input_queue = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for input_queue: {e}")
                    });
                self
            }
            pub fn output_queue<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::QueueRequest>>,
                T::Error: ::std::fmt::Display,
            {
                self.output_queue = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for output_queue: {e}")
                    });
                self
            }
            pub fn tree<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Hash>,
                T::Error: ::std::fmt::Display,
            {
                self.tree = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for tree: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetQueueElementsBodyParams>
        for super::PostGetQueueElementsBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetQueueElementsBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address_queue: value.address_queue?,
                    input_queue: value.input_queue?,
                    output_queue: value.output_queue?,
                    tree: value.tree?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetQueueElementsBodyParams>
        for PostGetQueueElementsBodyParams {
            fn from(value: super::PostGetQueueElementsBodyParams) -> Self {
                Self {
                    address_queue: Ok(value.address_queue),
                    input_queue: Ok(value.input_queue),
                    output_queue: Ok(value.output_queue),
                    tree: Ok(value.tree),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetQueueElementsResponse {
            error: ::std::result::Result<
                ::std::option::Option<super::PostGetQueueElementsResponseError>,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetQueueElementsResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetQueueElementsResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<super::PostGetQueueElementsResponseResult>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetQueueElementsResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetQueueElementsResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::PostGetQueueElementsResponseError>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetQueueElementsResponseId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetQueueElementsResponseJsonrpc>,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::PostGetQueueElementsResponseResult>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetQueueElementsResponse>
        for super::PostGetQueueElementsResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetQueueElementsResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetQueueElementsResponse>
        for PostGetQueueElementsResponse {
            fn from(value: super::PostGetQueueElementsResponse) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetQueueElementsResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetQueueElementsResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetQueueElementsResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetQueueElementsResponseError>
        for super::PostGetQueueElementsResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetQueueElementsResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetQueueElementsResponseError>
        for PostGetQueueElementsResponseError {
            fn from(value: super::PostGetQueueElementsResponseError) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetQueueElementsResponseResult {
            address_queue: ::std::result::Result<
                ::std::option::Option<super::AddressQueueData>,
                ::std::string::String,
            >,
            context: ::std::result::Result<super::Context, ::std::string::String>,
            state_queue: ::std::result::Result<
                ::std::option::Option<super::StateQueueData>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetQueueElementsResponseResult {
            fn default() -> Self {
                Self {
                    address_queue: Ok(Default::default()),
                    context: Err("no value supplied for context".to_string()),
                    state_queue: Ok(Default::default()),
                }
            }
        }
        impl PostGetQueueElementsResponseResult {
            pub fn address_queue<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::AddressQueueData>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.address_queue = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for address_queue: {e}")
                    });
                self
            }
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn state_queue<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::StateQueueData>>,
                T::Error: ::std::fmt::Display,
            {
                self.state_queue = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for state_queue: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetQueueElementsResponseResult>
        for super::PostGetQueueElementsResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetQueueElementsResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address_queue: value.address_queue?,
                    context: value.context?,
                    state_queue: value.state_queue?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetQueueElementsResponseResult>
        for PostGetQueueElementsResponseResult {
            fn from(value: super::PostGetQueueElementsResponseResult) -> Self {
                Self {
                    address_queue: Ok(value.address_queue),
                    context: Ok(value.context),
                    state_queue: Ok(value.state_queue),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetQueueInfoBody {
            id: ::std::result::Result<
                super::PostGetQueueInfoBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetQueueInfoBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetQueueInfoBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetQueueInfoBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetQueueInfoBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetQueueInfoBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetQueueInfoBodyId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetQueueInfoBodyJsonrpc>,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetQueueInfoBodyMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetQueueInfoBodyParams>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetQueueInfoBody>
        for super::PostGetQueueInfoBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetQueueInfoBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetQueueInfoBody> for PostGetQueueInfoBody {
            fn from(value: super::PostGetQueueInfoBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetQueueInfoBodyParams {
            trees: ::std::result::Result<
                ::std::option::Option<::std::vec::Vec<::std::string::String>>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetQueueInfoBodyParams {
            fn default() -> Self {
                Self {
                    trees: Ok(Default::default()),
                }
            }
        }
        impl PostGetQueueInfoBodyParams {
            pub fn trees<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<::std::vec::Vec<::std::string::String>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.trees = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for trees: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetQueueInfoBodyParams>
        for super::PostGetQueueInfoBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetQueueInfoBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { trees: value.trees? })
            }
        }
        impl ::std::convert::From<super::PostGetQueueInfoBodyParams>
        for PostGetQueueInfoBodyParams {
            fn from(value: super::PostGetQueueInfoBodyParams) -> Self {
                Self { trees: Ok(value.trees) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetQueueInfoResponse {
            error: ::std::result::Result<
                ::std::option::Option<super::PostGetQueueInfoResponseError>,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetQueueInfoResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetQueueInfoResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<super::PostGetQueueInfoResponseResult>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetQueueInfoResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetQueueInfoResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::PostGetQueueInfoResponseError>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetQueueInfoResponseId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetQueueInfoResponseJsonrpc>,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::PostGetQueueInfoResponseResult>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetQueueInfoResponse>
        for super::PostGetQueueInfoResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetQueueInfoResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetQueueInfoResponse>
        for PostGetQueueInfoResponse {
            fn from(value: super::PostGetQueueInfoResponse) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetQueueInfoResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetQueueInfoResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetQueueInfoResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetQueueInfoResponseError>
        for super::PostGetQueueInfoResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetQueueInfoResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetQueueInfoResponseError>
        for PostGetQueueInfoResponseError {
            fn from(value: super::PostGetQueueInfoResponseError) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetQueueInfoResponseResult {
            queues: ::std::result::Result<
                ::std::vec::Vec<super::QueueInfo>,
                ::std::string::String,
            >,
            slot: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for PostGetQueueInfoResponseResult {
            fn default() -> Self {
                Self {
                    queues: Err("no value supplied for queues".to_string()),
                    slot: Err("no value supplied for slot".to_string()),
                }
            }
        }
        impl PostGetQueueInfoResponseResult {
            pub fn queues<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::QueueInfo>>,
                T::Error: ::std::fmt::Display,
            {
                self.queues = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for queues: {e}")
                    });
                self
            }
            pub fn slot<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.slot = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for slot: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetQueueInfoResponseResult>
        for super::PostGetQueueInfoResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetQueueInfoResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    queues: value.queues?,
                    slot: value.slot?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetQueueInfoResponseResult>
        for PostGetQueueInfoResponseResult {
            fn from(value: super::PostGetQueueInfoResponseResult) -> Self {
                Self {
                    queues: Ok(value.queues),
                    slot: Ok(value.slot),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetTransactionWithCompressionInfoBody {
            id: ::std::result::Result<
                super::PostGetTransactionWithCompressionInfoBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetTransactionWithCompressionInfoBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetTransactionWithCompressionInfoBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetTransactionWithCompressionInfoBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetTransactionWithCompressionInfoBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetTransactionWithCompressionInfoBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetTransactionWithCompressionInfoBodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetTransactionWithCompressionInfoBodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetTransactionWithCompressionInfoBodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetTransactionWithCompressionInfoBodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetTransactionWithCompressionInfoBody>
        for super::PostGetTransactionWithCompressionInfoBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetTransactionWithCompressionInfoBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetTransactionWithCompressionInfoBody>
        for PostGetTransactionWithCompressionInfoBody {
            fn from(value: super::PostGetTransactionWithCompressionInfoBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetTransactionWithCompressionInfoBodyParams {
            signature: ::std::result::Result<
                super::SerializableSignature,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetTransactionWithCompressionInfoBodyParams {
            fn default() -> Self {
                Self {
                    signature: Err("no value supplied for signature".to_string()),
                }
            }
        }
        impl PostGetTransactionWithCompressionInfoBodyParams {
            pub fn signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializableSignature>,
                T::Error: ::std::fmt::Display,
            {
                self.signature = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for signature: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetTransactionWithCompressionInfoBodyParams>
        for super::PostGetTransactionWithCompressionInfoBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetTransactionWithCompressionInfoBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    signature: value.signature?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetTransactionWithCompressionInfoBodyParams>
        for PostGetTransactionWithCompressionInfoBodyParams {
            fn from(
                value: super::PostGetTransactionWithCompressionInfoBodyParams,
            ) -> Self {
                Self {
                    signature: Ok(value.signature),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetTransactionWithCompressionInfoResponse {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetTransactionWithCompressionInfoResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetTransactionWithCompressionInfoResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetTransactionWithCompressionInfoResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetTransactionWithCompressionInfoResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetTransactionWithCompressionInfoResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetTransactionWithCompressionInfoResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetTransactionWithCompressionInfoResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetTransactionWithCompressionInfoResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetTransactionWithCompressionInfoResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetTransactionWithCompressionInfoResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetTransactionWithCompressionInfoResponse>
        for super::PostGetTransactionWithCompressionInfoResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetTransactionWithCompressionInfoResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetTransactionWithCompressionInfoResponse>
        for PostGetTransactionWithCompressionInfoResponse {
            fn from(
                value: super::PostGetTransactionWithCompressionInfoResponse,
            ) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetTransactionWithCompressionInfoResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetTransactionWithCompressionInfoResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetTransactionWithCompressionInfoResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetTransactionWithCompressionInfoResponseError>
        for super::PostGetTransactionWithCompressionInfoResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetTransactionWithCompressionInfoResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetTransactionWithCompressionInfoResponseError,
        > for PostGetTransactionWithCompressionInfoResponseError {
            fn from(
                value: super::PostGetTransactionWithCompressionInfoResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetTransactionWithCompressionInfoResponseResult {
            compression_info: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetTransactionWithCompressionInfoResponseResultCompressionInfo,
                >,
                ::std::string::String,
            >,
            transaction: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetTransactionWithCompressionInfoResponseResult {
            fn default() -> Self {
                Self {
                    compression_info: Ok(Default::default()),
                    transaction: Ok(Default::default()),
                }
            }
        }
        impl PostGetTransactionWithCompressionInfoResponseResult {
            pub fn compression_info<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetTransactionWithCompressionInfoResponseResultCompressionInfo,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.compression_info = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for compression_info: {e}"
                        )
                    });
                self
            }
            pub fn transaction<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.transaction = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for transaction: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetTransactionWithCompressionInfoResponseResult>
        for super::PostGetTransactionWithCompressionInfoResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetTransactionWithCompressionInfoResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    compression_info: value.compression_info?,
                    transaction: value.transaction?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetTransactionWithCompressionInfoResponseResult,
        > for PostGetTransactionWithCompressionInfoResponseResult {
            fn from(
                value: super::PostGetTransactionWithCompressionInfoResponseResult,
            ) -> Self {
                Self {
                    compression_info: Ok(value.compression_info),
                    transaction: Ok(value.transaction),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetTransactionWithCompressionInfoResponseResultCompressionInfo {
            closed_accounts: ::std::result::Result<
                ::std::vec::Vec<super::AccountWithOptionalTokenData>,
                ::std::string::String,
            >,
            opened_accounts: ::std::result::Result<
                ::std::vec::Vec<super::AccountWithOptionalTokenData>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetTransactionWithCompressionInfoResponseResultCompressionInfo {
            fn default() -> Self {
                Self {
                    closed_accounts: Err(
                        "no value supplied for closed_accounts".to_string(),
                    ),
                    opened_accounts: Err(
                        "no value supplied for opened_accounts".to_string(),
                    ),
                }
            }
        }
        impl PostGetTransactionWithCompressionInfoResponseResultCompressionInfo {
            pub fn closed_accounts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::AccountWithOptionalTokenData>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.closed_accounts = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for closed_accounts: {e}"
                        )
                    });
                self
            }
            pub fn opened_accounts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::AccountWithOptionalTokenData>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.opened_accounts = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for opened_accounts: {e}"
                        )
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<
            PostGetTransactionWithCompressionInfoResponseResultCompressionInfo,
        > for super::PostGetTransactionWithCompressionInfoResponseResultCompressionInfo {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetTransactionWithCompressionInfoResponseResultCompressionInfo,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    closed_accounts: value.closed_accounts?,
                    opened_accounts: value.opened_accounts?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetTransactionWithCompressionInfoResponseResultCompressionInfo,
        > for PostGetTransactionWithCompressionInfoResponseResultCompressionInfo {
            fn from(
                value: super::PostGetTransactionWithCompressionInfoResponseResultCompressionInfo,
            ) -> Self {
                Self {
                    closed_accounts: Ok(value.closed_accounts),
                    opened_accounts: Ok(value.opened_accounts),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetTransactionWithCompressionInfoV2Body {
            id: ::std::result::Result<
                super::PostGetTransactionWithCompressionInfoV2BodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetTransactionWithCompressionInfoV2BodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetTransactionWithCompressionInfoV2BodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetTransactionWithCompressionInfoV2BodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetTransactionWithCompressionInfoV2Body {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetTransactionWithCompressionInfoV2Body {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetTransactionWithCompressionInfoV2BodyId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetTransactionWithCompressionInfoV2BodyJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetTransactionWithCompressionInfoV2BodyMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetTransactionWithCompressionInfoV2BodyParams,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetTransactionWithCompressionInfoV2Body>
        for super::PostGetTransactionWithCompressionInfoV2Body {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetTransactionWithCompressionInfoV2Body,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetTransactionWithCompressionInfoV2Body>
        for PostGetTransactionWithCompressionInfoV2Body {
            fn from(value: super::PostGetTransactionWithCompressionInfoV2Body) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetTransactionWithCompressionInfoV2BodyParams {
            signature: ::std::result::Result<
                super::SerializableSignature,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetTransactionWithCompressionInfoV2BodyParams {
            fn default() -> Self {
                Self {
                    signature: Err("no value supplied for signature".to_string()),
                }
            }
        }
        impl PostGetTransactionWithCompressionInfoV2BodyParams {
            pub fn signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializableSignature>,
                T::Error: ::std::fmt::Display,
            {
                self.signature = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for signature: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetTransactionWithCompressionInfoV2BodyParams>
        for super::PostGetTransactionWithCompressionInfoV2BodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetTransactionWithCompressionInfoV2BodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    signature: value.signature?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetTransactionWithCompressionInfoV2BodyParams,
        > for PostGetTransactionWithCompressionInfoV2BodyParams {
            fn from(
                value: super::PostGetTransactionWithCompressionInfoV2BodyParams,
            ) -> Self {
                Self {
                    signature: Ok(value.signature),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetTransactionWithCompressionInfoV2Response {
            error: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetTransactionWithCompressionInfoV2ResponseError,
                >,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetTransactionWithCompressionInfoV2ResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetTransactionWithCompressionInfoV2ResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetTransactionWithCompressionInfoV2ResponseResult,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetTransactionWithCompressionInfoV2Response {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetTransactionWithCompressionInfoV2Response {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetTransactionWithCompressionInfoV2ResponseError,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetTransactionWithCompressionInfoV2ResponseId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::PostGetTransactionWithCompressionInfoV2ResponseJsonrpc,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetTransactionWithCompressionInfoV2ResponseResult,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetTransactionWithCompressionInfoV2Response>
        for super::PostGetTransactionWithCompressionInfoV2Response {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetTransactionWithCompressionInfoV2Response,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetTransactionWithCompressionInfoV2Response>
        for PostGetTransactionWithCompressionInfoV2Response {
            fn from(
                value: super::PostGetTransactionWithCompressionInfoV2Response,
            ) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetTransactionWithCompressionInfoV2ResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetTransactionWithCompressionInfoV2ResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetTransactionWithCompressionInfoV2ResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<
            PostGetTransactionWithCompressionInfoV2ResponseError,
        > for super::PostGetTransactionWithCompressionInfoV2ResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetTransactionWithCompressionInfoV2ResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetTransactionWithCompressionInfoV2ResponseError,
        > for PostGetTransactionWithCompressionInfoV2ResponseError {
            fn from(
                value: super::PostGetTransactionWithCompressionInfoV2ResponseError,
            ) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetTransactionWithCompressionInfoV2ResponseResult {
            compression_info: ::std::result::Result<
                ::std::option::Option<
                    super::PostGetTransactionWithCompressionInfoV2ResponseResultCompressionInfo,
                >,
                ::std::string::String,
            >,
            transaction: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetTransactionWithCompressionInfoV2ResponseResult {
            fn default() -> Self {
                Self {
                    compression_info: Ok(Default::default()),
                    transaction: Ok(Default::default()),
                }
            }
        }
        impl PostGetTransactionWithCompressionInfoV2ResponseResult {
            pub fn compression_info<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::PostGetTransactionWithCompressionInfoV2ResponseResultCompressionInfo,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.compression_info = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for compression_info: {e}"
                        )
                    });
                self
            }
            pub fn transaction<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.transaction = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for transaction: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<
            PostGetTransactionWithCompressionInfoV2ResponseResult,
        > for super::PostGetTransactionWithCompressionInfoV2ResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetTransactionWithCompressionInfoV2ResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    compression_info: value.compression_info?,
                    transaction: value.transaction?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetTransactionWithCompressionInfoV2ResponseResult,
        > for PostGetTransactionWithCompressionInfoV2ResponseResult {
            fn from(
                value: super::PostGetTransactionWithCompressionInfoV2ResponseResult,
            ) -> Self {
                Self {
                    compression_info: Ok(value.compression_info),
                    transaction: Ok(value.transaction),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetTransactionWithCompressionInfoV2ResponseResultCompressionInfo {
            closed_accounts: ::std::result::Result<
                ::std::vec::Vec<super::ClosedAccountWithOptionalTokenDataV2>,
                ::std::string::String,
            >,
            opened_accounts: ::std::result::Result<
                ::std::vec::Vec<super::AccountWithOptionalTokenDataV2>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default
        for PostGetTransactionWithCompressionInfoV2ResponseResultCompressionInfo {
            fn default() -> Self {
                Self {
                    closed_accounts: Err(
                        "no value supplied for closed_accounts".to_string(),
                    ),
                    opened_accounts: Err(
                        "no value supplied for opened_accounts".to_string(),
                    ),
                }
            }
        }
        impl PostGetTransactionWithCompressionInfoV2ResponseResultCompressionInfo {
            pub fn closed_accounts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::ClosedAccountWithOptionalTokenDataV2>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.closed_accounts = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for closed_accounts: {e}"
                        )
                    });
                self
            }
            pub fn opened_accounts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::AccountWithOptionalTokenDataV2>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.opened_accounts = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for opened_accounts: {e}"
                        )
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<
            PostGetTransactionWithCompressionInfoV2ResponseResultCompressionInfo,
        >
        for super::PostGetTransactionWithCompressionInfoV2ResponseResultCompressionInfo {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetTransactionWithCompressionInfoV2ResponseResultCompressionInfo,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    closed_accounts: value.closed_accounts?,
                    opened_accounts: value.opened_accounts?,
                })
            }
        }
        impl ::std::convert::From<
            super::PostGetTransactionWithCompressionInfoV2ResponseResultCompressionInfo,
        > for PostGetTransactionWithCompressionInfoV2ResponseResultCompressionInfo {
            fn from(
                value: super::PostGetTransactionWithCompressionInfoV2ResponseResultCompressionInfo,
            ) -> Self {
                Self {
                    closed_accounts: Ok(value.closed_accounts),
                    opened_accounts: Ok(value.opened_accounts),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetValidityProofBody {
            id: ::std::result::Result<
                super::PostGetValidityProofBodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetValidityProofBodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetValidityProofBodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetValidityProofBodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetValidityProofBody {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetValidityProofBody {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetValidityProofBodyId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetValidityProofBodyJsonrpc>,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetValidityProofBodyMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetValidityProofBodyParams>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetValidityProofBody>
        for super::PostGetValidityProofBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetValidityProofBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetValidityProofBody>
        for PostGetValidityProofBody {
            fn from(value: super::PostGetValidityProofBody) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetValidityProofBodyParams {
            hashes: ::std::result::Result<
                ::std::vec::Vec<super::Hash>,
                ::std::string::String,
            >,
            new_addresses_with_trees: ::std::result::Result<
                ::std::vec::Vec<super::AddressWithTree>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetValidityProofBodyParams {
            fn default() -> Self {
                Self {
                    hashes: Ok(Default::default()),
                    new_addresses_with_trees: Ok(Default::default()),
                }
            }
        }
        impl PostGetValidityProofBodyParams {
            pub fn hashes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.hashes = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for hashes: {e}")
                    });
                self
            }
            pub fn new_addresses_with_trees<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::AddressWithTree>>,
                T::Error: ::std::fmt::Display,
            {
                self.new_addresses_with_trees = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for new_addresses_with_trees: {e}"
                        )
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetValidityProofBodyParams>
        for super::PostGetValidityProofBodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetValidityProofBodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    hashes: value.hashes?,
                    new_addresses_with_trees: value.new_addresses_with_trees?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetValidityProofBodyParams>
        for PostGetValidityProofBodyParams {
            fn from(value: super::PostGetValidityProofBodyParams) -> Self {
                Self {
                    hashes: Ok(value.hashes),
                    new_addresses_with_trees: Ok(value.new_addresses_with_trees),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetValidityProofResponse {
            error: ::std::result::Result<
                ::std::option::Option<super::PostGetValidityProofResponseError>,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetValidityProofResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetValidityProofResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<super::PostGetValidityProofResponseResult>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetValidityProofResponse {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetValidityProofResponse {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::PostGetValidityProofResponseError>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetValidityProofResponseId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetValidityProofResponseJsonrpc>,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::PostGetValidityProofResponseResult>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetValidityProofResponse>
        for super::PostGetValidityProofResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetValidityProofResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetValidityProofResponse>
        for PostGetValidityProofResponse {
            fn from(value: super::PostGetValidityProofResponse) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetValidityProofResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetValidityProofResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetValidityProofResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetValidityProofResponseError>
        for super::PostGetValidityProofResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetValidityProofResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetValidityProofResponseError>
        for PostGetValidityProofResponseError {
            fn from(value: super::PostGetValidityProofResponseError) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetValidityProofResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                super::CompressedProofWithContext,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetValidityProofResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetValidityProofResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CompressedProofWithContext>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetValidityProofResponseResult>
        for super::PostGetValidityProofResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetValidityProofResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetValidityProofResponseResult>
        for PostGetValidityProofResponseResult {
            fn from(value: super::PostGetValidityProofResponseResult) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetValidityProofV2Body {
            id: ::std::result::Result<
                super::PostGetValidityProofV2BodyId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetValidityProofV2BodyJsonrpc,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::PostGetValidityProofV2BodyMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::PostGetValidityProofV2BodyParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetValidityProofV2Body {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl PostGetValidityProofV2Body {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetValidityProofV2BodyId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetValidityProofV2BodyJsonrpc>,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetValidityProofV2BodyMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for method: {e}")
                    });
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetValidityProofV2BodyParams>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for params: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetValidityProofV2Body>
        for super::PostGetValidityProofV2Body {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetValidityProofV2Body,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetValidityProofV2Body>
        for PostGetValidityProofV2Body {
            fn from(value: super::PostGetValidityProofV2Body) -> Self {
                Self {
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetValidityProofV2BodyParams {
            hashes: ::std::result::Result<
                ::std::vec::Vec<super::Hash>,
                ::std::string::String,
            >,
            new_addresses_with_trees: ::std::result::Result<
                ::std::vec::Vec<super::AddressWithTree>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetValidityProofV2BodyParams {
            fn default() -> Self {
                Self {
                    hashes: Ok(Default::default()),
                    new_addresses_with_trees: Ok(Default::default()),
                }
            }
        }
        impl PostGetValidityProofV2BodyParams {
            pub fn hashes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Hash>>,
                T::Error: ::std::fmt::Display,
            {
                self.hashes = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for hashes: {e}")
                    });
                self
            }
            pub fn new_addresses_with_trees<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::AddressWithTree>>,
                T::Error: ::std::fmt::Display,
            {
                self.new_addresses_with_trees = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for new_addresses_with_trees: {e}"
                        )
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetValidityProofV2BodyParams>
        for super::PostGetValidityProofV2BodyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetValidityProofV2BodyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    hashes: value.hashes?,
                    new_addresses_with_trees: value.new_addresses_with_trees?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetValidityProofV2BodyParams>
        for PostGetValidityProofV2BodyParams {
            fn from(value: super::PostGetValidityProofV2BodyParams) -> Self {
                Self {
                    hashes: Ok(value.hashes),
                    new_addresses_with_trees: Ok(value.new_addresses_with_trees),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetValidityProofV2Response {
            error: ::std::result::Result<
                ::std::option::Option<super::PostGetValidityProofV2ResponseError>,
                ::std::string::String,
            >,
            id: ::std::result::Result<
                super::PostGetValidityProofV2ResponseId,
                ::std::string::String,
            >,
            jsonrpc: ::std::result::Result<
                super::PostGetValidityProofV2ResponseJsonrpc,
                ::std::string::String,
            >,
            result: ::std::result::Result<
                ::std::option::Option<super::PostGetValidityProofV2ResponseResult>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetValidityProofV2Response {
            fn default() -> Self {
                Self {
                    error: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    jsonrpc: Err("no value supplied for jsonrpc".to_string()),
                    result: Ok(Default::default()),
                }
            }
        }
        impl PostGetValidityProofV2Response {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::PostGetValidityProofV2ResponseError>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetValidityProofV2ResponseId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {e}"));
                self
            }
            pub fn jsonrpc<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PostGetValidityProofV2ResponseJsonrpc>,
                T::Error: ::std::fmt::Display,
            {
                self.jsonrpc = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for jsonrpc: {e}")
                    });
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::PostGetValidityProofV2ResponseResult>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for result: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetValidityProofV2Response>
        for super::PostGetValidityProofV2Response {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetValidityProofV2Response,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    id: value.id?,
                    jsonrpc: value.jsonrpc?,
                    result: value.result?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetValidityProofV2Response>
        for PostGetValidityProofV2Response {
            fn from(value: super::PostGetValidityProofV2Response) -> Self {
                Self {
                    error: Ok(value.error),
                    id: Ok(value.id),
                    jsonrpc: Ok(value.jsonrpc),
                    result: Ok(value.result),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetValidityProofV2ResponseError {
            code: ::std::result::Result<
                ::std::option::Option<i64>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetValidityProofV2ResponseError {
            fn default() -> Self {
                Self {
                    code: Ok(Default::default()),
                    message: Ok(Default::default()),
                }
            }
        }
        impl PostGetValidityProofV2ResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for code: {e}")
                    });
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for message: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetValidityProofV2ResponseError>
        for super::PostGetValidityProofV2ResponseError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetValidityProofV2ResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetValidityProofV2ResponseError>
        for PostGetValidityProofV2ResponseError {
            fn from(value: super::PostGetValidityProofV2ResponseError) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PostGetValidityProofV2ResponseResult {
            context: ::std::result::Result<super::Context, ::std::string::String>,
            value: ::std::result::Result<
                super::CompressedProofWithContextV2,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PostGetValidityProofV2ResponseResult {
            fn default() -> Self {
                Self {
                    context: Err("no value supplied for context".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl PostGetValidityProofV2ResponseResult {
            pub fn context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Context>,
                T::Error: ::std::fmt::Display,
            {
                self.context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for context: {e}")
                    });
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CompressedProofWithContextV2>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for value: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<PostGetValidityProofV2ResponseResult>
        for super::PostGetValidityProofV2ResponseResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PostGetValidityProofV2ResponseResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    context: value.context?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::PostGetValidityProofV2ResponseResult>
        for PostGetValidityProofV2ResponseResult {
            fn from(value: super::PostGetValidityProofV2ResponseResult) -> Self {
                Self {
                    context: Ok(value.context),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct QueueInfo {
            queue: ::std::result::Result<::std::string::String, ::std::string::String>,
            queue_size: ::std::result::Result<u64, ::std::string::String>,
            queue_type: ::std::result::Result<u8, ::std::string::String>,
            tree: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for QueueInfo {
            fn default() -> Self {
                Self {
                    queue: Err("no value supplied for queue".to_string()),
                    queue_size: Err("no value supplied for queue_size".to_string()),
                    queue_type: Err("no value supplied for queue_type".to_string()),
                    tree: Err("no value supplied for tree".to_string()),
                }
            }
        }
        impl QueueInfo {
            pub fn queue<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.queue = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for queue: {e}")
                    });
                self
            }
            pub fn queue_size<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.queue_size = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for queue_size: {e}")
                    });
                self
            }
            pub fn queue_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u8>,
                T::Error: ::std::fmt::Display,
            {
                self.queue_type = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for queue_type: {e}")
                    });
                self
            }
            pub fn tree<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.tree = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for tree: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<QueueInfo> for super::QueueInfo {
            type Error = super::error::ConversionError;
            fn try_from(
                value: QueueInfo,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    queue: value.queue?,
                    queue_size: value.queue_size?,
                    queue_type: value.queue_type?,
                    tree: value.tree?,
                })
            }
        }
        impl ::std::convert::From<super::QueueInfo> for QueueInfo {
            fn from(value: super::QueueInfo) -> Self {
                Self {
                    queue: Ok(value.queue),
                    queue_size: Ok(value.queue_size),
                    queue_type: Ok(value.queue_type),
                    tree: Ok(value.tree),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct QueueRequest {
            limit: ::std::result::Result<u16, ::std::string::String>,
            start_index: ::std::result::Result<
                ::std::option::Option<u64>,
                ::std::string::String,
            >,
            zkp_batch_size: ::std::result::Result<
                ::std::option::Option<u16>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for QueueRequest {
            fn default() -> Self {
                Self {
                    limit: Err("no value supplied for limit".to_string()),
                    start_index: Ok(Default::default()),
                    zkp_batch_size: Ok(Default::default()),
                }
            }
        }
        impl QueueRequest {
            pub fn limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u16>,
                T::Error: ::std::fmt::Display,
            {
                self.limit = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for limit: {e}")
                    });
                self
            }
            pub fn start_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<u64>>,
                T::Error: ::std::fmt::Display,
            {
                self.start_index = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for start_index: {e}")
                    });
                self
            }
            pub fn zkp_batch_size<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<u16>>,
                T::Error: ::std::fmt::Display,
            {
                self.zkp_batch_size = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for zkp_batch_size: {e}"
                        )
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<QueueRequest> for super::QueueRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: QueueRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    limit: value.limit?,
                    start_index: value.start_index?,
                    zkp_batch_size: value.zkp_batch_size?,
                })
            }
        }
        impl ::std::convert::From<super::QueueRequest> for QueueRequest {
            fn from(value: super::QueueRequest) -> Self {
                Self {
                    limit: Ok(value.limit),
                    start_index: Ok(value.start_index),
                    zkp_batch_size: Ok(value.zkp_batch_size),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RootIndex {
            prove_by_index: ::std::result::Result<bool, ::std::string::String>,
            root_index: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for RootIndex {
            fn default() -> Self {
                Self {
                    prove_by_index: Err(
                        "no value supplied for prove_by_index".to_string(),
                    ),
                    root_index: Err("no value supplied for root_index".to_string()),
                }
            }
        }
        impl RootIndex {
            pub fn prove_by_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.prove_by_index = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for prove_by_index: {e}"
                        )
                    });
                self
            }
            pub fn root_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.root_index = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for root_index: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<RootIndex> for super::RootIndex {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RootIndex,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    prove_by_index: value.prove_by_index?,
                    root_index: value.root_index?,
                })
            }
        }
        impl ::std::convert::From<super::RootIndex> for RootIndex {
            fn from(value: super::RootIndex) -> Self {
                Self {
                    prove_by_index: Ok(value.prove_by_index),
                    root_index: Ok(value.root_index),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignatureInfo {
            block_time: ::std::result::Result<
                super::UnixTimestamp,
                ::std::string::String,
            >,
            signature: ::std::result::Result<
                super::SerializableSignature,
                ::std::string::String,
            >,
            slot: ::std::result::Result<super::UnsignedInteger, ::std::string::String>,
        }
        impl ::std::default::Default for SignatureInfo {
            fn default() -> Self {
                Self {
                    block_time: Err("no value supplied for block_time".to_string()),
                    signature: Err("no value supplied for signature".to_string()),
                    slot: Err("no value supplied for slot".to_string()),
                }
            }
        }
        impl SignatureInfo {
            pub fn block_time<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UnixTimestamp>,
                T::Error: ::std::fmt::Display,
            {
                self.block_time = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for block_time: {e}")
                    });
                self
            }
            pub fn signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializableSignature>,
                T::Error: ::std::fmt::Display,
            {
                self.signature = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for signature: {e}")
                    });
                self
            }
            pub fn slot<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UnsignedInteger>,
                T::Error: ::std::fmt::Display,
            {
                self.slot = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for slot: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<SignatureInfo> for super::SignatureInfo {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignatureInfo,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    block_time: value.block_time?,
                    signature: value.signature?,
                    slot: value.slot?,
                })
            }
        }
        impl ::std::convert::From<super::SignatureInfo> for SignatureInfo {
            fn from(value: super::SignatureInfo) -> Self {
                Self {
                    block_time: Ok(value.block_time),
                    signature: Ok(value.signature),
                    slot: Ok(value.slot),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignatureInfoList {
            items: ::std::result::Result<
                ::std::vec::Vec<super::SignatureInfo>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SignatureInfoList {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                }
            }
        }
        impl SignatureInfoList {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SignatureInfo>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<SignatureInfoList> for super::SignatureInfoList {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignatureInfoList,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { items: value.items? })
            }
        }
        impl ::std::convert::From<super::SignatureInfoList> for SignatureInfoList {
            fn from(value: super::SignatureInfoList) -> Self {
                Self { items: Ok(value.items) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignatureInfoListWithError {
            items: ::std::result::Result<
                ::std::vec::Vec<super::SignatureInfoWithError>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SignatureInfoListWithError {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                }
            }
        }
        impl SignatureInfoListWithError {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::SignatureInfoWithError>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<SignatureInfoListWithError>
        for super::SignatureInfoListWithError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignatureInfoListWithError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { items: value.items? })
            }
        }
        impl ::std::convert::From<super::SignatureInfoListWithError>
        for SignatureInfoListWithError {
            fn from(value: super::SignatureInfoListWithError) -> Self {
                Self { items: Ok(value.items) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SignatureInfoWithError {
            block_time: ::std::result::Result<
                super::UnixTimestamp,
                ::std::string::String,
            >,
            error: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            signature: ::std::result::Result<
                super::SerializableSignature,
                ::std::string::String,
            >,
            slot: ::std::result::Result<super::UnsignedInteger, ::std::string::String>,
        }
        impl ::std::default::Default for SignatureInfoWithError {
            fn default() -> Self {
                Self {
                    block_time: Err("no value supplied for block_time".to_string()),
                    error: Ok(Default::default()),
                    signature: Err("no value supplied for signature".to_string()),
                    slot: Err("no value supplied for slot".to_string()),
                }
            }
        }
        impl SignatureInfoWithError {
            pub fn block_time<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UnixTimestamp>,
                T::Error: ::std::fmt::Display,
            {
                self.block_time = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for block_time: {e}")
                    });
                self
            }
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for error: {e}")
                    });
                self
            }
            pub fn signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializableSignature>,
                T::Error: ::std::fmt::Display,
            {
                self.signature = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for signature: {e}")
                    });
                self
            }
            pub fn slot<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UnsignedInteger>,
                T::Error: ::std::fmt::Display,
            {
                self.slot = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for slot: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<SignatureInfoWithError>
        for super::SignatureInfoWithError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SignatureInfoWithError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    block_time: value.block_time?,
                    error: value.error?,
                    signature: value.signature?,
                    slot: value.slot?,
                })
            }
        }
        impl ::std::convert::From<super::SignatureInfoWithError>
        for SignatureInfoWithError {
            fn from(value: super::SignatureInfoWithError) -> Self {
                Self {
                    block_time: Ok(value.block_time),
                    error: Ok(value.error),
                    signature: Ok(value.signature),
                    slot: Ok(value.slot),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolanaAccountData {
            data: ::std::result::Result<super::Base64String, ::std::string::String>,
            executable: ::std::result::Result<bool, ::std::string::String>,
            lamports: ::std::result::Result<
                super::UnsignedInteger,
                ::std::string::String,
            >,
            owner: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
            rent_epoch: ::std::result::Result<
                super::UnsignedInteger,
                ::std::string::String,
            >,
            space: ::std::result::Result<super::UnsignedInteger, ::std::string::String>,
        }
        impl ::std::default::Default for SolanaAccountData {
            fn default() -> Self {
                Self {
                    data: Err("no value supplied for data".to_string()),
                    executable: Err("no value supplied for executable".to_string()),
                    lamports: Err("no value supplied for lamports".to_string()),
                    owner: Err("no value supplied for owner".to_string()),
                    rent_epoch: Err("no value supplied for rent_epoch".to_string()),
                    space: Err("no value supplied for space".to_string()),
                }
            }
        }
        impl SolanaAccountData {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Base64String>,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for data: {e}")
                    });
                self
            }
            pub fn executable<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.executable = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for executable: {e}")
                    });
                self
            }
            pub fn lamports<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UnsignedInteger>,
                T::Error: ::std::fmt::Display,
            {
                self.lamports = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for lamports: {e}")
                    });
                self
            }
            pub fn owner<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.owner = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for owner: {e}")
                    });
                self
            }
            pub fn rent_epoch<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UnsignedInteger>,
                T::Error: ::std::fmt::Display,
            {
                self.rent_epoch = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for rent_epoch: {e}")
                    });
                self
            }
            pub fn space<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UnsignedInteger>,
                T::Error: ::std::fmt::Display,
            {
                self.space = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for space: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<SolanaAccountData> for super::SolanaAccountData {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolanaAccountData,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    data: value.data?,
                    executable: value.executable?,
                    lamports: value.lamports?,
                    owner: value.owner?,
                    rent_epoch: value.rent_epoch?,
                    space: value.space?,
                })
            }
        }
        impl ::std::convert::From<super::SolanaAccountData> for SolanaAccountData {
            fn from(value: super::SolanaAccountData) -> Self {
                Self {
                    data: Ok(value.data),
                    executable: Ok(value.executable),
                    lamports: Ok(value.lamports),
                    owner: Ok(value.owner),
                    rent_epoch: Ok(value.rent_epoch),
                    space: Ok(value.space),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct StateQueueData {
            initial_root: ::std::result::Result<super::Hash, ::std::string::String>,
            input_queue: ::std::result::Result<
                ::std::option::Option<super::InputQueueData>,
                ::std::string::String,
            >,
            nodes: ::std::result::Result<
                ::std::vec::Vec<super::Node>,
                ::std::string::String,
            >,
            output_queue: ::std::result::Result<
                ::std::option::Option<super::OutputQueueData>,
                ::std::string::String,
            >,
            root_seq: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for StateQueueData {
            fn default() -> Self {
                Self {
                    initial_root: Err("no value supplied for initial_root".to_string()),
                    input_queue: Ok(Default::default()),
                    nodes: Ok(Default::default()),
                    output_queue: Ok(Default::default()),
                    root_seq: Err("no value supplied for root_seq".to_string()),
                }
            }
        }
        impl StateQueueData {
            pub fn initial_root<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Hash>,
                T::Error: ::std::fmt::Display,
            {
                self.initial_root = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for initial_root: {e}")
                    });
                self
            }
            pub fn input_queue<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::InputQueueData>>,
                T::Error: ::std::fmt::Display,
            {
                self.input_queue = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for input_queue: {e}")
                    });
                self
            }
            pub fn nodes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Node>>,
                T::Error: ::std::fmt::Display,
            {
                self.nodes = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for nodes: {e}")
                    });
                self
            }
            pub fn output_queue<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::OutputQueueData>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.output_queue = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for output_queue: {e}")
                    });
                self
            }
            pub fn root_seq<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.root_seq = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for root_seq: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<StateQueueData> for super::StateQueueData {
            type Error = super::error::ConversionError;
            fn try_from(
                value: StateQueueData,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    initial_root: value.initial_root?,
                    input_queue: value.input_queue?,
                    nodes: value.nodes?,
                    output_queue: value.output_queue?,
                    root_seq: value.root_seq?,
                })
            }
        }
        impl ::std::convert::From<super::StateQueueData> for StateQueueData {
            fn from(value: super::StateQueueData) -> Self {
                Self {
                    initial_root: Ok(value.initial_root),
                    input_queue: Ok(value.input_queue),
                    nodes: Ok(value.nodes),
                    output_queue: Ok(value.output_queue),
                    root_seq: Ok(value.root_seq),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TokenAccount {
            account: ::std::result::Result<super::Account, ::std::string::String>,
            token_data: ::std::result::Result<super::TokenData, ::std::string::String>,
        }
        impl ::std::default::Default for TokenAccount {
            fn default() -> Self {
                Self {
                    account: Err("no value supplied for account".to_string()),
                    token_data: Err("no value supplied for token_data".to_string()),
                }
            }
        }
        impl TokenAccount {
            pub fn account<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Account>,
                T::Error: ::std::fmt::Display,
            {
                self.account = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for account: {e}")
                    });
                self
            }
            pub fn token_data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TokenData>,
                T::Error: ::std::fmt::Display,
            {
                self.token_data = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for token_data: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<TokenAccount> for super::TokenAccount {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TokenAccount,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account: value.account?,
                    token_data: value.token_data?,
                })
            }
        }
        impl ::std::convert::From<super::TokenAccount> for TokenAccount {
            fn from(value: super::TokenAccount) -> Self {
                Self {
                    account: Ok(value.account),
                    token_data: Ok(value.token_data),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TokenAccountBalance {
            amount: ::std::result::Result<super::UnsignedInteger, ::std::string::String>,
        }
        impl ::std::default::Default for TokenAccountBalance {
            fn default() -> Self {
                Self {
                    amount: Err("no value supplied for amount".to_string()),
                }
            }
        }
        impl TokenAccountBalance {
            pub fn amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UnsignedInteger>,
                T::Error: ::std::fmt::Display,
            {
                self.amount = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for amount: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<TokenAccountBalance>
        for super::TokenAccountBalance {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TokenAccountBalance,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { amount: value.amount? })
            }
        }
        impl ::std::convert::From<super::TokenAccountBalance> for TokenAccountBalance {
            fn from(value: super::TokenAccountBalance) -> Self {
                Self { amount: Ok(value.amount) }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TokenAccountList {
            cursor: ::std::result::Result<
                ::std::option::Option<super::Base58String>,
                ::std::string::String,
            >,
            items: ::std::result::Result<
                ::std::vec::Vec<super::TokenAccount>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for TokenAccountList {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    items: Err("no value supplied for items".to_string()),
                }
            }
        }
        impl TokenAccountList {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Base58String>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::TokenAccount>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<TokenAccountList> for super::TokenAccountList {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TokenAccountList,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    items: value.items?,
                })
            }
        }
        impl ::std::convert::From<super::TokenAccountList> for TokenAccountList {
            fn from(value: super::TokenAccountList) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    items: Ok(value.items),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TokenAccountListV2 {
            cursor: ::std::result::Result<
                ::std::option::Option<super::Base58String>,
                ::std::string::String,
            >,
            items: ::std::result::Result<
                ::std::vec::Vec<super::TokenAccountV2>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for TokenAccountListV2 {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    items: Err("no value supplied for items".to_string()),
                }
            }
        }
        impl TokenAccountListV2 {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Base58String>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::TokenAccountV2>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<TokenAccountListV2> for super::TokenAccountListV2 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TokenAccountListV2,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    items: value.items?,
                })
            }
        }
        impl ::std::convert::From<super::TokenAccountListV2> for TokenAccountListV2 {
            fn from(value: super::TokenAccountListV2) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    items: Ok(value.items),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TokenAccountV2 {
            account: ::std::result::Result<super::AccountV2, ::std::string::String>,
            token_data: ::std::result::Result<super::TokenData, ::std::string::String>,
        }
        impl ::std::default::Default for TokenAccountV2 {
            fn default() -> Self {
                Self {
                    account: Err("no value supplied for account".to_string()),
                    token_data: Err("no value supplied for token_data".to_string()),
                }
            }
        }
        impl TokenAccountV2 {
            pub fn account<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AccountV2>,
                T::Error: ::std::fmt::Display,
            {
                self.account = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for account: {e}")
                    });
                self
            }
            pub fn token_data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TokenData>,
                T::Error: ::std::fmt::Display,
            {
                self.token_data = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for token_data: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<TokenAccountV2> for super::TokenAccountV2 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TokenAccountV2,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account: value.account?,
                    token_data: value.token_data?,
                })
            }
        }
        impl ::std::convert::From<super::TokenAccountV2> for TokenAccountV2 {
            fn from(value: super::TokenAccountV2) -> Self {
                Self {
                    account: Ok(value.account),
                    token_data: Ok(value.token_data),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TokenBalance {
            balance: ::std::result::Result<
                super::UnsignedInteger,
                ::std::string::String,
            >,
            mint: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for TokenBalance {
            fn default() -> Self {
                Self {
                    balance: Err("no value supplied for balance".to_string()),
                    mint: Err("no value supplied for mint".to_string()),
                }
            }
        }
        impl TokenBalance {
            pub fn balance<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UnsignedInteger>,
                T::Error: ::std::fmt::Display,
            {
                self.balance = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for balance: {e}")
                    });
                self
            }
            pub fn mint<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.mint = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for mint: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<TokenBalance> for super::TokenBalance {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TokenBalance,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    balance: value.balance?,
                    mint: value.mint?,
                })
            }
        }
        impl ::std::convert::From<super::TokenBalance> for TokenBalance {
            fn from(value: super::TokenBalance) -> Self {
                Self {
                    balance: Ok(value.balance),
                    mint: Ok(value.mint),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TokenBalanceList {
            cursor: ::std::result::Result<
                ::std::option::Option<super::Base58String>,
                ::std::string::String,
            >,
            token_balances: ::std::result::Result<
                ::std::vec::Vec<super::TokenBalance>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for TokenBalanceList {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    token_balances: Err(
                        "no value supplied for token_balances".to_string(),
                    ),
                }
            }
        }
        impl TokenBalanceList {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Base58String>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn token_balances<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::TokenBalance>>,
                T::Error: ::std::fmt::Display,
            {
                self.token_balances = value
                    .try_into()
                    .map_err(|e| {
                        format!(
                            "error converting supplied value for token_balances: {e}"
                        )
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<TokenBalanceList> for super::TokenBalanceList {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TokenBalanceList,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    token_balances: value.token_balances?,
                })
            }
        }
        impl ::std::convert::From<super::TokenBalanceList> for TokenBalanceList {
            fn from(value: super::TokenBalanceList) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    token_balances: Ok(value.token_balances),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TokenBalanceListV2 {
            cursor: ::std::result::Result<
                ::std::option::Option<super::Base58String>,
                ::std::string::String,
            >,
            items: ::std::result::Result<
                ::std::vec::Vec<super::TokenBalance>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for TokenBalanceListV2 {
            fn default() -> Self {
                Self {
                    cursor: Ok(Default::default()),
                    items: Err("no value supplied for items".to_string()),
                }
            }
        }
        impl TokenBalanceListV2 {
            pub fn cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Base58String>>,
                T::Error: ::std::fmt::Display,
            {
                self.cursor = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cursor: {e}")
                    });
                self
            }
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::TokenBalance>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for items: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<TokenBalanceListV2> for super::TokenBalanceListV2 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TokenBalanceListV2,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cursor: value.cursor?,
                    items: value.items?,
                })
            }
        }
        impl ::std::convert::From<super::TokenBalanceListV2> for TokenBalanceListV2 {
            fn from(value: super::TokenBalanceListV2) -> Self {
                Self {
                    cursor: Ok(value.cursor),
                    items: Ok(value.items),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TokenData {
            amount: ::std::result::Result<super::UnsignedInteger, ::std::string::String>,
            delegate: ::std::result::Result<
                ::std::option::Option<super::SerializablePubkey>,
                ::std::string::String,
            >,
            mint: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
            owner: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
            state: ::std::result::Result<super::AccountState, ::std::string::String>,
            tlv: ::std::result::Result<
                ::std::option::Option<super::Base64String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for TokenData {
            fn default() -> Self {
                Self {
                    amount: Err("no value supplied for amount".to_string()),
                    delegate: Ok(Default::default()),
                    mint: Err("no value supplied for mint".to_string()),
                    owner: Err("no value supplied for owner".to_string()),
                    state: Err("no value supplied for state".to_string()),
                    tlv: Ok(Default::default()),
                }
            }
        }
        impl TokenData {
            pub fn amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UnsignedInteger>,
                T::Error: ::std::fmt::Display,
            {
                self.amount = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for amount: {e}")
                    });
                self
            }
            pub fn delegate<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::SerializablePubkey>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.delegate = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for delegate: {e}")
                    });
                self
            }
            pub fn mint<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.mint = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for mint: {e}")
                    });
                self
            }
            pub fn owner<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.owner = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for owner: {e}")
                    });
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AccountState>,
                T::Error: ::std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for state: {e}")
                    });
                self
            }
            pub fn tlv<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Base64String>>,
                T::Error: ::std::fmt::Display,
            {
                self.tlv = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for tlv: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<TokenData> for super::TokenData {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TokenData,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    amount: value.amount?,
                    delegate: value.delegate?,
                    mint: value.mint?,
                    owner: value.owner?,
                    state: value.state?,
                    tlv: value.tlv?,
                })
            }
        }
        impl ::std::convert::From<super::TokenData> for TokenData {
            fn from(value: super::TokenData) -> Self {
                Self {
                    amount: Ok(value.amount),
                    delegate: Ok(value.delegate),
                    mint: Ok(value.mint),
                    owner: Ok(value.owner),
                    state: Ok(value.state),
                    tlv: Ok(value.tlv),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TreeContextInfo {
            cpi_context: ::std::result::Result<
                ::std::option::Option<super::SerializablePubkey>,
                ::std::string::String,
            >,
            queue: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
            tree: ::std::result::Result<
                super::SerializablePubkey,
                ::std::string::String,
            >,
            tree_type: ::std::result::Result<u16, ::std::string::String>,
        }
        impl ::std::default::Default for TreeContextInfo {
            fn default() -> Self {
                Self {
                    cpi_context: Ok(Default::default()),
                    queue: Err("no value supplied for queue".to_string()),
                    tree: Err("no value supplied for tree".to_string()),
                    tree_type: Err("no value supplied for tree_type".to_string()),
                }
            }
        }
        impl TreeContextInfo {
            pub fn cpi_context<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::SerializablePubkey>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.cpi_context = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for cpi_context: {e}")
                    });
                self
            }
            pub fn queue<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.queue = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for queue: {e}")
                    });
                self
            }
            pub fn tree<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SerializablePubkey>,
                T::Error: ::std::fmt::Display,
            {
                self.tree = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for tree: {e}")
                    });
                self
            }
            pub fn tree_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u16>,
                T::Error: ::std::fmt::Display,
            {
                self.tree_type = value
                    .try_into()
                    .map_err(|e| {
                        format!("error converting supplied value for tree_type: {e}")
                    });
                self
            }
        }
        impl ::std::convert::TryFrom<TreeContextInfo> for super::TreeContextInfo {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TreeContextInfo,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cpi_context: value.cpi_context?,
                    queue: value.queue?,
                    tree: value.tree?,
                    tree_type: value.tree_type?,
                })
            }
        }
        impl ::std::convert::From<super::TreeContextInfo> for TreeContextInfo {
            fn from(value: super::TreeContextInfo) -> Self {
                Self {
                    cpi_context: Ok(value.cpi_context),
                    queue: Ok(value.queue),
                    tree: Ok(value.tree),
                    tree_type: Ok(value.tree_type),
                }
            }
        }
    }
    /// Generation of default values for serde.
    pub mod defaults {
        pub(super) fn default_u64<T, const V: u64>() -> T
        where
            T: ::std::convert::TryFrom<u64>,
            <T as ::std::convert::TryFrom<u64>>::Error: ::std::fmt::Debug,
        {
            T::try_from(V).unwrap()
        }
        pub(super) fn post_get_indexer_health_response_result() -> super::PostGetIndexerHealthResponseResult {
            super::PostGetIndexerHealthResponseResult::Ok
        }
    }
}
#[derive(Clone, Debug)]
/**Client for photon-indexer

Solana indexer for general compression

Version: 0.51.2*/
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
}
impl Client {
    /// Create a new client.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new(baseurl: &str) -> Self {
        #[cfg(not(target_arch = "wasm32"))]
        let client = {
            let dur = ::std::time::Duration::from_secs(15u64);
            reqwest::ClientBuilder::new().connect_timeout(dur).timeout(dur)
        };
        #[cfg(target_arch = "wasm32")]
        let client = reqwest::ClientBuilder::new();
        Self::new_with_client(baseurl, client.build().unwrap())
    }
    /// Construct a new client with an existing `reqwest::Client`,
    /// allowing more control over its configuration.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }
}
impl ClientInfo<()> for Client {
    fn api_version() -> &'static str {
        "0.51.2"
    }
    fn baseurl(&self) -> &str {
        self.baseurl.as_str()
    }
    fn client(&self) -> &reqwest::Client {
        &self.client
    }
    fn inner(&self) -> &() {
        &()
    }
}
impl ClientHooks<()> for &Client {}
impl Client {
    /**Sends a `POST` request to `/getAccountInterface`

```ignore
let response = client.post_get_account_interface()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_account_interface(&self) -> builder::PostGetAccountInterface<'_> {
        builder::PostGetAccountInterface::new(self)
    }
    /**Sends a `POST` request to `/getCompressedAccount`

```ignore
let response = client.post_get_compressed_account()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_compressed_account(&self) -> builder::PostGetCompressedAccount<'_> {
        builder::PostGetCompressedAccount::new(self)
    }
    /**Sends a `POST` request to `/getCompressedAccountBalance`

```ignore
let response = client.post_get_compressed_account_balance()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_compressed_account_balance(
        &self,
    ) -> builder::PostGetCompressedAccountBalance<'_> {
        builder::PostGetCompressedAccountBalance::new(self)
    }
    /**Sends a `POST` request to `/getCompressedAccountProof`

```ignore
let response = client.post_get_compressed_account_proof()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_compressed_account_proof(
        &self,
    ) -> builder::PostGetCompressedAccountProof<'_> {
        builder::PostGetCompressedAccountProof::new(self)
    }
    /**Sends a `POST` request to `/getCompressedAccountProofV2`

```ignore
let response = client.post_get_compressed_account_proof_v2()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_compressed_account_proof_v2(
        &self,
    ) -> builder::PostGetCompressedAccountProofV2<'_> {
        builder::PostGetCompressedAccountProofV2::new(self)
    }
    /**Sends a `POST` request to `/getCompressedAccountV2`

```ignore
let response = client.post_get_compressed_account_v2()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_compressed_account_v2(
        &self,
    ) -> builder::PostGetCompressedAccountV2<'_> {
        builder::PostGetCompressedAccountV2::new(self)
    }
    /**Sends a `POST` request to `/getCompressedAccountsByOwner`

```ignore
let response = client.post_get_compressed_accounts_by_owner()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_compressed_accounts_by_owner(
        &self,
    ) -> builder::PostGetCompressedAccountsByOwner<'_> {
        builder::PostGetCompressedAccountsByOwner::new(self)
    }
    /**Sends a `POST` request to `/getCompressedAccountsByOwnerV2`

```ignore
let response = client.post_get_compressed_accounts_by_owner_v2()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_compressed_accounts_by_owner_v2(
        &self,
    ) -> builder::PostGetCompressedAccountsByOwnerV2<'_> {
        builder::PostGetCompressedAccountsByOwnerV2::new(self)
    }
    /**Sends a `POST` request to `/getCompressedBalanceByOwner`

```ignore
let response = client.post_get_compressed_balance_by_owner()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_compressed_balance_by_owner(
        &self,
    ) -> builder::PostGetCompressedBalanceByOwner<'_> {
        builder::PostGetCompressedBalanceByOwner::new(self)
    }
    /**Sends a `POST` request to `/getCompressedMintTokenHolders`

```ignore
let response = client.post_get_compressed_mint_token_holders()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_compressed_mint_token_holders(
        &self,
    ) -> builder::PostGetCompressedMintTokenHolders<'_> {
        builder::PostGetCompressedMintTokenHolders::new(self)
    }
    /**Sends a `POST` request to `/getCompressedTokenAccountBalance`

```ignore
let response = client.post_get_compressed_token_account_balance()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_compressed_token_account_balance(
        &self,
    ) -> builder::PostGetCompressedTokenAccountBalance<'_> {
        builder::PostGetCompressedTokenAccountBalance::new(self)
    }
    /**Sends a `POST` request to `/getCompressedTokenAccountsByDelegate`

```ignore
let response = client.post_get_compressed_token_accounts_by_delegate()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_compressed_token_accounts_by_delegate(
        &self,
    ) -> builder::PostGetCompressedTokenAccountsByDelegate<'_> {
        builder::PostGetCompressedTokenAccountsByDelegate::new(self)
    }
    /**Sends a `POST` request to `/getCompressedTokenAccountsByDelegateV2`

```ignore
let response = client.post_get_compressed_token_accounts_by_delegate_v2()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_compressed_token_accounts_by_delegate_v2(
        &self,
    ) -> builder::PostGetCompressedTokenAccountsByDelegateV2<'_> {
        builder::PostGetCompressedTokenAccountsByDelegateV2::new(self)
    }
    /**Sends a `POST` request to `/getCompressedTokenAccountsByOwner`

```ignore
let response = client.post_get_compressed_token_accounts_by_owner()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_compressed_token_accounts_by_owner(
        &self,
    ) -> builder::PostGetCompressedTokenAccountsByOwner<'_> {
        builder::PostGetCompressedTokenAccountsByOwner::new(self)
    }
    /**Sends a `POST` request to `/getCompressedTokenAccountsByOwnerV2`

```ignore
let response = client.post_get_compressed_token_accounts_by_owner_v2()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_compressed_token_accounts_by_owner_v2(
        &self,
    ) -> builder::PostGetCompressedTokenAccountsByOwnerV2<'_> {
        builder::PostGetCompressedTokenAccountsByOwnerV2::new(self)
    }
    /**Sends a `POST` request to `/getCompressedTokenBalancesByOwner`

```ignore
let response = client.post_get_compressed_token_balances_by_owner()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_compressed_token_balances_by_owner(
        &self,
    ) -> builder::PostGetCompressedTokenBalancesByOwner<'_> {
        builder::PostGetCompressedTokenBalancesByOwner::new(self)
    }
    /**Sends a `POST` request to `/getCompressedTokenBalancesByOwnerV2`

```ignore
let response = client.post_get_compressed_token_balances_by_owner_v2()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_compressed_token_balances_by_owner_v2(
        &self,
    ) -> builder::PostGetCompressedTokenBalancesByOwnerV2<'_> {
        builder::PostGetCompressedTokenBalancesByOwnerV2::new(self)
    }
    /**Sends a `POST` request to `/getCompressionSignaturesForAccount`

```ignore
let response = client.post_get_compression_signatures_for_account()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_compression_signatures_for_account(
        &self,
    ) -> builder::PostGetCompressionSignaturesForAccount<'_> {
        builder::PostGetCompressionSignaturesForAccount::new(self)
    }
    /**Sends a `POST` request to `/getCompressionSignaturesForAddress`

```ignore
let response = client.post_get_compression_signatures_for_address()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_compression_signatures_for_address(
        &self,
    ) -> builder::PostGetCompressionSignaturesForAddress<'_> {
        builder::PostGetCompressionSignaturesForAddress::new(self)
    }
    /**Sends a `POST` request to `/getCompressionSignaturesForOwner`

```ignore
let response = client.post_get_compression_signatures_for_owner()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_compression_signatures_for_owner(
        &self,
    ) -> builder::PostGetCompressionSignaturesForOwner<'_> {
        builder::PostGetCompressionSignaturesForOwner::new(self)
    }
    /**Sends a `POST` request to `/getCompressionSignaturesForTokenOwner`

```ignore
let response = client.post_get_compression_signatures_for_token_owner()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_compression_signatures_for_token_owner(
        &self,
    ) -> builder::PostGetCompressionSignaturesForTokenOwner<'_> {
        builder::PostGetCompressionSignaturesForTokenOwner::new(self)
    }
    /**Sends a `POST` request to `/getIndexerHealth`

```ignore
let response = client.post_get_indexer_health()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_indexer_health(&self) -> builder::PostGetIndexerHealth<'_> {
        builder::PostGetIndexerHealth::new(self)
    }
    /**Sends a `POST` request to `/getIndexerSlot`

```ignore
let response = client.post_get_indexer_slot()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_indexer_slot(&self) -> builder::PostGetIndexerSlot<'_> {
        builder::PostGetIndexerSlot::new(self)
    }
    /**Sends a `POST` request to `/getLatestCompressionSignatures`

```ignore
let response = client.post_get_latest_compression_signatures()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_latest_compression_signatures(
        &self,
    ) -> builder::PostGetLatestCompressionSignatures<'_> {
        builder::PostGetLatestCompressionSignatures::new(self)
    }
    /**Sends a `POST` request to `/getLatestNonVotingSignatures`

```ignore
let response = client.post_get_latest_non_voting_signatures()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_latest_non_voting_signatures(
        &self,
    ) -> builder::PostGetLatestNonVotingSignatures<'_> {
        builder::PostGetLatestNonVotingSignatures::new(self)
    }
    /**Sends a `POST` request to `/getMultipleAccountInterfaces`

```ignore
let response = client.post_get_multiple_account_interfaces()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_multiple_account_interfaces(
        &self,
    ) -> builder::PostGetMultipleAccountInterfaces<'_> {
        builder::PostGetMultipleAccountInterfaces::new(self)
    }
    /**Sends a `POST` request to `/getMultipleCompressedAccountProofs`

```ignore
let response = client.post_get_multiple_compressed_account_proofs()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_multiple_compressed_account_proofs(
        &self,
    ) -> builder::PostGetMultipleCompressedAccountProofs<'_> {
        builder::PostGetMultipleCompressedAccountProofs::new(self)
    }
    /**Sends a `POST` request to `/getMultipleCompressedAccountProofsV2`

```ignore
let response = client.post_get_multiple_compressed_account_proofs_v2()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_multiple_compressed_account_proofs_v2(
        &self,
    ) -> builder::PostGetMultipleCompressedAccountProofsV2<'_> {
        builder::PostGetMultipleCompressedAccountProofsV2::new(self)
    }
    /**Sends a `POST` request to `/getMultipleCompressedAccounts`

```ignore
let response = client.post_get_multiple_compressed_accounts()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_multiple_compressed_accounts(
        &self,
    ) -> builder::PostGetMultipleCompressedAccounts<'_> {
        builder::PostGetMultipleCompressedAccounts::new(self)
    }
    /**Sends a `POST` request to `/getMultipleCompressedAccountsV2`

```ignore
let response = client.post_get_multiple_compressed_accounts_v2()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_multiple_compressed_accounts_v2(
        &self,
    ) -> builder::PostGetMultipleCompressedAccountsV2<'_> {
        builder::PostGetMultipleCompressedAccountsV2::new(self)
    }
    /**Sends a `POST` request to `/getMultipleNewAddressProofs`

```ignore
let response = client.post_get_multiple_new_address_proofs()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_multiple_new_address_proofs(
        &self,
    ) -> builder::PostGetMultipleNewAddressProofs<'_> {
        builder::PostGetMultipleNewAddressProofs::new(self)
    }
    /**Sends a `POST` request to `/getMultipleNewAddressProofsV2`

```ignore
let response = client.post_get_multiple_new_address_proofs_v2()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_multiple_new_address_proofs_v2(
        &self,
    ) -> builder::PostGetMultipleNewAddressProofsV2<'_> {
        builder::PostGetMultipleNewAddressProofsV2::new(self)
    }
    /**Sends a `POST` request to `/getQueueElements`

```ignore
let response = client.post_get_queue_elements()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_queue_elements(&self) -> builder::PostGetQueueElements<'_> {
        builder::PostGetQueueElements::new(self)
    }
    /**Sends a `POST` request to `/getQueueInfo`

```ignore
let response = client.post_get_queue_info()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_queue_info(&self) -> builder::PostGetQueueInfo<'_> {
        builder::PostGetQueueInfo::new(self)
    }
    /**Sends a `POST` request to `/getTransactionWithCompressionInfo`

```ignore
let response = client.post_get_transaction_with_compression_info()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_transaction_with_compression_info(
        &self,
    ) -> builder::PostGetTransactionWithCompressionInfo<'_> {
        builder::PostGetTransactionWithCompressionInfo::new(self)
    }
    /**Sends a `POST` request to `/getTransactionWithCompressionInfoV2`

```ignore
let response = client.post_get_transaction_with_compression_info_v2()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_transaction_with_compression_info_v2(
        &self,
    ) -> builder::PostGetTransactionWithCompressionInfoV2<'_> {
        builder::PostGetTransactionWithCompressionInfoV2::new(self)
    }
    /**Sends a `POST` request to `/getValidityProof`

```ignore
let response = client.post_get_validity_proof()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_validity_proof(&self) -> builder::PostGetValidityProof<'_> {
        builder::PostGetValidityProof::new(self)
    }
    /**Sends a `POST` request to `/getValidityProofV2`

```ignore
let response = client.post_get_validity_proof_v2()
    .body(body)
    .send()
    .await;
```*/
    pub fn post_get_validity_proof_v2(&self) -> builder::PostGetValidityProofV2<'_> {
        builder::PostGetValidityProofV2::new(self)
    }
}
/// Types for composing operation parameters.
#[allow(clippy::all)]
pub mod builder {
    use super::types;
    #[allow(unused_imports)]
    use super::{
        encode_path, ByteStream, ClientInfo, ClientHooks, Error, OperationInfo,
        RequestBuilderExt, ResponseValue,
    };
    /**Builder for [`Client::post_get_account_interface`]

[`Client::post_get_account_interface`]: super::Client::post_get_account_interface*/
    #[derive(Debug, Clone)]
    pub struct PostGetAccountInterface<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetAccountInterfaceBody, String>,
    }
    impl<'a> PostGetAccountInterface<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetAccountInterfaceBody>,
            <V as std::convert::TryInto<
                types::PostGetAccountInterfaceBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetAccountInterfaceBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetAccountInterfaceBody,
            ) -> types::builder::PostGetAccountInterfaceBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getAccountInterface`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetAccountInterfaceResponse>,
            Error<types::PostGetAccountInterfaceResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetAccountInterfaceBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getAccountInterface", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_account_interface",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_compressed_account`]

[`Client::post_get_compressed_account`]: super::Client::post_get_compressed_account*/
    #[derive(Debug, Clone)]
    pub struct PostGetCompressedAccount<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetCompressedAccountBody, String>,
    }
    impl<'a> PostGetCompressedAccount<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetCompressedAccountBody>,
            <V as std::convert::TryInto<
                types::PostGetCompressedAccountBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetCompressedAccountBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetCompressedAccountBody,
            ) -> types::builder::PostGetCompressedAccountBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getCompressedAccount`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetCompressedAccountResponse>,
            Error<types::PostGetCompressedAccountResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetCompressedAccountBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getCompressedAccount", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_compressed_account",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_compressed_account_balance`]

[`Client::post_get_compressed_account_balance`]: super::Client::post_get_compressed_account_balance*/
    #[derive(Debug, Clone)]
    pub struct PostGetCompressedAccountBalance<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetCompressedAccountBalanceBody, String>,
    }
    impl<'a> PostGetCompressedAccountBalance<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetCompressedAccountBalanceBody>,
            <V as std::convert::TryInto<
                types::PostGetCompressedAccountBalanceBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetCompressedAccountBalanceBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetCompressedAccountBalanceBody,
            ) -> types::builder::PostGetCompressedAccountBalanceBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getCompressedAccountBalance`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetCompressedAccountBalanceResponse>,
            Error<types::PostGetCompressedAccountBalanceResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetCompressedAccountBalanceBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getCompressedAccountBalance", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_compressed_account_balance",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_compressed_account_proof`]

[`Client::post_get_compressed_account_proof`]: super::Client::post_get_compressed_account_proof*/
    #[derive(Debug, Clone)]
    pub struct PostGetCompressedAccountProof<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetCompressedAccountProofBody, String>,
    }
    impl<'a> PostGetCompressedAccountProof<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetCompressedAccountProofBody>,
            <V as std::convert::TryInto<
                types::PostGetCompressedAccountProofBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetCompressedAccountProofBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetCompressedAccountProofBody,
            ) -> types::builder::PostGetCompressedAccountProofBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getCompressedAccountProof`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetCompressedAccountProofResponse>,
            Error<types::PostGetCompressedAccountProofResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetCompressedAccountProofBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getCompressedAccountProof", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_compressed_account_proof",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_compressed_account_proof_v2`]

[`Client::post_get_compressed_account_proof_v2`]: super::Client::post_get_compressed_account_proof_v2*/
    #[derive(Debug, Clone)]
    pub struct PostGetCompressedAccountProofV2<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetCompressedAccountProofV2Body, String>,
    }
    impl<'a> PostGetCompressedAccountProofV2<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetCompressedAccountProofV2Body>,
            <V as std::convert::TryInto<
                types::PostGetCompressedAccountProofV2Body,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetCompressedAccountProofV2Body` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetCompressedAccountProofV2Body,
            ) -> types::builder::PostGetCompressedAccountProofV2Body,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getCompressedAccountProofV2`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetCompressedAccountProofV2Response>,
            Error<types::PostGetCompressedAccountProofV2Response>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetCompressedAccountProofV2Body::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getCompressedAccountProofV2", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_compressed_account_proof_v2",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_compressed_account_v2`]

[`Client::post_get_compressed_account_v2`]: super::Client::post_get_compressed_account_v2*/
    #[derive(Debug, Clone)]
    pub struct PostGetCompressedAccountV2<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetCompressedAccountV2Body, String>,
    }
    impl<'a> PostGetCompressedAccountV2<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetCompressedAccountV2Body>,
            <V as std::convert::TryInto<
                types::PostGetCompressedAccountV2Body,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetCompressedAccountV2Body` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetCompressedAccountV2Body,
            ) -> types::builder::PostGetCompressedAccountV2Body,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getCompressedAccountV2`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetCompressedAccountV2Response>,
            Error<types::PostGetCompressedAccountV2Response>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetCompressedAccountV2Body::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getCompressedAccountV2", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_compressed_account_v2",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_compressed_accounts_by_owner`]

[`Client::post_get_compressed_accounts_by_owner`]: super::Client::post_get_compressed_accounts_by_owner*/
    #[derive(Debug, Clone)]
    pub struct PostGetCompressedAccountsByOwner<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetCompressedAccountsByOwnerBody, String>,
    }
    impl<'a> PostGetCompressedAccountsByOwner<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetCompressedAccountsByOwnerBody>,
            <V as std::convert::TryInto<
                types::PostGetCompressedAccountsByOwnerBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetCompressedAccountsByOwnerBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetCompressedAccountsByOwnerBody,
            ) -> types::builder::PostGetCompressedAccountsByOwnerBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getCompressedAccountsByOwner`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetCompressedAccountsByOwnerResponse>,
            Error<types::PostGetCompressedAccountsByOwnerResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetCompressedAccountsByOwnerBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getCompressedAccountsByOwner", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_compressed_accounts_by_owner",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_compressed_accounts_by_owner_v2`]

[`Client::post_get_compressed_accounts_by_owner_v2`]: super::Client::post_get_compressed_accounts_by_owner_v2*/
    #[derive(Debug, Clone)]
    pub struct PostGetCompressedAccountsByOwnerV2<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetCompressedAccountsByOwnerV2Body, String>,
    }
    impl<'a> PostGetCompressedAccountsByOwnerV2<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetCompressedAccountsByOwnerV2Body>,
            <V as std::convert::TryInto<
                types::PostGetCompressedAccountsByOwnerV2Body,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetCompressedAccountsByOwnerV2Body` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetCompressedAccountsByOwnerV2Body,
            ) -> types::builder::PostGetCompressedAccountsByOwnerV2Body,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getCompressedAccountsByOwnerV2`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetCompressedAccountsByOwnerV2Response>,
            Error<types::PostGetCompressedAccountsByOwnerV2Response>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetCompressedAccountsByOwnerV2Body::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getCompressedAccountsByOwnerV2", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_compressed_accounts_by_owner_v2",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_compressed_balance_by_owner`]

[`Client::post_get_compressed_balance_by_owner`]: super::Client::post_get_compressed_balance_by_owner*/
    #[derive(Debug, Clone)]
    pub struct PostGetCompressedBalanceByOwner<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetCompressedBalanceByOwnerBody, String>,
    }
    impl<'a> PostGetCompressedBalanceByOwner<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetCompressedBalanceByOwnerBody>,
            <V as std::convert::TryInto<
                types::PostGetCompressedBalanceByOwnerBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetCompressedBalanceByOwnerBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetCompressedBalanceByOwnerBody,
            ) -> types::builder::PostGetCompressedBalanceByOwnerBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getCompressedBalanceByOwner`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetCompressedBalanceByOwnerResponse>,
            Error<types::PostGetCompressedBalanceByOwnerResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetCompressedBalanceByOwnerBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getCompressedBalanceByOwner", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_compressed_balance_by_owner",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_compressed_mint_token_holders`]

[`Client::post_get_compressed_mint_token_holders`]: super::Client::post_get_compressed_mint_token_holders*/
    #[derive(Debug, Clone)]
    pub struct PostGetCompressedMintTokenHolders<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetCompressedMintTokenHoldersBody, String>,
    }
    impl<'a> PostGetCompressedMintTokenHolders<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetCompressedMintTokenHoldersBody>,
            <V as std::convert::TryInto<
                types::PostGetCompressedMintTokenHoldersBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetCompressedMintTokenHoldersBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetCompressedMintTokenHoldersBody,
            ) -> types::builder::PostGetCompressedMintTokenHoldersBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getCompressedMintTokenHolders`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetCompressedMintTokenHoldersResponse>,
            Error<types::PostGetCompressedMintTokenHoldersResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetCompressedMintTokenHoldersBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getCompressedMintTokenHolders", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_compressed_mint_token_holders",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_compressed_token_account_balance`]

[`Client::post_get_compressed_token_account_balance`]: super::Client::post_get_compressed_token_account_balance*/
    #[derive(Debug, Clone)]
    pub struct PostGetCompressedTokenAccountBalance<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetCompressedTokenAccountBalanceBody, String>,
    }
    impl<'a> PostGetCompressedTokenAccountBalance<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetCompressedTokenAccountBalanceBody>,
            <V as std::convert::TryInto<
                types::PostGetCompressedTokenAccountBalanceBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetCompressedTokenAccountBalanceBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetCompressedTokenAccountBalanceBody,
            ) -> types::builder::PostGetCompressedTokenAccountBalanceBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getCompressedTokenAccountBalance`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetCompressedTokenAccountBalanceResponse>,
            Error<types::PostGetCompressedTokenAccountBalanceResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetCompressedTokenAccountBalanceBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getCompressedTokenAccountBalance", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_compressed_token_account_balance",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_compressed_token_accounts_by_delegate`]

[`Client::post_get_compressed_token_accounts_by_delegate`]: super::Client::post_get_compressed_token_accounts_by_delegate*/
    #[derive(Debug, Clone)]
    pub struct PostGetCompressedTokenAccountsByDelegate<'a> {
        client: &'a super::Client,
        body: Result<
            types::builder::PostGetCompressedTokenAccountsByDelegateBody,
            String,
        >,
    }
    impl<'a> PostGetCompressedTokenAccountsByDelegate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<
                types::PostGetCompressedTokenAccountsByDelegateBody,
            >,
            <V as std::convert::TryInto<
                types::PostGetCompressedTokenAccountsByDelegateBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetCompressedTokenAccountsByDelegateBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetCompressedTokenAccountsByDelegateBody,
            ) -> types::builder::PostGetCompressedTokenAccountsByDelegateBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getCompressedTokenAccountsByDelegate`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetCompressedTokenAccountsByDelegateResponse>,
            Error<types::PostGetCompressedTokenAccountsByDelegateResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetCompressedTokenAccountsByDelegateBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/getCompressedTokenAccountsByDelegate", client.baseurl,
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_compressed_token_accounts_by_delegate",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_compressed_token_accounts_by_delegate_v2`]

[`Client::post_get_compressed_token_accounts_by_delegate_v2`]: super::Client::post_get_compressed_token_accounts_by_delegate_v2*/
    #[derive(Debug, Clone)]
    pub struct PostGetCompressedTokenAccountsByDelegateV2<'a> {
        client: &'a super::Client,
        body: Result<
            types::builder::PostGetCompressedTokenAccountsByDelegateV2Body,
            String,
        >,
    }
    impl<'a> PostGetCompressedTokenAccountsByDelegateV2<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<
                types::PostGetCompressedTokenAccountsByDelegateV2Body,
            >,
            <V as std::convert::TryInto<
                types::PostGetCompressedTokenAccountsByDelegateV2Body,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetCompressedTokenAccountsByDelegateV2Body` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetCompressedTokenAccountsByDelegateV2Body,
            ) -> types::builder::PostGetCompressedTokenAccountsByDelegateV2Body,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getCompressedTokenAccountsByDelegateV2`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetCompressedTokenAccountsByDelegateV2Response>,
            Error<types::PostGetCompressedTokenAccountsByDelegateV2Response>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetCompressedTokenAccountsByDelegateV2Body::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/getCompressedTokenAccountsByDelegateV2", client.baseurl,
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_compressed_token_accounts_by_delegate_v2",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_compressed_token_accounts_by_owner`]

[`Client::post_get_compressed_token_accounts_by_owner`]: super::Client::post_get_compressed_token_accounts_by_owner*/
    #[derive(Debug, Clone)]
    pub struct PostGetCompressedTokenAccountsByOwner<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetCompressedTokenAccountsByOwnerBody, String>,
    }
    impl<'a> PostGetCompressedTokenAccountsByOwner<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetCompressedTokenAccountsByOwnerBody>,
            <V as std::convert::TryInto<
                types::PostGetCompressedTokenAccountsByOwnerBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetCompressedTokenAccountsByOwnerBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetCompressedTokenAccountsByOwnerBody,
            ) -> types::builder::PostGetCompressedTokenAccountsByOwnerBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getCompressedTokenAccountsByOwner`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetCompressedTokenAccountsByOwnerResponse>,
            Error<types::PostGetCompressedTokenAccountsByOwnerResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetCompressedTokenAccountsByOwnerBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getCompressedTokenAccountsByOwner", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_compressed_token_accounts_by_owner",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_compressed_token_accounts_by_owner_v2`]

[`Client::post_get_compressed_token_accounts_by_owner_v2`]: super::Client::post_get_compressed_token_accounts_by_owner_v2*/
    #[derive(Debug, Clone)]
    pub struct PostGetCompressedTokenAccountsByOwnerV2<'a> {
        client: &'a super::Client,
        body: Result<
            types::builder::PostGetCompressedTokenAccountsByOwnerV2Body,
            String,
        >,
    }
    impl<'a> PostGetCompressedTokenAccountsByOwnerV2<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetCompressedTokenAccountsByOwnerV2Body>,
            <V as std::convert::TryInto<
                types::PostGetCompressedTokenAccountsByOwnerV2Body,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetCompressedTokenAccountsByOwnerV2Body` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetCompressedTokenAccountsByOwnerV2Body,
            ) -> types::builder::PostGetCompressedTokenAccountsByOwnerV2Body,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getCompressedTokenAccountsByOwnerV2`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetCompressedTokenAccountsByOwnerV2Response>,
            Error<types::PostGetCompressedTokenAccountsByOwnerV2Response>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetCompressedTokenAccountsByOwnerV2Body::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getCompressedTokenAccountsByOwnerV2", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_compressed_token_accounts_by_owner_v2",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_compressed_token_balances_by_owner`]

[`Client::post_get_compressed_token_balances_by_owner`]: super::Client::post_get_compressed_token_balances_by_owner*/
    #[derive(Debug, Clone)]
    pub struct PostGetCompressedTokenBalancesByOwner<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetCompressedTokenBalancesByOwnerBody, String>,
    }
    impl<'a> PostGetCompressedTokenBalancesByOwner<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetCompressedTokenBalancesByOwnerBody>,
            <V as std::convert::TryInto<
                types::PostGetCompressedTokenBalancesByOwnerBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetCompressedTokenBalancesByOwnerBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetCompressedTokenBalancesByOwnerBody,
            ) -> types::builder::PostGetCompressedTokenBalancesByOwnerBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getCompressedTokenBalancesByOwner`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetCompressedTokenBalancesByOwnerResponse>,
            Error<types::PostGetCompressedTokenBalancesByOwnerResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetCompressedTokenBalancesByOwnerBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getCompressedTokenBalancesByOwner", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_compressed_token_balances_by_owner",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_compressed_token_balances_by_owner_v2`]

[`Client::post_get_compressed_token_balances_by_owner_v2`]: super::Client::post_get_compressed_token_balances_by_owner_v2*/
    #[derive(Debug, Clone)]
    pub struct PostGetCompressedTokenBalancesByOwnerV2<'a> {
        client: &'a super::Client,
        body: Result<
            types::builder::PostGetCompressedTokenBalancesByOwnerV2Body,
            String,
        >,
    }
    impl<'a> PostGetCompressedTokenBalancesByOwnerV2<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetCompressedTokenBalancesByOwnerV2Body>,
            <V as std::convert::TryInto<
                types::PostGetCompressedTokenBalancesByOwnerV2Body,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetCompressedTokenBalancesByOwnerV2Body` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetCompressedTokenBalancesByOwnerV2Body,
            ) -> types::builder::PostGetCompressedTokenBalancesByOwnerV2Body,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getCompressedTokenBalancesByOwnerV2`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetCompressedTokenBalancesByOwnerV2Response>,
            Error<types::PostGetCompressedTokenBalancesByOwnerV2Response>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetCompressedTokenBalancesByOwnerV2Body::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getCompressedTokenBalancesByOwnerV2", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_compressed_token_balances_by_owner_v2",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_compression_signatures_for_account`]

[`Client::post_get_compression_signatures_for_account`]: super::Client::post_get_compression_signatures_for_account*/
    #[derive(Debug, Clone)]
    pub struct PostGetCompressionSignaturesForAccount<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetCompressionSignaturesForAccountBody, String>,
    }
    impl<'a> PostGetCompressionSignaturesForAccount<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetCompressionSignaturesForAccountBody>,
            <V as std::convert::TryInto<
                types::PostGetCompressionSignaturesForAccountBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetCompressionSignaturesForAccountBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetCompressionSignaturesForAccountBody,
            ) -> types::builder::PostGetCompressionSignaturesForAccountBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getCompressionSignaturesForAccount`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetCompressionSignaturesForAccountResponse>,
            Error<types::PostGetCompressionSignaturesForAccountResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetCompressionSignaturesForAccountBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getCompressionSignaturesForAccount", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_compression_signatures_for_account",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_compression_signatures_for_address`]

[`Client::post_get_compression_signatures_for_address`]: super::Client::post_get_compression_signatures_for_address*/
    #[derive(Debug, Clone)]
    pub struct PostGetCompressionSignaturesForAddress<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetCompressionSignaturesForAddressBody, String>,
    }
    impl<'a> PostGetCompressionSignaturesForAddress<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetCompressionSignaturesForAddressBody>,
            <V as std::convert::TryInto<
                types::PostGetCompressionSignaturesForAddressBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetCompressionSignaturesForAddressBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetCompressionSignaturesForAddressBody,
            ) -> types::builder::PostGetCompressionSignaturesForAddressBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getCompressionSignaturesForAddress`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetCompressionSignaturesForAddressResponse>,
            Error<types::PostGetCompressionSignaturesForAddressResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetCompressionSignaturesForAddressBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getCompressionSignaturesForAddress", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_compression_signatures_for_address",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_compression_signatures_for_owner`]

[`Client::post_get_compression_signatures_for_owner`]: super::Client::post_get_compression_signatures_for_owner*/
    #[derive(Debug, Clone)]
    pub struct PostGetCompressionSignaturesForOwner<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetCompressionSignaturesForOwnerBody, String>,
    }
    impl<'a> PostGetCompressionSignaturesForOwner<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetCompressionSignaturesForOwnerBody>,
            <V as std::convert::TryInto<
                types::PostGetCompressionSignaturesForOwnerBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetCompressionSignaturesForOwnerBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetCompressionSignaturesForOwnerBody,
            ) -> types::builder::PostGetCompressionSignaturesForOwnerBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getCompressionSignaturesForOwner`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetCompressionSignaturesForOwnerResponse>,
            Error<types::PostGetCompressionSignaturesForOwnerResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetCompressionSignaturesForOwnerBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getCompressionSignaturesForOwner", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_compression_signatures_for_owner",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_compression_signatures_for_token_owner`]

[`Client::post_get_compression_signatures_for_token_owner`]: super::Client::post_get_compression_signatures_for_token_owner*/
    #[derive(Debug, Clone)]
    pub struct PostGetCompressionSignaturesForTokenOwner<'a> {
        client: &'a super::Client,
        body: Result<
            types::builder::PostGetCompressionSignaturesForTokenOwnerBody,
            String,
        >,
    }
    impl<'a> PostGetCompressionSignaturesForTokenOwner<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<
                types::PostGetCompressionSignaturesForTokenOwnerBody,
            >,
            <V as std::convert::TryInto<
                types::PostGetCompressionSignaturesForTokenOwnerBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetCompressionSignaturesForTokenOwnerBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetCompressionSignaturesForTokenOwnerBody,
            ) -> types::builder::PostGetCompressionSignaturesForTokenOwnerBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getCompressionSignaturesForTokenOwner`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetCompressionSignaturesForTokenOwnerResponse>,
            Error<types::PostGetCompressionSignaturesForTokenOwnerResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetCompressionSignaturesForTokenOwnerBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/getCompressionSignaturesForTokenOwner", client.baseurl,
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_compression_signatures_for_token_owner",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_indexer_health`]

[`Client::post_get_indexer_health`]: super::Client::post_get_indexer_health*/
    #[derive(Debug, Clone)]
    pub struct PostGetIndexerHealth<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetIndexerHealthBody, String>,
    }
    impl<'a> PostGetIndexerHealth<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetIndexerHealthBody>,
            <V as std::convert::TryInto<
                types::PostGetIndexerHealthBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetIndexerHealthBody` for body failed: {}", s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetIndexerHealthBody,
            ) -> types::builder::PostGetIndexerHealthBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getIndexerHealth`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetIndexerHealthResponse>,
            Error<types::PostGetIndexerHealthResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetIndexerHealthBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getIndexerHealth", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_indexer_health",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_indexer_slot`]

[`Client::post_get_indexer_slot`]: super::Client::post_get_indexer_slot*/
    #[derive(Debug, Clone)]
    pub struct PostGetIndexerSlot<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetIndexerSlotBody, String>,
    }
    impl<'a> PostGetIndexerSlot<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetIndexerSlotBody>,
            <V as std::convert::TryInto<
                types::PostGetIndexerSlotBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetIndexerSlotBody` for body failed: {}", s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetIndexerSlotBody,
            ) -> types::builder::PostGetIndexerSlotBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getIndexerSlot`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetIndexerSlotResponse>,
            Error<types::PostGetIndexerSlotResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetIndexerSlotBody::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getIndexerSlot", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_indexer_slot",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_latest_compression_signatures`]

[`Client::post_get_latest_compression_signatures`]: super::Client::post_get_latest_compression_signatures*/
    #[derive(Debug, Clone)]
    pub struct PostGetLatestCompressionSignatures<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetLatestCompressionSignaturesBody, String>,
    }
    impl<'a> PostGetLatestCompressionSignatures<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetLatestCompressionSignaturesBody>,
            <V as std::convert::TryInto<
                types::PostGetLatestCompressionSignaturesBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetLatestCompressionSignaturesBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetLatestCompressionSignaturesBody,
            ) -> types::builder::PostGetLatestCompressionSignaturesBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getLatestCompressionSignatures`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetLatestCompressionSignaturesResponse>,
            Error<types::PostGetLatestCompressionSignaturesResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetLatestCompressionSignaturesBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getLatestCompressionSignatures", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_latest_compression_signatures",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_latest_non_voting_signatures`]

[`Client::post_get_latest_non_voting_signatures`]: super::Client::post_get_latest_non_voting_signatures*/
    #[derive(Debug, Clone)]
    pub struct PostGetLatestNonVotingSignatures<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetLatestNonVotingSignaturesBody, String>,
    }
    impl<'a> PostGetLatestNonVotingSignatures<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetLatestNonVotingSignaturesBody>,
            <V as std::convert::TryInto<
                types::PostGetLatestNonVotingSignaturesBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetLatestNonVotingSignaturesBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetLatestNonVotingSignaturesBody,
            ) -> types::builder::PostGetLatestNonVotingSignaturesBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getLatestNonVotingSignatures`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetLatestNonVotingSignaturesResponse>,
            Error<types::PostGetLatestNonVotingSignaturesResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetLatestNonVotingSignaturesBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getLatestNonVotingSignatures", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_latest_non_voting_signatures",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_multiple_account_interfaces`]

[`Client::post_get_multiple_account_interfaces`]: super::Client::post_get_multiple_account_interfaces*/
    #[derive(Debug, Clone)]
    pub struct PostGetMultipleAccountInterfaces<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetMultipleAccountInterfacesBody, String>,
    }
    impl<'a> PostGetMultipleAccountInterfaces<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetMultipleAccountInterfacesBody>,
            <V as std::convert::TryInto<
                types::PostGetMultipleAccountInterfacesBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetMultipleAccountInterfacesBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetMultipleAccountInterfacesBody,
            ) -> types::builder::PostGetMultipleAccountInterfacesBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getMultipleAccountInterfaces`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetMultipleAccountInterfacesResponse>,
            Error<types::PostGetMultipleAccountInterfacesResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetMultipleAccountInterfacesBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getMultipleAccountInterfaces", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_multiple_account_interfaces",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_multiple_compressed_account_proofs`]

[`Client::post_get_multiple_compressed_account_proofs`]: super::Client::post_get_multiple_compressed_account_proofs*/
    #[derive(Debug, Clone)]
    pub struct PostGetMultipleCompressedAccountProofs<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetMultipleCompressedAccountProofsBody, String>,
    }
    impl<'a> PostGetMultipleCompressedAccountProofs<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetMultipleCompressedAccountProofsBody>,
            <V as std::convert::TryInto<
                types::PostGetMultipleCompressedAccountProofsBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetMultipleCompressedAccountProofsBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetMultipleCompressedAccountProofsBody,
            ) -> types::builder::PostGetMultipleCompressedAccountProofsBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getMultipleCompressedAccountProofs`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetMultipleCompressedAccountProofsResponse>,
            Error<types::PostGetMultipleCompressedAccountProofsResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetMultipleCompressedAccountProofsBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getMultipleCompressedAccountProofs", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_multiple_compressed_account_proofs",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_multiple_compressed_account_proofs_v2`]

[`Client::post_get_multiple_compressed_account_proofs_v2`]: super::Client::post_get_multiple_compressed_account_proofs_v2*/
    #[derive(Debug, Clone)]
    pub struct PostGetMultipleCompressedAccountProofsV2<'a> {
        client: &'a super::Client,
        body: Result<
            types::builder::PostGetMultipleCompressedAccountProofsV2Body,
            String,
        >,
    }
    impl<'a> PostGetMultipleCompressedAccountProofsV2<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<
                types::PostGetMultipleCompressedAccountProofsV2Body,
            >,
            <V as std::convert::TryInto<
                types::PostGetMultipleCompressedAccountProofsV2Body,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetMultipleCompressedAccountProofsV2Body` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetMultipleCompressedAccountProofsV2Body,
            ) -> types::builder::PostGetMultipleCompressedAccountProofsV2Body,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getMultipleCompressedAccountProofsV2`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetMultipleCompressedAccountProofsV2Response>,
            Error<types::PostGetMultipleCompressedAccountProofsV2Response>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetMultipleCompressedAccountProofsV2Body::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/getMultipleCompressedAccountProofsV2", client.baseurl,
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_multiple_compressed_account_proofs_v2",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_multiple_compressed_accounts`]

[`Client::post_get_multiple_compressed_accounts`]: super::Client::post_get_multiple_compressed_accounts*/
    #[derive(Debug, Clone)]
    pub struct PostGetMultipleCompressedAccounts<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetMultipleCompressedAccountsBody, String>,
    }
    impl<'a> PostGetMultipleCompressedAccounts<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetMultipleCompressedAccountsBody>,
            <V as std::convert::TryInto<
                types::PostGetMultipleCompressedAccountsBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetMultipleCompressedAccountsBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetMultipleCompressedAccountsBody,
            ) -> types::builder::PostGetMultipleCompressedAccountsBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getMultipleCompressedAccounts`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetMultipleCompressedAccountsResponse>,
            Error<types::PostGetMultipleCompressedAccountsResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetMultipleCompressedAccountsBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getMultipleCompressedAccounts", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_multiple_compressed_accounts",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_multiple_compressed_accounts_v2`]

[`Client::post_get_multiple_compressed_accounts_v2`]: super::Client::post_get_multiple_compressed_accounts_v2*/
    #[derive(Debug, Clone)]
    pub struct PostGetMultipleCompressedAccountsV2<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetMultipleCompressedAccountsV2Body, String>,
    }
    impl<'a> PostGetMultipleCompressedAccountsV2<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetMultipleCompressedAccountsV2Body>,
            <V as std::convert::TryInto<
                types::PostGetMultipleCompressedAccountsV2Body,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetMultipleCompressedAccountsV2Body` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetMultipleCompressedAccountsV2Body,
            ) -> types::builder::PostGetMultipleCompressedAccountsV2Body,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getMultipleCompressedAccountsV2`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetMultipleCompressedAccountsV2Response>,
            Error<types::PostGetMultipleCompressedAccountsV2Response>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetMultipleCompressedAccountsV2Body::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getMultipleCompressedAccountsV2", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_multiple_compressed_accounts_v2",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_multiple_new_address_proofs`]

[`Client::post_get_multiple_new_address_proofs`]: super::Client::post_get_multiple_new_address_proofs*/
    #[derive(Debug, Clone)]
    pub struct PostGetMultipleNewAddressProofs<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetMultipleNewAddressProofsBody, String>,
    }
    impl<'a> PostGetMultipleNewAddressProofs<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetMultipleNewAddressProofsBody>,
            <V as std::convert::TryInto<
                types::PostGetMultipleNewAddressProofsBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetMultipleNewAddressProofsBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetMultipleNewAddressProofsBody,
            ) -> types::builder::PostGetMultipleNewAddressProofsBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getMultipleNewAddressProofs`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetMultipleNewAddressProofsResponse>,
            Error<types::PostGetMultipleNewAddressProofsResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetMultipleNewAddressProofsBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getMultipleNewAddressProofs", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_multiple_new_address_proofs",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_multiple_new_address_proofs_v2`]

[`Client::post_get_multiple_new_address_proofs_v2`]: super::Client::post_get_multiple_new_address_proofs_v2*/
    #[derive(Debug, Clone)]
    pub struct PostGetMultipleNewAddressProofsV2<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetMultipleNewAddressProofsV2Body, String>,
    }
    impl<'a> PostGetMultipleNewAddressProofsV2<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetMultipleNewAddressProofsV2Body>,
            <V as std::convert::TryInto<
                types::PostGetMultipleNewAddressProofsV2Body,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetMultipleNewAddressProofsV2Body` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetMultipleNewAddressProofsV2Body,
            ) -> types::builder::PostGetMultipleNewAddressProofsV2Body,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getMultipleNewAddressProofsV2`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetMultipleNewAddressProofsV2Response>,
            Error<types::PostGetMultipleNewAddressProofsV2Response>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetMultipleNewAddressProofsV2Body::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getMultipleNewAddressProofsV2", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_multiple_new_address_proofs_v2",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_queue_elements`]

[`Client::post_get_queue_elements`]: super::Client::post_get_queue_elements*/
    #[derive(Debug, Clone)]
    pub struct PostGetQueueElements<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetQueueElementsBody, String>,
    }
    impl<'a> PostGetQueueElements<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetQueueElementsBody>,
            <V as std::convert::TryInto<
                types::PostGetQueueElementsBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetQueueElementsBody` for body failed: {}", s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetQueueElementsBody,
            ) -> types::builder::PostGetQueueElementsBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getQueueElements`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetQueueElementsResponse>,
            Error<types::PostGetQueueElementsResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetQueueElementsBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getQueueElements", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_queue_elements",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_queue_info`]

[`Client::post_get_queue_info`]: super::Client::post_get_queue_info*/
    #[derive(Debug, Clone)]
    pub struct PostGetQueueInfo<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetQueueInfoBody, String>,
    }
    impl<'a> PostGetQueueInfo<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetQueueInfoBody>,
            <V as std::convert::TryInto<
                types::PostGetQueueInfoBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetQueueInfoBody` for body failed: {}", s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetQueueInfoBody,
            ) -> types::builder::PostGetQueueInfoBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getQueueInfo`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetQueueInfoResponse>,
            Error<types::PostGetQueueInfoResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetQueueInfoBody::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getQueueInfo", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_queue_info",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_transaction_with_compression_info`]

[`Client::post_get_transaction_with_compression_info`]: super::Client::post_get_transaction_with_compression_info*/
    #[derive(Debug, Clone)]
    pub struct PostGetTransactionWithCompressionInfo<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetTransactionWithCompressionInfoBody, String>,
    }
    impl<'a> PostGetTransactionWithCompressionInfo<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetTransactionWithCompressionInfoBody>,
            <V as std::convert::TryInto<
                types::PostGetTransactionWithCompressionInfoBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetTransactionWithCompressionInfoBody` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetTransactionWithCompressionInfoBody,
            ) -> types::builder::PostGetTransactionWithCompressionInfoBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getTransactionWithCompressionInfo`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetTransactionWithCompressionInfoResponse>,
            Error<types::PostGetTransactionWithCompressionInfoResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetTransactionWithCompressionInfoBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getTransactionWithCompressionInfo", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_transaction_with_compression_info",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_transaction_with_compression_info_v2`]

[`Client::post_get_transaction_with_compression_info_v2`]: super::Client::post_get_transaction_with_compression_info_v2*/
    #[derive(Debug, Clone)]
    pub struct PostGetTransactionWithCompressionInfoV2<'a> {
        client: &'a super::Client,
        body: Result<
            types::builder::PostGetTransactionWithCompressionInfoV2Body,
            String,
        >,
    }
    impl<'a> PostGetTransactionWithCompressionInfoV2<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetTransactionWithCompressionInfoV2Body>,
            <V as std::convert::TryInto<
                types::PostGetTransactionWithCompressionInfoV2Body,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetTransactionWithCompressionInfoV2Body` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetTransactionWithCompressionInfoV2Body,
            ) -> types::builder::PostGetTransactionWithCompressionInfoV2Body,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getTransactionWithCompressionInfoV2`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetTransactionWithCompressionInfoV2Response>,
            Error<types::PostGetTransactionWithCompressionInfoV2Response>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetTransactionWithCompressionInfoV2Body::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getTransactionWithCompressionInfoV2", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_transaction_with_compression_info_v2",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_validity_proof`]

[`Client::post_get_validity_proof`]: super::Client::post_get_validity_proof*/
    #[derive(Debug, Clone)]
    pub struct PostGetValidityProof<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetValidityProofBody, String>,
    }
    impl<'a> PostGetValidityProof<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetValidityProofBody>,
            <V as std::convert::TryInto<
                types::PostGetValidityProofBody,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetValidityProofBody` for body failed: {}", s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetValidityProofBody,
            ) -> types::builder::PostGetValidityProofBody,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getValidityProof`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetValidityProofResponse>,
            Error<types::PostGetValidityProofResponse>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetValidityProofBody::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getValidityProof", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_validity_proof",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::post_get_validity_proof_v2`]

[`Client::post_get_validity_proof_v2`]: super::Client::post_get_validity_proof_v2*/
    #[derive(Debug, Clone)]
    pub struct PostGetValidityProofV2<'a> {
        client: &'a super::Client,
        body: Result<types::builder::PostGetValidityProofV2Body, String>,
    }
    impl<'a> PostGetValidityProofV2<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PostGetValidityProofV2Body>,
            <V as std::convert::TryInto<
                types::PostGetValidityProofV2Body,
            >>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| {
                    format!(
                        "conversion to `PostGetValidityProofV2Body` for body failed: {}",
                        s
                    )
                });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::PostGetValidityProofV2Body,
            ) -> types::builder::PostGetValidityProofV2Body,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/getValidityProofV2`
        pub async fn send(
            self,
        ) -> Result<
            ResponseValue<types::PostGetValidityProofV2Response>,
            Error<types::PostGetValidityProofV2Response>,
        > {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::PostGetValidityProofV2Body::try_from(v)
                        .map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/getValidityProofV2", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map
                .append(
                    ::reqwest::header::HeaderName::from_static("api-version"),
                    ::reqwest::header::HeaderValue::from_static(
                        super::Client::api_version(),
                    ),
                );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "post_get_validity_proof_v2",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                429u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                500u16 => {
                    Err(
                        Error::ErrorResponse(
                            ResponseValue::from_response(response).await?,
                        ),
                    )
                }
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
}
/// Items consumers will typically use such as the Client.
pub mod prelude {
    pub use self::super::Client;
}
