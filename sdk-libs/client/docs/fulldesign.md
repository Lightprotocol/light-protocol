# Compression-Aware AMM Integration: Full Design

## Executive Summary

This document specifies how DEX aggregators (Jupiter, DFlow) integrate with compression-enabled AMMs. The design is **non-breaking** - existing AMMs work unchanged, compressible AMMs opt-in via extension trait.

---

## Part 1: Trait Design

### 1.1 Jupiter's Amm Trait (Unchanged)

```rust
pub trait Amm {
    fn from_keyed_account(keyed_account: &KeyedAccount, ctx: &AmmContext) -> Result<Self>;
    fn label(&self) -> String;
    fn program_id(&self) -> Pubkey;
    fn key(&self) -> Pubkey;
    fn get_reserve_mints(&self) -> Vec<Pubkey>;
    fn get_accounts_to_update(&self) -> Vec<Pubkey>;           // UNCHANGED
    fn update(&mut self, account_map: &AccountMap) -> Result<()>;
    fn quote(&self, params: &QuoteParams) -> Result<Quote>;
    fn get_swap_and_account_metas(&self, params: &SwapParams) -> Result<SwapAndAccountMetas>;
    fn clone_amm(&self) -> Box<dyn Amm + Send + Sync>;
}
```

### 1.2 CompressibleAmm Extension Trait (New)

```rust
/// Extension trait for AMMs supporting rent-free (compressible) accounts.
/// Implemented IN ADDITION TO the standard Amm trait.
pub trait CompressibleAmm: Amm {
    /// The typed variant enum generated by #[light_program] macro.
    /// Contains parsed account data + seed values for PDA verification.
    type Variant: Pack + Clone + Debug;
    
    /// Returns the SUBSET of accounts that could be cold.
    /// This is a subset of get_accounts_to_update().
    /// Aggregator uses this to decide which closures need Photon queries.
    fn get_compressible_accounts(&self) -> Vec<Pubkey>;
    
    /// Update from AccountInterface slice (works uniformly for hot/cold).
    /// For cold accounts, converts to ColdAccountSpec and stores internally.
    fn update_with_interfaces(&mut self, accounts: &[AccountInterface]) -> Result<()>;
    
    /// Get lean specs for cold accounts only (for load instruction building).
    /// Returns ColdAccountSpec which has NO redundant Account data.
    fn get_cold_specs(&self) -> Vec<ColdAccountSpec<Self::Variant>>;
    
    /// Check if any currently cached accounts are cold.
    fn has_cold_accounts(&self) -> bool;
}
```

**Key distinction:**

```
get_accounts_to_update()      → ALL accounts AMM needs (from Amm trait)
get_compressible_accounts()   → SUBSET that could be cold (from CompressibleAmm)

Example for a pool:
  get_accounts_to_update():      [pool_state, vault_0, vault_1, observation, 
                                  lp_mint, amm_config, token_program]
  
  get_compressible_accounts():   [pool_state, vault_0, vault_1, observation, lp_mint]
                                  ↑ only these can go cold
```

### 1.3 Core Types

```rust
/// Lean cold account spec - NO redundancy.
/// Does NOT store Account struct (which would duplicate data from compressed).
pub enum ColdAccountSpec<V> {
    /// Program-owned PDA - needs Variant for pack()
    Pda {
        key: Pubkey,
        compressed: CompressedAccount,  // hash, tree_info, data
        variant: V,                     // parsed data + seeds
        program_id: Pubkey,
    },
    /// Program-owned token account (vault)
    Token {
        key: Pubkey,
        compressed: CompressedTokenAccount,  // has .token with mint, owner, amount
    },
    /// Compressed mint
    Mint {
        key: Pubkey,
        compressed: CompressedAccount,  // parse mint from .data on demand
    },
}

/// What's in CompressedAccount (from indexer):
/// - hash: [u8; 32]          - for proof fetching
/// - tree_info: TreeInfo     - Merkle tree pubkey, queue
/// - leaf_index: u32         - position in tree
/// - data: CompressedData    - discriminator + raw bytes
/// - lamports: u64           - for account recreation
/// - owner: Pubkey           - for account recreation

/// What's in CompressedTokenAccount:
/// - account: CompressedAccount  - underlying compressed account
/// - token: TokenData            - mint, owner, amount, delegate, state

/// Unified account interface - for FETCHING (hot or cold).
/// Used by Photon API, passed to update_with_interfaces().
pub struct AccountInterface {
    pub key: Pubkey,
    pub account: Account,           // Synthetic for cold (for .data() uniformity)
    pub cold: Option<ColdContext>,  // Present when cold
}

/// Cold context - bridges AccountInterface to ColdAccountSpec.
pub enum ColdContext {
    Account(CompressedAccount),      // For PDAs and mints
    Token(CompressedTokenAccount),   // For token accounts
}
```

**Why ColdAccountSpec is lean:**

| Current AccountSpec | Lean ColdAccountSpec |
|---------------------|----------------------|
| Embeds `Account` struct | No `Account` struct |
| `Account.data` duplicates `CompressedAccount.data` | Single source of truth |
| ~200+ bytes overhead per cold account | Minimal overhead |

**Field usage in load instructions:**

| Field | Used For |
|-------|----------|
| `key` | Hot account address (recreation target) |
| `compressed.hash` | Proof fetching from indexer |
| `compressed.tree_info` | Merkle tree accounts in instruction |
| `variant` (PDA only) | `pack()` serializes data + seeds |
| `program_id` (PDA only) | CPI target for decompression |

### 1.4 Converters: AccountInterface → ColdAccountSpec

```rust
impl<V> ColdAccountSpec<V> {
    /// Convert AccountInterface to ColdAccountSpec::Pda
    /// Requires variant construction (SDK-specific).
    pub fn from_pda_interface(
        interface: &AccountInterface,
        variant: V,
        program_id: Pubkey,
    ) -> Option<Self> {
        let compressed = interface.as_compressed_account()?.clone();
        Some(Self::Pda {
            key: interface.key,
            compressed,
            variant,
            program_id,
        })
    }
    
    /// Convert AccountInterface to ColdAccountSpec::Token
    pub fn from_token_interface(interface: &AccountInterface) -> Option<Self> {
        let compressed = interface.as_compressed_token()?.clone();
        Some(Self::Token {
            key: interface.key,
            compressed,
        })
    }
    
    /// Convert AccountInterface to ColdAccountSpec::Mint
    pub fn from_mint_interface(interface: &AccountInterface) -> Option<Self> {
        let compressed = interface.as_compressed_account()?.clone();
        Some(Self::Mint {
            key: interface.key,
            compressed,
        })
    }
}

impl<V> ColdAccountSpec<V> {
    pub fn key(&self) -> Pubkey {
        match self {
            Self::Pda { key, .. } => *key,
            Self::Token { key, .. } => *key,
            Self::Mint { key, .. } => *key,
        }
    }
    
    pub fn hash(&self) -> [u8; 32] {
        match self {
            Self::Pda { compressed, .. } => compressed.hash,
            Self::Token { compressed, .. } => compressed.account.hash,
            Self::Mint { compressed, .. } => compressed.hash,
        }
    }
}
```

### 1.5 What's NOT in the Trait

```rust
// NOT NEEDED - Photon determines account type from pubkey
fn get_account_fetch_hints(&self) -> Vec<AccountToFetch>;
```

### 1.6 Method Summary

| Method | Source | Purpose |
|--------|--------|---------|
| `get_accounts_to_update()` | `Amm` trait | ALL accounts AMM needs (for streaming) |
| `get_compressible_accounts()` | `CompressibleAmm` | SUBSET that could be cold (for Photon queries) |
| `update()` | `Amm` trait | Update from hot accounts (stream) |
| `update_with_interfaces()` | `CompressibleAmm` | Update from Photon (hot or cold) |
| `get_cold_specs()` | `CompressibleAmm` | Get cold accounts for load instructions |
| `has_cold_accounts()` | `CompressibleAmm` | Check if any accounts are cold |

---

## Part 2: SDK Internal Storage

### 2.1 Regular AMM SDK (Baseline)

```rust
struct RegularAmmSdk {
    // Parsed scalars only - no raw Account storage
    pool_key: Pubkey,
    reserve_0: u64,
    reserve_1: u64,
    token_0_mint: Pubkey,
    token_1_mint: Pubkey,
    // ... other parsed state
}
```

### 2.1.1 Important: `update()` Must Clear Stale Cold Specs

The regular `Amm::update()` method (from stream) must also handle decompression:

```rust
impl Amm for CompressibleAmmSdk {
    fn update(&mut self, account_map: &AccountMap) -> Result<()> {
        for (pubkey, account) in account_map {
            // Update scalars
            self.parse_and_update_scalars(pubkey, &account.data)?;
            
            // IMPORTANT: Remove cold spec if account is now hot
            // (this handles decompression - account came back on-chain)
            self.cold_specs.remove(pubkey);
        }
        Ok(())
    }
}
```

This ensures that when an account is decompressed (appears on-chain again), the stale cold spec is removed.

### 2.2 Compressible AMM SDK

```rust
struct CompressibleAmmSdk {
    // Same parsed scalars (for quoting)
    pool_key: Pubkey,
    reserve_0: u64,
    reserve_1: u64,
    token_0_mint: Pubkey,
    token_1_mint: Pubkey,
    
    // ONLY for cold accounts - unified, lean storage
    // ColdAccountSpec has NO redundant Account data
    cold_specs: HashMap<Pubkey, ColdAccountSpec<LightAccountVariant>>,
}

impl CompressibleAmm for CompressibleAmmSdk {
    fn update_with_interfaces(&mut self, accounts: &[AccountInterface]) -> Result<()> {
        for interface in accounts {
            // Always update scalars (for quoting)
            self.parse_and_update_scalars(&interface.key, interface.data())?;
            
            if interface.is_cold() {
                // Convert to lean ColdAccountSpec and store
                let spec = self.build_cold_spec(interface)?;
                self.cold_specs.insert(interface.key, spec);
            } else {
                // Hot - remove any stale cold spec (decompression case)
                self.cold_specs.remove(&interface.key);
            }
        }
        Ok(())
    }
    
    fn get_cold_specs(&self) -> Vec<ColdAccountSpec<Self::Variant>> {
        self.cold_specs.values().cloned().collect()
    }
    
    fn has_cold_accounts(&self) -> bool {
        !self.cold_specs.is_empty()
    }
}
```

### 2.3 Storage Comparison

| Account State | Regular SDK | Compressible SDK |
|---------------|-------------|------------------|
| Hot           | scalars     | scalars (same)   |
| Cold          | N/A         | scalars + ColdAccountSpec |

**Zero redundancy for hot accounts** - identical to regular SDK.

**Minimal storage for cold accounts:**
- `ColdAccountSpec` - lean enum, NO Account struct
- Contains only: `CompressedAccount`/`CompressedTokenAccount` + Variant (for PDAs)
- Scalars still stored separately for fast quoting

---

## Part 3: Aggregator Integration

### 3.1 What Aggregator Must Adapt

| Component | Change Required |
|-----------|-----------------|
| AMM registry | Add `is_compressible` flag per program |
| Account fetching | Add Photon client for cold queries |
| Update path | Branch: `update()` vs `update_with_interfaces()` |
| Swap building | Prepend load instructions when cold |
| Event detection | Detect compression events (see 3.4) |

### 3.2 New Dependencies

```rust
// Aggregator adds:
use light_client::{
    AccountInterface,
    ColdSpec,
    CompressibleAmm,
    create_load_instructions,
};
use photon_client::PhotonClient;  // or equivalent indexer client
```

### 3.3 Aggregator Pseudocode

```rust
// Initialization
let photon = PhotonClient::new(photon_url);
let compressible_programs: HashSet<Pubkey> = load_registry();

// Main routing function
async fn route_swap(amm: &mut dyn Amm, params: SwapParams) -> Result<Transaction> {
    let mut instructions = Vec::new();
    let pubkeys = amm.get_accounts_to_update();
    
    if is_compressible(amm.program_id()) {
        // COMPRESSIBLE PATH
        let interfaces = photon.get_account_interfaces(&pubkeys).await?;
        as_compressible(amm).update_with_interfaces(&interfaces)?;
        
        if as_compressible(amm).has_cold_accounts() {
            let cold_specs = as_compressible(amm).get_cold_specs();
            let load_ixs = create_load_instructions(&cold_specs, payer, config).await?;
            instructions.extend(load_ixs);
        }
    } else {
        // REGULAR PATH (unchanged)
        let accounts = rpc.get_multiple_accounts(&pubkeys).await?;
        amm.update(&accounts)?;
    }
    
    // Quote and swap (same for both)
    let swap = amm.get_swap_and_account_metas(&params)?;
    instructions.push(build_swap_ix(swap));
    
    Ok(build_transaction(instructions))
}
```

### 3.4 Detecting Cold Accounts

**Question: How does aggregator know when an account goes cold?**

#### Option A: Account Closure Detection (Recommended)

```
STREAM EVENT: account_update(pubkey, account)
│
├─ account exists && lamports > 0
│   └─ HOT - use directly via update(AccountMap)
│
└─ account missing OR lamports == 0
    │
    ├─ is_compressible_program(program_id)?
    │   │
    │   ├─ YES → is pubkey in get_compressible_accounts()?
    │   │        │
    │   │        ├─ YES → query Photon
    │   │        │        │
    │   │        │        ├─ Photon returns cold data → COMPRESSED
    │   │        │        │   └─ call update_with_interfaces([interface])
    │   │        │        │
    │   │        │        └─ Photon returns nothing → ACTUALLY DELETED
    │   │        │            └─ remove from cache
    │   │        │
    │   │        └─ NO → non-compressible account closed (e.g., amm_config)
    │   │             └─ handle as regular deletion
    │   │
    │   └─ NO → regular AMM, account just closed
    │
    └─ END
```

**Key optimization:** Don't query Photon for accounts that can't be cold.

```rust
// Aggregator caches the compressible set per AMM
let compressible_set: HashSet<Pubkey> = amm.get_compressible_accounts().into_iter().collect();

// On closure
if compressible_set.contains(&pubkey) {
    // This account COULD be cold - query Photon
    let interface = photon.get_account_interface(&pubkey).await?;
    amm.update_with_interfaces(&[interface])?;
} else {
    // Not compressible - regular deletion
}
```

**Why closure works:**
- Compression = account closed on-chain + data moved to Merkle tree
- Stream sees closure as `lamports = 0` or account disappearing
- Photon query distinguishes "compressed" from "actually deleted"

#### Option B: Watch Compression Transactions

```rust
// Subscribe to compress/decompress transactions
stream.subscribe_logs(|log| {
    if log.contains("Compress") || log.contains("Decompress") {
        let affected_accounts = parse_affected_accounts(log);
        for pubkey in affected_accounts {
            refresh_from_photon(pubkey);
        }
    }
});
```

**Pros:** More explicit, catches compression before next quote request
**Cons:** Requires log parsing, more complex

#### Option C: Periodic Photon Polling

```rust
// Every N seconds, refresh compressible AMM accounts
for amm in compressible_amms {
    let interfaces = photon.get_account_interfaces(amm.get_accounts_to_update()).await?;
    amm.update_with_interfaces(&interfaces)?;
}
```

**Pros:** Simple, catches everything
**Cons:** Wasteful, adds latency

#### Recommendation: Option A + Optional B

- **Primary:** Detect via account closure in stream
- **Optional:** Also watch compress transactions for faster detection
- **Fallback:** Photon query always gives definitive answer

---

## Part 4: Visual Diagrams

### 4.1 High-Level Architecture

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              AGGREGATOR (Jupiter/DFlow)                          │
└─────────────────────────────────────────────────────────────────────────────────┘
        │                                              │
        │ Regular AMMs                                 │ Compressible AMMs
        │                                              │
        ▼                                              ▼
┌─────────────────────┐                    ┌─────────────────────────────────────┐
│  LaserStream/RPC    │                    │  LaserStream + Photon Fallback      │
│                     │                    │                                     │
│  getMultipleAccounts│                    │  Stream → if missing → Photon      │
│  → Account[]        │                    │  → AccountInterface[]               │
└─────────────────────┘                    └─────────────────────────────────────┘
        │                                              │
        ▼                                              ▼
┌─────────────────────┐                    ┌─────────────────────────────────────┐
│  amm.update(        │                    │  amm.update_with_interfaces(        │
│    AccountMap)      │                    │    &[AccountInterface])             │
└─────────────────────┘                    └─────────────────────────────────────┘
        │                                              │
        │                                              │ if has_cold_accounts()
        │                                              ▼
        │                                  ┌─────────────────────────────────────┐
        │                                  │  create_load_instructions(          │
        │                                  │    cold_specs, payer, config)       │
        │                                  │  → Vec<Instruction>                 │
        │                                  └─────────────────────────────────────┘
        │                                              │
        ▼                                              ▼
┌─────────────────────────────────────────────────────────────────────────────────┐
│                                  TRANSACTION                                     │
│                                                                                  │
│  Regular:    [swap_ix]                                                           │
│  Compressed: [load_ix_1, load_ix_2, ..., swap_ix]                               │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 Account State Flow

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           ACCOUNT LIFECYCLE                                      │
└─────────────────────────────────────────────────────────────────────────────────┘

                              ┌──────────────┐
                              │   CREATED    │
                              │  (on-chain)  │
                              └──────┬───────┘
                                     │
                    ┌────────────────┼────────────────┐
                    ▼                │                ▼
           ┌──────────────┐         │       ┌──────────────┐
           │     HOT      │◄────────┴──────►│     COLD     │
           │  (on-chain)  │   compress/     │ (compressed) │
           │              │   decompress    │              │
           └──────────────┘                 └──────────────┘
                    │                                │
                    │                                │
                    ▼                                ▼
           ┌──────────────┐                 ┌──────────────┐
           │   STREAM     │                 │   PHOTON     │
           │   delivers   │                 │   delivers   │
           │   Account    │                 │   Account-   │
           │              │                 │   Interface  │
           └──────────────┘                 └──────────────┘
                    │                                │
                    └────────────┬───────────────────┘
                                 ▼
                        ┌──────────────┐
                        │  SDK parses  │
                        │  same way    │
                        │  (.data())   │
                        └──────────────┘
```

### 4.3 Cold Detection Flow

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                        COLD ACCOUNT DETECTION                                    │
└─────────────────────────────────────────────────────────────────────────────────┘

    STREAM: account_update(pool_vault_0, account)
                              │
                              ▼
              ┌───────────────────────────────┐
              │  account.lamports > 0 ?       │
              └───────────────────────────────┘
                    │                 │
                   YES               NO (closed/missing)
                    │                 │
                    ▼                 ▼
              ┌──────────┐    ┌───────────────────────┐
              │   HOT    │    │  is_compressible(     │
              │  update  │    │    program_id)?       │
              │  cache   │    └───────────────────────┘
              └──────────┘           │           │
                                    YES         NO
                                     │           │
                                     ▼           ▼
                           ┌──────────────┐  ┌──────────┐
                           │ Query Photon │  │ Regular  │
                           │ (pubkey)     │  │ deletion │
                           └──────────────┘  └──────────┘
                                     │
                     ┌───────────────┴───────────────┐
                     ▼                               ▼
            ┌──────────────────┐           ┌──────────────────┐
            │ Photon returns   │           │ Photon returns   │
            │ AccountInterface │           │ nothing          │
            │ with ColdContext │           │                  │
            └──────────────────┘           └──────────────────┘
                     │                               │
                     ▼                               ▼
            ┌──────────────────┐           ┌──────────────────┐
            │ COMPRESSED       │           │ ACTUALLY DELETED │
            │ Cache interface  │           │ Remove from cache│
            │ SDK stores       │           │ Pool may be      │
            │ ColdSpec         │           │ invalid          │
            └──────────────────┘           └──────────────────┘
```

### 4.4 SDK Internal Flow

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                     SDK: update_with_interfaces()                                │
└─────────────────────────────────────────────────────────────────────────────────┘

    for interface in interfaces:
                │
                ▼
        ┌───────────────────┐
        │ Parse account     │
        │ data = interface  │
        │   .data()         │
        └───────────────────┘
                │
                ▼
        ┌───────────────────┐
        │ Update scalars    │  reserve_0, reserve_1, etc.
        │ (for quoting)     │  SAME FOR HOT AND COLD
        └───────────────────┘
                │
                ▼
        ┌───────────────────┐
        │ interface.is_     │
        │   cold()?         │
        └───────────────────┘
              │         │
             YES       NO
              │         │
              ▼         ▼
    ┌──────────────┐  ┌──────────────┐
    │ Convert to   │  │ Remove stale │
    │ lean spec:   │  │ cold spec    │
    │              │  │ (hot now)    │
    │ ColdAccount- │  └──────────────┘
    │ Spec::from_  │
    │ *_interface()│
    │              │
    │ Store in     │
    │ cold_specs   │
    │ HashMap      │
    └──────────────┘
```

### 4.4.1 AccountInterface → ColdAccountSpec Conversion

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                     TYPE CONVERSION FLOW                                         │
└─────────────────────────────────────────────────────────────────────────────────┘

    AccountInterface (from Photon)
    ├─ key: Pubkey
    ├─ account: Account          ← DISCARDED (redundant for cold)
    └─ cold: Option<ColdContext> ← EXTRACTED
                │
                ▼
    ┌───────────────────────────────────────────────────────────────┐
    │  SDK determines account type (knows its own accounts)         │
    └───────────────────────────────────────────────────────────────┘
                │
      ┌─────────┼─────────┬─────────────┐
      ▼         ▼         ▼             │
    ┌─────┐  ┌─────┐  ┌─────┐          │
    │ PDA │  │Token│  │Mint │          │
    └─────┘  └─────┘  └─────┘          │
      │         │         │             │
      ▼         ▼         ▼             │
    ┌─────────────────────────────────────────────────────────────┐
    │ ColdAccountSpec::Pda {                                       │
    │   key: interface.key,                                        │
    │   compressed: interface.cold.as_account().clone(),           │
    │   variant: build_variant(interface.data()),  ← SDK builds   │
    │   program_id,                                                │
    │ }                                                            │
    ├─────────────────────────────────────────────────────────────┤
    │ ColdAccountSpec::Token {                                     │
    │   key: interface.key,                                        │
    │   compressed: interface.cold.as_token().clone(),             │
    │ }                                                            │
    ├─────────────────────────────────────────────────────────────┤
    │ ColdAccountSpec::Mint {                                      │
    │   key: interface.key,                                        │
    │   compressed: interface.cold.as_account().clone(),           │
    │ }                                                            │
    └─────────────────────────────────────────────────────────────┘
    
    Result: Lean storage, NO Account struct, NO redundant data
```

### 4.5 Load Instruction Building

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                    create_load_instructions()                                    │
└─────────────────────────────────────────────────────────────────────────────────┘

    Input: Vec<ColdAccountSpec<V>>
                │
                ▼
    ┌───────────────────────────────────────┐
    │ Collect hashes from each spec:       │
    │                                       │
    │   Pda   → compressed.hash            │
    │   Token → compressed.account.hash    │
    │   Mint  → compressed.hash            │
    └───────────────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────────────┐
    │ Fetch validity proofs from indexer   │
    │                                       │
    │   proofs = indexer.get_validity_     │
    │     proof(hashes)                     │
    └───────────────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────────────┐
    │ Build instruction per spec type:     │
    │                                       │
    │   Pda:                               │
    │     packed_data = variant.pack()     │
    │     build_decompress_pda_ix(...)     │
    │                                       │
    │   Token:                             │
    │     build_transfer2_ix(              │
    │       compressed.token, ...)         │
    │                                       │
    │   Mint:                              │
    │     mint_data = parse(compressed)    │
    │     build_decompress_mint_ix(...)    │
    └───────────────────────────────────────┘
                │
                ▼
    Output: Vec<Instruction>
```

---

## Part 5: The Diff

### 5.1 Regular AMM vs Compressible AMM

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                              THE DIFF                                             │
└──────────────────────────────────────────────────────────────────────────────────┘

REGULAR AMM                          COMPRESSIBLE AMM
───────────                          ─────────────────

Trait:                               Trait:
  impl Amm                             impl Amm              (same)
                                       impl CompressibleAmm  (NEW)

Fetching:                            Fetching:
  RPC only                             RPC for hot
                                       Photon for cold/missing  (NEW)

Update:                              Update:
  update(AccountMap)                   update_with_interfaces(  (NEW)
                                         &[AccountInterface])

Storage:                             Storage:
  Scalars only                         Scalars (same)
                                       + ColdSpec for cold only (NEW)

Quote:                               Quote:
  From scalars                         From scalars (SAME)

Swap:                                Swap:
  [swap_ix]                            [load_ixs..., swap_ix]  (NEW prefix)
```

### 5.2 Aggregator Changes Summary

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                         AGGREGATOR CHANGES                                        │
└──────────────────────────────────────────────────────────────────────────────────┘

BEFORE                                AFTER
──────                                ─────

1. REGISTRY
   program_id → AmmFactory            program_id → AmmFactory
                                               + is_compressible flag

2. FETCHING
   RPC.getMultipleAccounts            if compressible && missing:
                                        Photon.getAccountInterfaces

3. UPDATE CALL
   amm.update(account_map)            if compressible:
                                        amm.update_with_interfaces(interfaces)
                                      else:
                                        amm.update(account_map)

4. SWAP BUILDING
   [swap_ix]                          if has_cold_accounts():
                                        [load_ixs..., swap_ix]
                                      else:
                                        [swap_ix]

5. EVENT HANDLING
   (none)                             on account_closure:
                                        if compressible: query Photon
```

---

## Part 6: Open Questions & Recommendations

### 6.1 Is Account Closure the Best Detection Method?

**Analysis:**

| Method | Pros | Cons |
|--------|------|------|
| Account closure | Simple, uses existing stream | Ambiguous until Photon query |
| Compress tx logs | Explicit, immediate | Requires log parsing, more complex |
| Periodic polling | Simple | Wasteful, adds latency |
| Photon streaming | Ideal, real-time | May not exist yet |

**Recommendation:** Account closure + immediate Photon query.

**Critical insight:** Closure alone is ambiguous, but **Photon resolves it instantly**.

```
STREAM: account closed
    │
    ├─ Non-compressible program → actually deleted (ignore)
    │
    └─ Compressible program → IMMEDIATELY query Photon
           │
           ├─ Photon has it → COMPRESSED (cache AccountInterface)
           │
           └─ Photon doesn't have it → ACTUALLY DELETED (remove from cache)
```

**Why immediate?** Don't wait for user request. When closure detected for compressible AMM, query Photon immediately to keep cache fresh. This ensures quotes/swaps are always ready.

**Future optimization:** If Photon adds streaming support for compressed account updates, aggregator could subscribe directly.

### 6.2 What About Decompression Detection?

When a cold account gets loaded (decompressed):
- Account appears on-chain again
- Stream delivers the account normally
- SDK can just use the hot account, drop ColdSpec

**No special handling needed** - hot accounts work automatically.

### 6.3 How Does Aggregator Know Program is Compressible?

**Options:**
1. **Registry lookup** (recommended) - aggregator maintains list
2. **On-chain config** - program stores compressibility flag
3. **Trait check** - runtime downcast (requires `'static`)

**Recommendation:** Registry lookup is simplest and most flexible.

### 6.4 Transaction Size Limits

Load instructions add to transaction size. With multiple cold accounts:
- May need to split into multiple transactions
- Or use address lookup tables (ALTs)
- Or batch load instructions efficiently

**Typical sizes:**
- Load instruction per PDA: ~500-800 bytes (depends on proof size)
- Solana tx limit: 1232 bytes
- With ALTs: can fit more

**Recommendation:** SDK provides `create_load_instructions` that handles batching internally. Aggregator may need to handle multi-tx scenarios for many cold accounts.

### 6.5 Idempotency

Load instructions should be **idempotent** - safe to retry if account already loaded.

```rust
// On-chain check in decompress instruction:
if account_exists_and_matches(hot_address, expected_data) {
    return Ok(()); // Already loaded, no-op
}
```

This allows aggregator to include load instructions even if account might have been loaded by another tx in the same slot.

---

## Part 7: Implementation Checklist

### For Light Protocol (SDK Provider)

- [ ] Define `CompressibleAmm` trait with:
  - [ ] `get_compressible_accounts()` - subset that could be cold
  - [ ] `update_with_interfaces()` - update from Photon
  - [ ] `get_cold_specs()` - returns lean `ColdAccountSpec<V>`
  - [ ] `has_cold_accounts()` - check if any cold
- [ ] Define `ColdAccountSpec<V>` enum (Pda, Token, Mint) - NO redundant Account data
- [ ] Implement converter helpers: `AccountInterface` → `ColdAccountSpec`
- [ ] Implement `create_load_instructions` that takes `Vec<ColdAccountSpec<V>>`
- [ ] Ensure `Variant.pack()` is correct and deterministic
- [ ] Provide reference implementation in test AMM SDK
- [ ] Document macro usage for generating `Variant` types

### For Aggregator (Jupiter/DFlow)

- [ ] Add compressibility flag to AMM registry
- [ ] Integrate Photon client
- [ ] Cache `get_compressible_accounts()` per AMM at registration
- [ ] On closure: check if pubkey is in compressible set before querying Photon
- [ ] Hot accounts: use `update(AccountMap)` from stream
- [ ] Cold accounts: use `update_with_interfaces()` from Photon
- [ ] Handle load instruction prepending
- [ ] Test with Light Protocol test AMM
- [ ] Monitor and iterate

---

## Appendix A: Variant Construction

The `Variant` type is generated by the `#[light_program]` macro. Understanding its structure is critical:

```rust
// Generated by macro for a pool state account
pub enum LightAccountVariant {
    PoolState {
        data: PoolState,         // The deserialized account struct
        amm_config: Pubkey,      // Seed value 1 (from data.amm_config)
        token_0_mint: Pubkey,    // Seed value 2 (from data.token_0_mint)
        token_1_mint: Pubkey,    // Seed value 3 (from data.token_1_mint)
    },
    ObservationState {
        data: ObservationState,
        pool_state: Pubkey,      // Seed value (from data.pool_state)
    },
}
```

**Key insight:** Seeds are COPIED from the account data at parse time.

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                        VARIANT CONSTRUCTION                                      │
└─────────────────────────────────────────────────────────────────────────────────┘

    AccountInterface.data() → raw bytes
            │
            ▼
    ┌───────────────────────┐
    │ Deserialize struct    │
    │                       │
    │ pool_state = PoolState│
    │   ::deserialize(      │
    │     &data[8..])       │
    └───────────────────────┘
            │
            ▼
    ┌───────────────────────┐
    │ Extract seeds from    │
    │ parsed struct fields  │
    │                       │
    │ amm_config =          │
    │   pool_state.amm_     │
    │   config              │
    │                       │
    │ token_0_mint =        │
    │   pool_state.token_   │
    │   0_mint              │
    └───────────────────────┘
            │
            ▼
    ┌───────────────────────┐
    │ Construct Variant     │
    │                       │
    │ LightAccountVariant:: │
    │   PoolState {         │
    │     data: pool_state, │
    │     amm_config,       │
    │     token_0_mint,     │
    │     token_1_mint,     │
    │   }                   │
    └───────────────────────┘
            │
            ▼
    variant.pack() serializes:
    - discriminator
    - struct data
    - seeds into remaining_accounts
```

**This is why ColdSpec needs Variant, not just raw bytes:**
- Raw bytes alone don't have explicit seed values extracted
- Variant has seeds ready for `pack()` to use
- `pack()` puts seeds into `remaining_accounts` for on-chain PDA verification

---

## Appendix B: Photon API

```rust
/// Photon indexer client interface
trait PhotonClient {
    /// Get account interface - determines type automatically from pubkey.
    /// Returns AccountInterface with ColdContext if compressed.
    async fn get_account_interface(&self, pubkey: &Pubkey) -> Result<AccountInterface>;
    
    /// Batch version
    async fn get_account_interfaces(&self, pubkeys: &[Pubkey]) -> Result<Vec<AccountInterface>>;
    
    /// Get validity proof for compressed account hashes
    async fn get_validity_proof(&self, hashes: Vec<[u8; 32]>) -> Result<ValidityProofWithContext>;
}
```

**Key property:** `get_account_interface(pubkey)` needs NO hints.
Photon determines account type (PDA/Token/ATA/Mint) internally.
API matches RPC signature - drop-in replacement.

---

## Appendix C: Complete Aggregator Example

```rust
/// Complete aggregator integration example
struct Aggregator {
    stream: LaserStream,
    rpc: RpcClient,
    photon: PhotonClient,
    amm_cache: HashMap<Pubkey, Box<dyn Amm>>,
    compressible_programs: HashSet<Pubkey>,
    // Cache of which accounts could be cold per AMM
    compressible_accounts: HashMap<Pubkey, HashSet<Pubkey>>,  // amm_key → compressible pubkeys
}

impl Aggregator {
    /// Initialize AMM and cache its compressible accounts
    fn register_amm(&mut self, amm: Box<dyn Amm>) {
        let amm_key = amm.key();
        
        // Cache compressible accounts if this is a compressible AMM
        if self.compressible_programs.contains(&amm.program_id()) {
            if let Some(compressible) = as_compressible(amm.as_ref()) {
                let set: HashSet<Pubkey> = compressible
                    .get_compressible_accounts()
                    .into_iter()
                    .collect();
                self.compressible_accounts.insert(amm_key, set);
            }
        }
        
        self.amm_cache.insert(amm_key, amm);
    }
    
    /// Main streaming loop
    async fn run(&mut self) {
        loop {
            match self.stream.next().await {
                StreamEvent::AccountUpdate { pubkey, account } => {
                    self.handle_account_update(pubkey, account).await;
                }
                StreamEvent::Slot { .. } => { /* update slot */ }
            }
        }
    }
    
    /// Handle account update from stream
    async fn handle_account_update(&mut self, pubkey: Pubkey, account: Option<Account>) {
        let affected_amms: Vec<Pubkey> = self.find_amms_watching(&pubkey);
        
        for amm_key in affected_amms {
            let amm = self.amm_cache.get_mut(&amm_key).unwrap();
            
            match account {
                Some(acc) if acc.lamports > 0 => {
                    // HOT - use regular update path
                    let map = HashMap::from([(pubkey, acc)]);
                    amm.update(&map).ok();
                }
                _ => {
                    // CLOSED - check if this specific account could be cold
                    let could_be_cold = self.compressible_accounts
                        .get(&amm_key)
                        .map(|set| set.contains(&pubkey))
                        .unwrap_or(false);
                    
                    if could_be_cold {
                        // Query Photon for this specific account
                        if let Ok(interface) = self.photon.get_account_interface(&pubkey).await {
                            if let Some(compressible) = as_compressible_mut(amm.as_mut()) {
                                compressible.update_with_interfaces(&[interface]).ok();
                            }
                        }
                    }
                    // If not compressible or Photon returns nothing → truly deleted
                }
            }
        }
    }
    
    /// Build swap transaction
    async fn build_swap(&self, amm_key: &Pubkey, params: SwapParams) -> Result<Transaction> {
        let amm = self.amm_cache.get(amm_key).unwrap();
        let mut instructions = Vec::new();
        
        // Check for cold accounts and prepend load instructions
        if let Some(compressible) = as_compressible(amm.as_ref()) {
            if compressible.has_cold_accounts() {
                let cold_specs = compressible.get_cold_specs();
                let load_ixs = create_load_instructions(&cold_specs, params.payer).await?;
                instructions.extend(load_ixs);
            }
        }
        
        // Build swap instruction (same for hot/cold)
        let swap = amm.get_swap_and_account_metas(&params)?;
        instructions.push(build_ix(swap));
        
        Ok(build_transaction(instructions, params.payer))
    }
}

/// Helper to downcast to CompressibleAmm
fn as_compressible(amm: &dyn Amm) -> Option<&dyn CompressibleAmm<Variant = impl Pack>> {
    // Implementation depends on how traits are structured
    // Option 1: Use Any + downcast
    // Option 2: Registry lookup
    // Option 3: Method on Amm trait
    todo!()
}
```

---

## Appendix D: Summary of Changes

### Light Protocol Delivers:

1. `CompressibleAmm` trait with 4 methods:
   - `get_compressible_accounts()` - which accounts could be cold
   - `update_with_interfaces()` - update from Photon
   - `get_cold_specs()` - returns lean `ColdAccountSpec<V>`
   - `has_cold_accounts()` - check if any cold
2. `ColdAccountSpec<V>` enum - lean, NO redundant Account data:
   - `Pda { key, compressed, variant, program_id }`
   - `Token { key, compressed }`
   - `Mint { key, compressed }`
3. Converter helpers: `AccountInterface` → `ColdAccountSpec`
4. `create_load_instructions()` function
5. `#[light_program]` macro generates `Variant` types
6. Reference implementation in test AMM SDK
7. Documentation (this document)

### Aggregator Implements:

1. Compressible program registry
2. Photon client integration
3. Cache `get_compressible_accounts()` per AMM
4. On closure: check compressible set → query Photon if needed
5. Hot path: `update(AccountMap)` from stream
6. Cold path: `update_with_interfaces()` from Photon
7. Load instruction prepending in swap building
8. (Optional) Compress transaction log watching

### No Changes Required:

1. Jupiter `Amm` trait - unchanged
2. `get_accounts_to_update()` - unchanged (returns all accounts)
3. Existing non-compressible AMMs - unchanged
4. Quote logic - unchanged (reads from memory)
5. Stream subscription - unchanged (same pubkeys)
