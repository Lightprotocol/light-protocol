# LightProgramClient Trait: General Client for Compressible Programs

## Overview

The `CompressibleAmm` trait is AMM/swap-specific (for Jupiter integration). This document defines `LightProgramClient` - a general trait for ANY program with compressible accounts, supporting ANY instruction type.

---

## Problem Statement

A program might have many instructions, each using different accounts:

```
Program: AMM
├── swap()           → [pool, vault_0, vault_1, user_ata_0, user_ata_1]
├── add_liquidity()  → [pool, vault_0, vault_1, user_ata_0, user_ata_1, lp_mint]
├── remove_liquidity() → [pool, vault_0, vault_1, user_ata_0, user_ata_1, lp_mint]
├── claim_fees()     → [pool, fee_vault, admin]
└── update_config()  → [pool, admin]
```

Each instruction needs different accounts. A client executing `add_liquidity` shouldn't need to load accounts only used by `claim_fees`.

---

## Design Goals

1. **Per-instruction granularity** - load only accounts needed for the specific instruction
2. **Type-safe instruction kinds** - SDK defines enum of instruction types
3. **Consistent with CompressibleAmm** - similar patterns, can share implementation
4. **Minimal client code** - easy to use correctly

---

## Trait Definition

```rust
/// General client trait for programs with compressible accounts.
/// Supports any instruction type, not just swaps.
pub trait LightProgramClient {
    /// The typed variant enum (generated by #[light_program] macro).
    type Variant: Pack + Clone + Debug;
    
    /// Enum of instruction kinds this program supports.
    /// SDK defines this based on program's instruction set.
    type InstructionKind: Copy + Debug;
    
    /// Program ID
    fn program_id(&self) -> Pubkey;
    
    // === Account Discovery ===
    
    /// All compressible accounts across all instructions.
    /// Used for initial fetching/caching.
    fn get_compressible_accounts(&self) -> Vec<Pubkey>;
    
    /// Accounts needed for a specific instruction kind.
    fn get_accounts_for_instruction(&self, kind: Self::InstructionKind) -> Vec<Pubkey>;
    
    /// Compressible accounts for a specific instruction (subset of above).
    fn get_compressible_accounts_for_instruction(&self, kind: Self::InstructionKind) -> Vec<Pubkey>;
    
    // === State Management ===
    
    /// Update from AccountInterface (Photon response).
    /// Stores ColdAccountSpec for cold accounts.
    fn update_with_interfaces(&mut self, accounts: &[AccountInterface]) -> Result<()>;
    
    // === Cold Account Queries ===
    
    /// Get cold specs for accounts needed by an instruction.
    fn get_cold_specs_for_instruction(&self, kind: Self::InstructionKind) -> Vec<ColdAccountSpec<Self::Variant>>;
    
    /// Check if any accounts for instruction are cold.
    fn has_cold_accounts_for_instruction(&self, kind: Self::InstructionKind) -> bool;
}
```

---

## InstructionKind Enum Example

```rust
/// Generated or hand-written for each program
#[derive(Copy, Clone, Debug)]
pub enum AmmInstructionKind {
    Swap,
    AddLiquidity,
    RemoveLiquidity,
    ClaimFees,
    UpdateConfig,
}

impl LightProgramClient for AmmSdk {
    type Variant = LightAccountVariant;
    type InstructionKind = AmmInstructionKind;
    
    fn get_accounts_for_instruction(&self, kind: Self::InstructionKind) -> Vec<Pubkey> {
        match kind {
            AmmInstructionKind::Swap => vec![
                self.pool_state,
                self.vault_0,
                self.vault_1,
            ],
            AmmInstructionKind::AddLiquidity => vec![
                self.pool_state,
                self.vault_0,
                self.vault_1,
                self.lp_mint,
            ],
            AmmInstructionKind::ClaimFees => vec![
                self.pool_state,
                self.fee_vault,
            ],
            // ...
        }
    }
    
    fn get_compressible_accounts_for_instruction(&self, kind: Self::InstructionKind) -> Vec<Pubkey> {
        // Filter to only compressible ones
        self.get_accounts_for_instruction(kind)
            .into_iter()
            .filter(|pk| self.is_compressible(pk))
            .collect()
    }
    
    // ...
}
```

---

## Client Usage Flow

```rust
// 1. Client wants to add liquidity
let kind = AmmInstructionKind::AddLiquidity;

// 2. Check which accounts are needed and might be cold
let compressible = sdk.get_compressible_accounts_for_instruction(kind);

// 3. Fetch from Photon (only if not already cached)
let interfaces = photon.get_account_interfaces(&compressible).await?;
sdk.update_with_interfaces(&interfaces)?;

// 4. Check if any are cold
if sdk.has_cold_accounts_for_instruction(kind) {
    // 5. Get cold specs for THIS instruction only
    let cold_specs = sdk.get_cold_specs_for_instruction(kind);
    
    // 6. Build load instructions
    let load_ixs = create_load_instructions(&cold_specs, payer, config).await?;
    instructions.extend(load_ixs);
}

// 7. Build the actual instruction (SDK-specific method)
let add_liq_ix = sdk.build_add_liquidity(amount_0, amount_1, payer)?;
instructions.push(add_liq_ix);

// 8. Execute transaction
```

---

## Visual: Per-Instruction Cold Detection

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                    PER-INSTRUCTION COLD DETECTION                                │
└─────────────────────────────────────────────────────────────────────────────────┘

    SDK stores all cold specs:
    
    cold_specs: HashMap<Pubkey, ColdAccountSpec<V>>
    ├── pool_state    → ColdAccountSpec::Pda { ... }
    ├── vault_0       → ColdAccountSpec::Token { ... }
    └── fee_vault     → ColdAccountSpec::Token { ... }
    
    
    Client calls: get_cold_specs_for_instruction(Swap)
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │ Swap needs: pool, vault_0,    │
                    │             vault_1           │
                    └───────────────────────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │ Filter cold_specs to these    │
                    │ pubkeys only                  │
                    └───────────────────────────────┘
                                    │
                                    ▼
                    Returns: [pool_state spec, vault_0 spec]
                    (vault_1 is hot, not included)
                    (fee_vault not needed for Swap, not included)
```

---

## Relationship with CompressibleAmm

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                         TRAIT HIERARCHY                                          │
└─────────────────────────────────────────────────────────────────────────────────┘

                    ┌─────────────────────────────┐
                    │    LightProgramClient       │
                    │    (general, any program)   │
                    │                             │
                    │  - InstructionKind enum     │
                    │  - per-instruction methods  │
                    └─────────────────────────────┘
                                  │
                                  │ implements
                                  ▼
                    ┌─────────────────────────────┐
                    │         AmmSdk              │
                    │                             │
                    │  LightProgramClient impl    │
                    │  + Amm impl                 │
                    │  + CompressibleAmm impl     │
                    └─────────────────────────────┘

    CompressibleAmm is a SPECIALIZATION for Jupiter/aggregators:
    
    - get_cold_specs() = get_cold_specs_for_instruction(Swap)
    - has_cold_accounts() = has_cold_accounts_for_instruction(Swap)
    - get_compressible_accounts() = get_compressible_accounts_for_instruction(Swap)
    
    The SDK can implement both traits, with CompressibleAmm delegating to
    LightProgramClient methods for the Swap instruction kind.
```

---

## Implementation: CompressibleAmm as Wrapper

`CompressibleAmm` is just `LightProgramClient` pinned to the `Swap` instruction:

```rust
impl CompressibleAmm for AmmSdk {
    type Variant = LightAccountVariant;
    
    fn get_compressible_accounts(&self) -> Vec<Pubkey> {
        // Swap-specific: only accounts needed for swap
        LightProgramClient::get_compressible_accounts_for_instruction(
            self, 
            AmmInstructionKind::Swap
        )
    }
    
    fn get_cold_specs(&self) -> Vec<ColdAccountSpec<Self::Variant>> {
        // Swap-specific: only cold specs for swap accounts
        LightProgramClient::get_cold_specs_for_instruction(
            self,
            AmmInstructionKind::Swap
        )
    }
    
    fn has_cold_accounts(&self) -> bool {
        // Swap-specific: any swap accounts cold?
        LightProgramClient::has_cold_accounts_for_instruction(
            self,
            AmmInstructionKind::Swap
        )
    }
    
    fn update_with_interfaces(&mut self, accounts: &[AccountInterface]) -> Result<()> {
        // Same - updates all accounts, storage is shared
        LightProgramClient::update_with_interfaces(self, accounts)
    }
}
```

**Key point:** Aggregators call `CompressibleAmm::get_cold_specs()` which returns only swap-relevant cold specs. They don't need or see `add_liquidity` accounts.

---

## SDK Internal Storage (Same as Before)

```rust
struct AmmSdk {
    // Parsed scalars for quoting/operations
    pool_key: Pubkey,
    reserve_0: u64,
    reserve_1: u64,
    // ...
    
    // All cold specs (unified storage)
    cold_specs: HashMap<Pubkey, ColdAccountSpec<LightAccountVariant>>,
    
    // Account pubkeys per type (for instruction routing)
    pool_state: Pubkey,
    vault_0: Pubkey,
    vault_1: Pubkey,
    lp_mint: Pubkey,
    fee_vault: Pubkey,
    // ...
}

impl AmmSdk {
    /// Helper: filter cold_specs to given pubkeys
    fn filter_cold_specs(&self, pubkeys: &[Pubkey]) -> Vec<ColdAccountSpec<LightAccountVariant>> {
        pubkeys.iter()
            .filter_map(|pk| self.cold_specs.get(pk).cloned())
            .collect()
    }
}
```

---

## Method Summary

| Method | Purpose |
|--------|---------|
| `program_id()` | Program ID |
| `get_compressible_accounts()` | ALL compressible accounts (for initial fetch/caching) |
| `get_accounts_for_instruction(kind)` | Accounts needed for specific instruction |
| `get_compressible_accounts_for_instruction(kind)` | Compressible subset for instruction |
| `update_with_interfaces(&[AccountInterface])` | Update from Photon |
| `get_cold_specs_for_instruction(kind)` | Cold specs for instruction's accounts |
| `has_cold_accounts_for_instruction(kind)` | Check if instruction has cold accounts |

**Note:** No `get_all_cold_specs()` needed. Each caller specifies the instruction kind they care about.

---

## Comparison: CompressibleAmm vs LightProgramClient

| Aspect | CompressibleAmm | LightProgramClient |
|--------|-----------------|-------------------|
| Use case | Jupiter/aggregator swaps | Any instruction |
| Instruction scope | Swap only | Per-instruction |
| Granularity | All swap accounts | Specific instruction accounts |
| Inheritance | Extends Amm trait | Standalone |
| Who uses | Aggregators | General clients, wallets, dApps |

---

## Benefits of Per-Instruction Design

1. **Efficiency** - Only load accounts needed for the specific operation
2. **Clarity** - SDK explicitly knows which accounts each instruction needs
3. **Flexibility** - Support any instruction, not just swap
4. **Composability** - CompressibleAmm can delegate to LightProgramClient

---

## Open Questions

### 1. Should InstructionKind be generic or use concrete enum?

**Option A: Associated type (current)**
```rust
type InstructionKind: Copy + Debug;
```
Each SDK defines its own enum.

**Option B: Generic parameter**
```rust
trait LightProgramClient<I: InstructionKind> { ... }
```

Recommendation: Associated type is simpler.

### 2. Should we auto-generate InstructionKind from program?

The `#[light_program]` macro could generate the enum:
```rust
#[light_program]
mod amm {
    pub fn swap(...) { ... }
    pub fn add_liquidity(...) { ... }
}

// Generated:
pub enum AmmInstructionKind { Swap, AddLiquidity }
```

This would be ideal for consistency.

### 3. How does this interact with instruction building?

The trait handles compression (which accounts are cold). Instruction building is SDK-specific:
```rust
// SDK-specific methods (not in trait)
impl AmmSdk {
    fn build_swap(&self, ...) -> Instruction { ... }
    fn build_add_liquidity(&self, ...) -> Instruction { ... }
}
```

The trait doesn't dictate instruction building - that's program-specific.

---

## Summary

`LightProgramClient` is the general trait for any compressible program:
- Per-instruction account discovery
- Per-instruction cold detection
- `CompressibleAmm` is a specialization for swaps that can delegate to it

This enables clients to efficiently load only the accounts needed for their specific operation.
