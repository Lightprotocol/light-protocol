# Init Flow: Ideal Design

## Analysis: What's Missing in A & B

### Design A Gaps
1. No bumps - client can't build instruction params without re-deriving
2. Manifest uses `&'static str` names - not type-safe
3. `to_proof_inputs()` hides address derivation (still some magic)
4. No clear path to typed instruction building

### Design B Gaps
1. Client must call `get_address_tree_v2()` before derivation
2. Multiple pack steps (validity proof -> pack -> instruction)
3. No name/role metadata for debugging
4. Higher verbosity for simple use cases

### What Aggregators Actually Need
1. **All accounts in one place** (Jupiter audit requirement)
2. **Bumps included** (instruction building)
3. **Batch-friendly** (DFlow proof batching)
4. **Debuggable** (name/role for logging)
5. **No hidden RPC** (predictable latency)
6. **Raw access when needed** (custom proof infra)

---

## Ideal Design: Typed Manifest with Raw Access

Combine the best of both:

```rust
//============================================================================
// CORE TYPES - Raw protocol types, no abstraction
//============================================================================

/// Address with its tree - exactly what get_validity_proof needs.
/// Re-exported from light_client::indexer for convenience.
pub use light_client::indexer::AddressWithTree;

/// Compressed address + proof metadata.
#[derive(Debug, Clone)]
pub struct AddressProofInput {
    /// The compressed address bytes (32-byte hash)
    pub address: [u8; 32],
    /// The address tree this belongs to
    pub tree: Pubkey,
    /// Human-readable name for debugging
    pub name: &'static str,
}

impl AddressProofInput {
    /// Convert to AddressWithTree for proof fetching.
    #[inline]
    pub fn to_address_with_tree(&self) -> AddressWithTree {
        AddressWithTree {
            address: self.address,
            tree: self.tree,
        }
    }
}

//============================================================================
// PROGRAM-SPECIFIC: Each SDK defines its own typed PDA struct
//============================================================================

/// All derived accounts for InitializePool.
/// 
/// This is the SINGLE SOURCE OF TRUTH for all pubkeys and bumps.
/// Generated by macro or hand-written per instruction.
#[derive(Debug, Clone)]
pub struct InitPoolAccounts {
    // PDAs that need address proofs
    pub pool_state: Pubkey,
    pub pool_state_bump: u8,
    pub observation_state: Pubkey,
    pub observation_state_bump: u8,
    
    // Mint that needs address proof
    pub lp_mint_signer: Pubkey,
    pub lp_mint_signer_bump: u8,
    pub lp_mint: Pubkey,  // Derived from lp_mint_signer
    
    // Token accounts (NO address proof needed)
    pub token_0_vault: Pubkey,
    pub token_0_vault_bump: u8,
    pub token_1_vault: Pubkey,
    pub token_1_vault_bump: u8,
    
    // ATA (NO address proof needed)
    pub creator_lp_token: Pubkey,
    pub creator_lp_token_bump: u8,
    
    // Static PDAs (NO address proof needed)
    pub authority: Pubkey,
    pub authority_bump: u8,
}

/// Output from derive function - accounts + proof inputs.
#[derive(Debug, Clone)]
pub struct InitPoolDerived {
    /// All derived accounts with bumps.
    pub accounts: InitPoolAccounts,
    /// Addresses that need proofs (pre-computed).
    /// Ready to pass to get_validity_proof.
    pub proof_inputs: Vec<AddressProofInput>,
}

//============================================================================
// SDK IMPLEMENTATION
//============================================================================

impl AmmSdk {
    /// Derive all InitializePool accounts and proof inputs.
    /// 
    /// SYNC - pure derivation, no RPC.
    /// 
    /// # Arguments
    /// * `address_tree` - From `rpc.get_address_tree_v2().tree`. 
    ///   Pass `None` to skip compressed address derivation (only PDAs).
    /// 
    /// # Returns
    /// All accounts with bumps + proof inputs for accounts needing proofs.
    pub fn derive_init_pool(
        amm_config: &Pubkey,
        token_0_mint: &Pubkey,
        token_1_mint: &Pubkey,
        creator: &Pubkey,
        address_tree: &Pubkey,
    ) -> InitPoolDerived {
        // 1. Derive all PDAs
        let (pool_state, pool_state_bump) = Pubkey::find_program_address(
            &[POOL_SEED.as_bytes(), amm_config.as_ref(), token_0_mint.as_ref(), token_1_mint.as_ref()],
            &PROGRAM_ID,
        );
        let (observation_state, observation_state_bump) = Pubkey::find_program_address(
            &[OBSERVATION_SEED.as_bytes(), pool_state.as_ref()],
            &PROGRAM_ID,
        );
        let (authority, authority_bump) = Pubkey::find_program_address(
            &[AUTH_SEED.as_bytes()],
            &PROGRAM_ID,
        );
        let (lp_mint_signer, lp_mint_signer_bump) = Pubkey::find_program_address(
            &[POOL_LP_MINT_SIGNER_SEED, pool_state.as_ref()],
            &PROGRAM_ID,
        );
        let (lp_mint, _) = find_mint_address(&lp_mint_signer);
        let (token_0_vault, token_0_vault_bump) = Pubkey::find_program_address(
            &[POOL_VAULT_SEED.as_bytes(), pool_state.as_ref(), token_0_mint.as_ref()],
            &PROGRAM_ID,
        );
        let (token_1_vault, token_1_vault_bump) = Pubkey::find_program_address(
            &[POOL_VAULT_SEED.as_bytes(), pool_state.as_ref(), token_1_mint.as_ref()],
            &PROGRAM_ID,
        );
        let (creator_lp_token, creator_lp_token_bump) = get_associated_token_address_and_bump(creator, &lp_mint);

        let accounts = InitPoolAccounts {
            pool_state,
            pool_state_bump,
            observation_state,
            observation_state_bump,
            authority,
            authority_bump,
            lp_mint_signer,
            lp_mint_signer_bump,
            lp_mint,
            token_0_vault,
            token_0_vault_bump,
            token_1_vault,
            token_1_vault_bump,
            creator_lp_token,
            creator_lp_token_bump,
        };

        // 2. Derive compressed addresses for accounts needing proofs
        let pool_address = derive_address(
            &pool_state.to_bytes(),
            &address_tree.to_bytes(),
            &PROGRAM_ID.to_bytes(),
        );
        let observation_address = derive_address(
            &observation_state.to_bytes(),
            &address_tree.to_bytes(),
            &PROGRAM_ID.to_bytes(),
        );
        let mint_address = derive_mint_compressed_address(&lp_mint_signer, &MINT_ADDRESS_TREE_PUBKEY);

        let proof_inputs = vec![
            AddressProofInput {
                address: pool_address,
                tree: *address_tree,
                name: "pool_state",
            },
            AddressProofInput {
                address: observation_address,
                tree: *address_tree,
                name: "observation_state",
            },
            AddressProofInput {
                address: mint_address,
                tree: MINT_ADDRESS_TREE_PUBKEY,
                name: "lp_mint",
            },
        ];

        InitPoolDerived {
            accounts,
            proof_inputs,
        }
    }
}

//============================================================================
// CLIENT HELPERS
//============================================================================

impl InitPoolDerived {
    /// Get addresses ready for get_validity_proof.
    pub fn addresses_with_trees(&self) -> Vec<AddressWithTree> {
        self.proof_inputs.iter().map(|p| p.to_address_with_tree()).collect()
    }
    
    /// Log all proof inputs (for debugging/audit).
    pub fn log_proof_inputs(&self) {
        for input in &self.proof_inputs {
            log::debug!(
                "Proof input '{}': address={:?}, tree={}",
                input.name,
                input.address,
                input.tree
            );
        }
    }
}

impl InitPoolAccounts {
    /// Build anchor accounts struct.
    pub fn to_anchor_accounts(
        &self,
        creator: &Pubkey,
        amm_config: &Pubkey,
        token_0_mint: &Pubkey,
        token_1_mint: &Pubkey,
        config_pda: &Pubkey,
    ) -> csdk_anchor_full_derived_test::accounts::InitializePool {
        csdk_anchor_full_derived_test::accounts::InitializePool {
            creator: *creator,
            amm_config: *amm_config,
            authority: self.authority,
            pool_state: self.pool_state,
            token_0_mint: *token_0_mint,
            token_1_mint: *token_1_mint,
            lp_mint_signer: self.lp_mint_signer,
            lp_mint: self.lp_mint,
            creator_lp_token: self.creator_lp_token,
            token_0_vault: self.token_0_vault,
            token_1_vault: self.token_1_vault,
            observation_state: self.observation_state,
            token_program: LIGHT_TOKEN_PROGRAM_ID,
            token_0_program: LIGHT_TOKEN_PROGRAM_ID,
            token_1_program: LIGHT_TOKEN_PROGRAM_ID,
            associated_token_program: LIGHT_TOKEN_PROGRAM_ID,
            system_program: solana_sdk::system_program::ID,
            rent: solana_sdk::sysvar::rent::ID,
            compression_config: *config_pda,
            light_token_compressible_config: COMPRESSIBLE_CONFIG_V1,
            rent_sponsor: RENT_SPONSOR_V1,
            light_token_program: LIGHT_TOKEN_PROGRAM_ID,
            light_token_cpi_authority: LIGHT_TOKEN_CPI_AUTHORITY,
        }
    }
    
    /// Build instruction params.
    pub fn to_params(
        &self,
        create_accounts_proof: CreateAccountsProof,
        init_amount_0: u64,
        init_amount_1: u64,
    ) -> InitializeParams {
        InitializeParams {
            init_amount_0,
            init_amount_1,
            open_time: 0,
            create_accounts_proof,
            lp_mint_signer_bump: self.lp_mint_signer_bump,
            creator_lp_token_bump: self.creator_lp_token_bump,
            authority_bump: self.authority_bump,
        }
    }
}
```

---

## Client Flow: Simple Case

```rust
// 1. Get address tree (cache this!)
let address_tree = rpc.get_address_tree_v2().tree;

// 2. Derive everything (SYNC)
let derived = AmmSdk::derive_init_pool(&config, &mint_0, &mint_1, &creator, &address_tree);

// 3. Get proof using raw addresses (ASYNC)
let proof_result = get_create_accounts_proof_from_addresses(
    &rpc,
    &program_id,
    derived.addresses_with_trees(),
).await?;

// 4. Build instruction (SYNC) - uses accounts struct directly
let accounts = derived.accounts.to_anchor_accounts(&creator, &config, &mint_0, &mint_1, &config_pda);
let params = derived.accounts.to_params(proof_result.create_accounts_proof, 1000, 1000);

let ix = Instruction {
    program_id,
    accounts: [accounts.to_account_metas(None), proof_result.remaining_accounts].concat(),
    data: csdk_anchor_full_derived_test::instruction::InitializePool { params }.data(),
};
```

---

## Client Flow: Aggregator (Full Control)

```rust
// Jupiter/DFlow want maximum control

// 1. Get address tree (they cache it)
let address_tree = jupiter_cache.get_or_fetch_address_tree(&rpc).await;

// 2. Derive (SYNC)
let derived = AmmSdk::derive_init_pool(&config, &mint_0, &mint_1, &creator, &address_tree);

// 3. Log for audit trail
derived.log_proof_inputs();

// 4. Batch with other operations
let all_addresses: Vec<AddressWithTree> = [
    derived.addresses_with_trees(),
    other_operation.addresses_with_trees(),
].concat();

// 5. Fetch proof their way
let validity_proof = jupiter_prover.batch_proof(all_addresses).await?;

// 6. Pack manually
let state_tree = rpc.get_random_state_tree_info()?;
let packed = pack_proof(&program_id, validity_proof, &state_tree, None)?;

// 7. Build instruction their way
let ix = jupiter_ix_builder.build(
    &derived.accounts,
    packed,
    init_amounts,
);
```

---

## Convenience Wrapper (Optional)

For clients who want one-liner:

```rust
/// Convenience: derive + get proof in one call.
/// 
/// Use this for simple cases. Aggregators should use raw derive + proof separately.
pub async fn derive_and_prove_init_pool<R: Rpc + Indexer>(
    rpc: &R,
    amm_config: &Pubkey,
    token_0_mint: &Pubkey,
    token_1_mint: &Pubkey,
    creator: &Pubkey,
) -> Result<(InitPoolDerived, CreateAccountsProofResult), Error> {
    let address_tree = rpc.get_address_tree_v2().tree;
    let derived = AmmSdk::derive_init_pool(amm_config, token_0_mint, token_1_mint, creator, &address_tree);
    let proof_result = get_create_accounts_proof_from_addresses(
        rpc,
        &PROGRAM_ID,
        derived.addresses_with_trees(),
    ).await?;
    Ok((derived, proof_result))
}
```

---

## Key Design Decisions

### 1. address_tree as explicit parameter
- No hidden RPC in derivation
- Cacheable by aggregators
- Clear dependency

### 2. Typed PDA struct (not generic manifest)
- Type safety for instruction building
- IDE autocompletion
- Compile-time errors for missing fields

### 3. proof_inputs with names
- Debuggable
- Audit trail
- Zero overhead (just metadata)

### 4. Raw AddressWithTree access
- Protocol-native types
- Batchable
- No abstraction layer

### 5. Convenience layer is optional
- Power users use raw derive
- Simple clients use wrapper
- No forced abstraction

---

## Comparison with A & B

| Aspect | Design A | Design B | Ideal |
|--------|----------|----------|-------|
| Typed accounts | No (generic) | Yes | Yes |
| Bumps included | No | Yes | Yes |
| Debug names | Yes | No | Yes |
| Raw address access | Partial | Yes | Yes |
| Convenience wrapper | Yes | No | Yes (optional) |
| Hidden RPC | Partial | No | No |
| Aggregator fit | High | Maximum | Maximum |
| Simple client fit | High | Medium | High |

---

## Implementation Checklist

1. [ ] Define `AddressProofInput` in `light_client::interface`
2. [ ] Add `get_create_accounts_proof_from_addresses()` function
3. [ ] Generate typed account structs per instruction (macro or codegen)
4. [ ] Add `to_anchor_accounts()` and `to_params()` helpers
5. [ ] Add optional convenience wrapper
6. [ ] Update AMM test to use new flow
7. [ ] Document for aggregators
