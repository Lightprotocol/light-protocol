//! Traits for decompression variant construction and manual Light Protocol implementation.
//!
//! This module contains traits for typed compressed account handling:
//! - Base traits (`IntoVariant`) - always available
//! - Variant traits (`LightAccountVariantTrait`, `PackedLightAccountVariantTrait`) - anchor-gated
//! - Token seed traits (`UnpackedTokenSeeds`, `PackedTokenSeeds`) - anchor-gated

// --- Base traits (always available) ---

#[cfg(feature = "anchor")]
use anchor_lang::error::Error;
#[cfg(not(feature = "anchor"))]
use solana_program_error::ProgramError as Error;

/// Trait for seeds that can construct a compressed account variant.
///
/// Implemented by generated `XxxSeeds` structs (e.g., `UserRecordSeeds`).
/// The macro generates impls that deserialize account data and verify seeds match.
///
/// # Example (generated code)
/// ```ignore
/// impl IntoVariant<RentFreeAccountVariant> for UserRecordSeeds {
///     fn into_variant(self, data: &[u8]) -> Result<RentFreeAccountVariant, Error> {
///         RentFreeAccountVariant::user_record(data, self)
///     }
/// }
/// ```
pub trait IntoVariant<V> {
    /// Construct variant from compressed account data bytes and these seeds.
    ///
    /// # Arguments
    /// * `data` - Raw compressed account data bytes
    ///
    /// # Returns
    /// The constructed variant on success, or an error if:
    /// - Deserialization fails
    /// - Seed verification fails (data.* seeds don't match account data)
    fn into_variant(self, data: &[u8]) -> Result<V, Error>;
}

// --- Anchor-gated variant traits ---

#[cfg(feature = "anchor")]
mod anchor_traits {
    use anchor_lang::prelude::*;
    use light_sdk_types::instruction::PackedStateTreeInfo;
    use light_token_interface::instructions::{
        extensions::ExtensionInstructionData, transfer2::MultiInputTokenDataWithContext,
    };
    use solana_program_error::ProgramError;

    use crate::account::light_account::AccountType;

    /// Trait for unpacked compressed account variants with seeds.
    ///
    /// Implementations are generated by the `#[light_program]` macro for each
    /// account type marked with `#[light_account(init)]`.
    ///
    /// # Type Parameters
    /// * `SEED_COUNT` - Number of seeds including bump for CPI signing
    /// * `Seeds` - The seeds struct type (e.g., `UserRecordSeeds`)
    /// * `Data` - The account data type (e.g., `UserRecord`)
    /// * `Packed` - The packed variant type for serialization
    pub trait LightAccountVariantTrait<const SEED_COUNT: usize>:
        Sized + Clone + AnchorSerialize + AnchorDeserialize
    {
        /// The program ID that owns accounts of this variant type.
        const PROGRAM_ID: Pubkey;

        /// The seeds struct type containing seed values.
        type Seeds;

        /// The account data type.
        type Data;

        /// The packed variant type for efficient serialization.
        type Packed: PackedLightAccountVariantTrait<SEED_COUNT, Unpacked = Self>;

        /// Get a reference to the account data.
        fn data(&self) -> &Self::Data;

        /// Get seed values as owned byte vectors for PDA derivation.
        fn seed_vec(&self) -> Vec<Vec<u8>>;

        /// Get seed references with bump for CPI signing.
        /// Returns a fixed-size array that can be passed to invoke_signed.
        fn seed_refs_with_bump<'a>(&'a self, bump_storage: &'a [u8; 1]) -> [&'a [u8]; SEED_COUNT];

        /// Derive the PDA address and bump seed using PROGRAM_ID.
        fn derive_pda(&self) -> (Pubkey, u8) {
            let seeds = self.seed_vec();
            let seed_slices: Vec<&[u8]> = seeds.iter().map(|s| s.as_slice()).collect();
            Pubkey::find_program_address(&seed_slices, &Self::PROGRAM_ID)
        }
    }

    /// Trait for packed compressed account variants.
    ///
    /// Packed variants use u8 indices instead of 32-byte Pubkeys for efficient
    /// serialization. They can be unpacked back to full variants using account info.
    #[allow(clippy::wrong_self_convention)]
    pub trait PackedLightAccountVariantTrait<const SEED_COUNT: usize>:
        Sized + Clone + AnchorSerialize + AnchorDeserialize
    {
        /// The unpacked variant type with full Pubkey values.
        type Unpacked: LightAccountVariantTrait<SEED_COUNT>;

        /// The account type (Pda, Token, Ata, etc.) for dispatch.
        const ACCOUNT_TYPE: AccountType;

        /// Get the PDA bump seed.
        fn bump(&self) -> u8;

        /// Unpack this variant by resolving u8 indices to Pubkeys.
        fn unpack(&self, accounts: &[AccountInfo]) -> Result<Self::Unpacked>;

        /// Get seed references with bump for CPI signing.
        /// Resolves u8 indices to pubkey refs from accounts slice.
        fn seed_refs_with_bump<'a>(
            &'a self,
            accounts: &'a [AccountInfo],
            bump_storage: &'a [u8; 1],
        ) -> std::result::Result<[&'a [u8]; SEED_COUNT], ProgramError>;

        /// Extract token data for compressed token CPI.
        ///
        /// Returns the packed token data needed for the token transfer instruction.
        /// Only meaningful for token account variants; PDA variants should not override.
        fn into_in_token_data(
            &self,
            tree_info: &PackedStateTreeInfo,
            output_queue_index: u8,
        ) -> Result<MultiInputTokenDataWithContext>;

        /// Extract TLV extension data for compressed token CPI.
        ///
        /// Returns extension instruction data if the token account has extensions.
        /// Only meaningful for token account variants; PDA variants return `None`.
        fn into_in_tlv(&self) -> Result<Option<Vec<ExtensionInstructionData>>>;

        /// Derive the owner pubkey from constant owner_seeds and program ID.
        /// Only meaningful for token account variants; PDA variants return default.
        fn derive_owner(&self) -> Pubkey {
            Pubkey::default()
        }
    }

    /// Trait for unpacked token seed structs.
    ///
    /// Generated by the `#[light_program]` macro on per-variant seed structs
    /// (e.g., `TokenVaultSeeds`). Provides seed-specific behavior for the blanket
    /// `LightAccountVariantTrait` impl on `TokenDataWithSeeds<S>`.
    pub trait UnpackedTokenSeeds<const N: usize>:
        Clone + std::fmt::Debug + AnchorSerialize + AnchorDeserialize
    {
        /// The packed seeds type.
        type Packed: PackedTokenSeeds<N, Unpacked = Self>;

        const PROGRAM_ID: Pubkey;
        fn seed_vec(&self) -> Vec<Vec<u8>>;
        fn seed_refs_with_bump<'a>(&'a self, bump_storage: &'a [u8; 1]) -> [&'a [u8]; N];
    }

    /// Trait for packed token seed structs.
    ///
    /// Generated by the `#[light_program]` macro on per-variant packed seed structs
    /// (e.g., `PackedTokenVaultSeeds`). Provides seed-specific behavior for the blanket
    /// `PackedLightAccountVariantTrait` impl on `TokenDataWithPackedSeeds<S>`.
    pub trait PackedTokenSeeds<const N: usize>:
        crate::account::pack::Unpack + Clone + std::fmt::Debug + AnchorSerialize + AnchorDeserialize
    {
        fn bump(&self) -> u8;
        fn seed_refs_with_bump<'a>(
            &'a self,
            accounts: &'a [AccountInfo],
            bump_storage: &'a [u8; 1],
        ) -> std::result::Result<[&'a [u8]; N], ProgramError>;

        /// Derive the owner pubkey from constant owner_seeds and program ID.
        fn derive_owner(&self) -> Pubkey;
    }
}

#[cfg(feature = "anchor")]
pub use anchor_traits::{
    LightAccountVariantTrait, PackedLightAccountVariantTrait, PackedTokenSeeds, UnpackedTokenSeeds,
};
