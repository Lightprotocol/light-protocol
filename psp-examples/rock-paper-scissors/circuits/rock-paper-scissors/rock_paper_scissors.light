pragma circom 2.1.4;

include "poseidon.circom";
include "merkleProof.circom";
include "keypair.circom";
include "gates.circom";
include "comparators.circom";

// will create a new instance of the circuit
#[instance]
{
  name: rock_paper_scissors,
  publicInputs: [publicGameCommitment0, publicGameCommitment1],
}

utxoType gameUtxo {
  slot, // after this slot the game should timeout and player two should win by default not implemented yet
  choice,
  opponentGameCommitmentHash, // zero for player 1
  userPubkey,
}

inUtxo playerOne {
  type: gameUtxo,
  checks:
  {
    utxoDataHash == publicGameCommitment0,
  },
}

inUtxo playerTwo {
  type: gameUtxo,
  checks:
  {
    amountSol == playerOne.amountSol,
    amountSpl == playerOne.amountSpl,
    assetSpl == playerOne.assetSpl,
    utxoDataHash == publicGameCommitment1,
  },
  dataChecks: {
    opponentGameCommitmentHash == playerOne.opponentGameCommitmentHash,
  },
}

// TODO: enable expression in fields
outUtxo drawPlayerTwo {
  type: native,
  enabled: isDraw,
  checks:
  {
    amountSol == playerTwo.amountSol,
    amountSpl == playerTwo.amountSpl,
    assetSpl == playerTwo.assetSpl,
    blinding == playerTwoOutUtxoBlinding,
    publicKey == playerTwo.userPubkey,
  },
}

// Player one loses, since player one executes we need to check the utxo of player two
outUtxo winPlayerTwo {
  type: native,
  enabled: isLoss,
  checks:
  {
    amountSol == doubleAmountSol,
    amountSpl == doubleAmountSpl,
    assetSpl == playerTwo.assetSpl,
    blinding == playerTwoOutUtxoBlinding,
    publicKey == playerTwo.userPubkey,
  },
}

#[entrypoint]
template rock_paper_scissors() {

    signal input isDraw;
    signal input isWin[3]; // player 1 executes the transaction
    signal input isLoss;
    signal input publicGameCommitment0;
    signal input publicGameCommitment1;

    utxo playerOne;
    playerOne.check();
    utxo playerTwo;
    playerTwo.check();
    utxo drawPlayerTwo;
    utxo winPlayerTwo;

    var playerTwoOutUtxoBlinding = playerTwo.publicKey + playerTwo.publicKey;
    var doubleAmountSol = playerTwo.amountSol * 2;
    var doubleAmountSpl = playerTwo.amountSpl * 2;

    var isWinTmp = 0;
    for (var i = 0; i < 3; i++) {
      (isWin[i] - 1) * isWin[i] === 0;
      isWinTmp = isWinTmp + isWin[i];
    }

    component checkWin = ForceEqualIfEnabled();
    checkWin.in[0] <== isWinTmp;
    checkWin.in[1] <== 0;
    checkWin.enabled <== isLoss + isDraw;

    // either isLoss or isDraw should be 1
    component checkIsDrawOrLose1 = OR();
    checkIsDrawOrLose1.a <== isLoss;
    checkIsDrawOrLose1.b <== isDraw;
    checkIsDrawOrLose1.out === 1 - isWinTmp;
    // either isLoss or isDraw should be 1
    component checkLossDrawEqual1 = ForceEqualIfEnabled();
    checkLossDrawEqual1.in[0] <== isLoss + isDraw;
    checkLossDrawEqual1.in[1] <== 1;
    checkLossDrawEqual1.enabled <== isLoss + isDraw;

    // component gameCommitmentHasher0 = Poseidon(4);
    // gameCommitmentHasher0.inputs[0] <== playerOne.choice;
    // gameCommitmentHasher0.inputs[1] <== slot[0];
    // gameCommitmentHasher0.inputs[2] <== 0;
    // gameCommitmentHasher0.inputs[3] <== gameAmount;

    // component gameCommitmentHasher1 = Poseidon(4);
    // gameCommitmentHasher1.inputs[0] <== playerTwo.choice;
    // gameCommitmentHasher1.inputs[1] <== slot[1];
    // gameCommitmentHasher1.inputs[2] <== gameCommitmentHasher0.out;
    // gameCommitmentHasher1.inputs[3] <== gameAmount;

    // gameCommitmentHasher0.out === publicGameCommitment0;
    // gameCommitmentHasher1.out === publicGameCommitment1;

    // TODO check that this works
    // component checkCommitmentHashOrder = LessThan(64);
    // checkCommitmentHashOrder.a <== slot[0];
    // checkCommitmentHashOrder.b <== slot[1];

    // check if the amount in the escrow utxos is correct
    // component checkCommittedAmount[2][nIns];
    // for (var playerIndex =0; playerIndex < 2; playerIndex++) {
    //   for(var inUtxoIndex = 0; inUtxoIndex < nIns; inUtxoIndex++) {
    //     checkCommittedAmount[playerIndex][inUtxoIndex] = ForceEqualIfEnabled();
    //     checkCommittedAmount[playerIndex][inUtxoIndex].in[0] <== inAmount[inUtxoIndex][0];
    //     checkCommittedAmount[playerIndex][inUtxoIndex].in[1] <== gameAmount;
    //     checkCommittedAmount[playerIndex][inUtxoIndex].enabled <== isAppInUtxo[playerIndex][inUtxoIndex];
    //   }
    // }


    /*  rock = 0, paper = 1, scissors = 2
        0 = 2nd player loses, 1 = draw, 2 = 2nd player wins
          0 0 = 1
          0 1 = 2
          0 2 = 0
          1 0 = 0
          1 1 = 1
          1 2 = 2
          2 0 = 2
          2 1 = 0
          2 2 = 1
    */

    component caseDraw = ForceEqualIfEnabled();
    caseDraw.in[0] <== playerOne.choice;
    caseDraw.in[1] <== playerTwo.choice;
    caseDraw.enabled <== isDraw;

    component caseWin1 = game_logic();
    caseWin1.choice <== [playerOne.choice, playerTwo.choice];
    caseWin1.isWin <== isWin[0];
    caseWin1.refChoice <== [0, 2];

    component caseWin2 = game_logic();
    caseWin2.choice <== [playerOne.choice, playerTwo.choice];
    caseWin2.isWin <== isWin[1];
    caseWin2.refChoice <== [1, 0];

    component caseWin3 = game_logic();
    caseWin3.choice <== [playerOne.choice, playerTwo.choice];
    caseWin3.isWin <== isWin[2];
    caseWin3.refChoice <== [2, 1];


    
    // check utxos for case draw
    // the locked amounts should go back to each player
    // we just need to check for player 2 because player 1 executes the tx
    drawPlayerTwo.check();
    winPlayerTwo.check();
}

// template get_publickey(nIns) {
//   signal input isAppInUtxo[nIns];
//   signal input inPublicKey[nIns];
//   signal input opponentPubkey;
//   signal input inAppDataHash[nIns];
//   signal input actualAppDataHash;
//   component getPublickey[nIns];
//   component checkAppDataHash[nIns];
//   for (var inUtxo = 0; inUtxo < nIns; inUtxo++) {
//     getPublickey[inUtxo] = ForceEqualIfEnabled();
//     getPublickey[inUtxo].in[0] <== inPublicKey[inUtxo];
//     getPublickey[inUtxo].in[1] <== opponentPubkey;
//     getPublickey[inUtxo].enabled <== isAppInUtxo[inUtxo];
//     checkAppDataHash[inUtxo] = ForceEqualIfEnabled();
//     checkAppDataHash[inUtxo].in[0] <== inAppDataHash[inUtxo];
//     checkAppDataHash[inUtxo].in[1] <== actualAppDataHash;
//     checkAppDataHash[inUtxo].enabled <== isAppInUtxo[inUtxo];
//   }
// }
template game_logic() {
  signal input choice[2];
  signal input isWin;
  signal input refChoice[2];
  component caseWin1A = ForceEqualIfEnabled();
  caseWin1A.in[0] <== choice[0];
  caseWin1A.in[1] <== refChoice[0];
  caseWin1A.enabled <== isWin;

  component caseWin1B = ForceEqualIfEnabled();
  caseWin1B.in[0] <== choice[1];
  caseWin1B.in[1] <== refChoice[1];
  caseWin1B.enabled <== isWin;
}
