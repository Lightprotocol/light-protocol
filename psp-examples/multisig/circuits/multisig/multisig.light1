pragma circom 2.1.4;
include "../../node_modules/circomlib/circuits/poseidon.circom";
include "../../node_modules/@lightprotocol/zk.js/circuit-lib/merkleProof.circom";
include "../../node_modules/@lightprotocol/zk.js/circuit-lib/keypair.circom";
include "../../node_modules/circomlib/circuits/gates.circom";
include "../../node_modules/circomlib/circuits/comparators.circom";
include "../../node_modules/circomlib/circuits/eddsaposeidon.circom";

// will create a new instance of the circuit
#[instance]
{
    fileName: multisig,
    config(),
    nrAppUtoxs: 1
}

#[lightTransaction(verifierTwo)]
template multisig() {
    // Defines the data which is saved in the utxo
    // utxoData variables need to be lowerCamelCase
    #[utxoData]
    {
        threshold,
        nrSigners
    }

    var nrMaxSigners = 7;
    var baseVariables = 2;

    signal input signerPubkeysX[nrMaxSigners];
    signal input signerPubkeysY[nrMaxSigners];

    // calculate instruction hash
    // component instructionHasher = Poseidon(baseVariables + nrMaxSigners * 2);
    // instructionHasher.inputs[0] <== threshold;
    // instructionHasher.inputs[1] <== nrSigners;

    // if need more max signers hash x and y
    // var j = 0;
    // for (var i = baseVariables; i < nrMaxSigners * 2 + baseVariables; i+=2) {
    //     instructionHasher.inputs[i] <== signerPubkeysX[j];
    //     instructionHasher.inputs[i + 1] <== signerPubkeysY[j];
    //     j++;
    // }
    
    signal input enabled[nrMaxSigners];

    signal input signatures[nrMaxSigners];
    signal input r8x[nrMaxSigners];
    signal input r8y[nrMaxSigners];

    // check either one or zero plus
    // number of signatures to check is greater than the threshold
    component checkIndices = CheckIndices(nrMaxSigners);
    checkIndices.threshold <== threshold;
    for (var i = 0; i < nrMaxSigners; i++) {
        checkIndices.indices[i] <== enabled[i];
    }


    // TODO: in program
    // registry account for multisig
    // - shared sym enc key
    // - sym enc key is encrypted to all participants
    // - sym key encrypted pubkeys of all participants
    // - encryption pubkey of multisig
    // - instructionHash of multisig
    // - pubkey or privkey of generic multisig signer has to be constant but doesn't do anything

    // cancel:
    // you can cancel the by spending a zero input transaction which is part of the connecting hash


    // we should store encrypted messages in compressed accounts
    // we need a verifier that just pays the relayer and stores data in a compressed account that's almost free and the additional data needs to be included in 
    // the integrity hash 
    // message is all utxos involved in the transaction encrypted with the symmetric key
    // Check signatures
    component sigVerifier[nrMaxSigners];
    for(var i = 0; i < nrMaxSigners; i++) {
        sigVerifier[i] = EdDSAPoseidonVerifier();
        // all dummy signer pubkeys are expected to be 0
        // this checks that dummy keypairs cannot validate signatures
        sigVerifier[i].enabled <== enabled[i] * signerPubkeysX[i];
        sigVerifier[i].Ax <== signerPubkeysX[i];
        sigVerifier[i].Ay <== signerPubkeysY[i];
        sigVerifier[i].S <== signatures[i];
        sigVerifier[i].R8x <== r8x[i];
        sigVerifier[i].R8y <== r8y[i];
        sigVerifier[i].M <== transactionHasher.out;
    }
}

template CheckIndices(n) {
    signal input indices[n];    
    signal input threshold;
    var varSumIndices = 0;
    for (var j = 0; j < n; j++) {
        varSumIndices += indices[j];
        // all indices are 0 or 1
        indices[j] * (1 - indices[j]) === 0;
    }
    // TODO: test that this works
    component checkThreshold = GreaterEqThan(8);
    checkThreshold.in[0] <== varSumIndices;
    checkThreshold.in[1] <== threshold;
    checkThreshold.out === 1;
}

/*
* Environment Constants:
*   levels = 18
*   nIns = 4 (number of in utxos)
*   nOuts = 4 (number of out utxos)
*   feeAsset = TruncatedSha256(0)
*   indexFeeAsset = 0
*   indexPublicAsset = 1
*   nAssets = 3
*   nInAssets = 2
*   nOutAssets = 2
* Environment variables:
*   txIntegrityHash;
*   transactionVersion;
*   publicAppVerifier;
*   transactionHash;
*   instructionHasher.out;
*   isAppInUtxo[nAppUtxos][nIns];
*   
*  InUtxos:
*   inAmount[nIns][nInAssets];
*   inPublicKey[nIns];
*   inBlinding[nIns];
*   inAppDataHash[nIns];
*   inPoolType[nIns];
*   inVerifierPubkey[nIns];
*   inIndices[nIns][nInAssets][nAssets];
* OutUtxos:
*   outputCommitment[nOuts];
*   outAmount[nOuts][nOutAssets];
*   outPubkey[nOuts];
*   outBlinding[nOuts];
*   outAppDataHash[nOuts];
*   outIndices[nOuts][nOutAssets][nAssets];
*   outPoolType[nOuts];
*   outVerifierPubkey[nOuts];
*/