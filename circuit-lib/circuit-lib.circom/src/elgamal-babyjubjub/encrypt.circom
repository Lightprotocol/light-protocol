pragma circom 2.1.2;

include "babyjub.circom";
include "bitify.circom";
include "escalarmulany.circom";
include "escalarmulfix.circom";

template Encode(nBits) {
    signal input plaintext;
    signal output out[2];

    // baby jubjub curve base point
    var base[2] = [
        5299619240641551281634865583518297030282874472190772894086521144482721001553,
        16950150798460657717958625567821834550301663161624707787222815936182638968203
    ]; 

    component plaintextBits = Num2Bits(nBits);
    component BaseMultiply = EscalarMulFix(nBits, base);

    var i;
    plaintext ==> plaintextBits.in;
    for  (i=0; i<32; i++) {
        plaintextBits.out[i] ==> BaseMultiply.e[i];
    }

    BaseMultiply.out ==> out;
}

template Encrypt() {

    // message encoded as a point on the curve: message = [plaintext].G, G: curve base point
    signal input message[2];    
    // secret key nonce          
    signal input nonceKey;    
    // public key generated by the receiver             
    signal input publicKey[2];             

    // ephemeral key: [nonce].Base
    signal output ephemeralKey[2];  
    // encrypted message: ciphertext = message + [nonceKey].publicKey           
    signal output ciphertext[2];            
    
    component isz = IsZero();
    isz.in <== publicKey[0];
    
    component ise = IsEqual();
    ise.in[0] <== publicKey[1];
    ise.in[1] <== 1;

    // protect against invalid curve attacks => Public Key shouldn't be the identity point
    isz.out + ise.out === 0;  


    // check the public key is point on curve
    component  publicKeyIsOnCurve = BabyCheck();
    publicKeyIsOnCurve.x <== publicKey[0];
    publicKeyIsOnCurve.y <== publicKey[1];
 
    // check the message is a point on curve
    component  messageIsOnCurve = BabyCheck();            
    messageIsOnCurve.x <== message[0];
    messageIsOnCurve.y <== message[1];
    
    // baby jubjub curve base point
    var base[2] = [
        5299619240641551281634865583518297030282874472190772894086521144482721001553,
        16950150798460657717958625567821834550301663161624707787222815936182638968203
    ];        

    // calculate the ephemeral key
    component baseMultiply = EscalarMulFix(253, base);
    
    // calculate the masking key => [nonce].PublicKey
    component publicKeyMultiply = EscalarMulAny(253);
    publicKeyMultiply.p[0] <== publicKey[0];
    publicKeyMultiply.p[1] <== publicKey[1];

    // since both ephemeral key and masking key are based on nonceKey multiplication
    // nonceKey bits are used in common for both operations
    component nonceKeyBits = Num2Bits(253);
    
    var i;
    nonceKey ==> nonceKeyBits.in;
    for  (i=0; i<253; i++) {
        nonceKeyBits.out[i] ==> baseMultiply.e[i];
        nonceKeyBits.out[i] ==> publicKeyMultiply.e[i];
    }

    baseMultiply.out[0] ==> ephemeralKey[0];
    baseMultiply.out[1] ==> ephemeralKey[1];
    
    signal maskingKey[2];
    publicKeyMultiply.out[0] ==> maskingKey[0];
    publicKeyMultiply.out[1] ==> maskingKey[1];

    component add = BabyAdd();
    add.x1 <== maskingKey[0];
    add.y1 <== maskingKey[1];
    add.x2 <== message[0];
    add.y2 <== message[1];
    ciphertext[0] <== add.xout;
    ciphertext[1] <== add.yout;
}
