use borsh::BorshDeserialize;
use borsh::BorshSerialize;
use light_macros::pubkey;
use light_sdk::{
    compressible::{CompressionInfo, HasCompressionInfo},
    LightDiscriminator, LightHasher,
};
use light_sdk::{cpi::CpiSigner, derive_light_cpi_signer, error::LightSdkError};
use light_sdk_macros::add_native_compressible_instructions;
use solana_program::{
    account_info::AccountInfo, entrypoint, entrypoint::ProgramResult, program_error::ProgramError,
    pubkey::Pubkey,
};

pub mod create_dynamic_pda;

pub mod update_pda;

pub const ID: Pubkey = pubkey!("FNt7byTHev1k5x2cXZLBr8TdWiC3zoP5vcnZR4P682Uy");
pub const LIGHT_CPI_SIGNER: CpiSigner =
    derive_light_cpi_signer!("FNt7byTHev1k5x2cXZLBr8TdWiC3zoP5vcnZR4P682Uy");

// Generate all compression-related instructions and data structures
#[add_native_compressible_instructions(MyPdaAccount)]
pub mod compression {
    use super::*;
}

// Define instruction enum like sdk-test
#[repr(u8)]
pub enum InstructionType {
    // Compression instructions (generated by macro)
    CreateCompressionConfig = 0,
    UpdateCompressionConfig = 1,
    DecompressMultiplePdas = 2,
    CompressMyPdaAccount = 3,

    // Custom instructions
    CreateDynamicPda = 10,
    UpdatePda = 11,
}

impl TryFrom<u8> for InstructionType {
    type Error = LightSdkError;

    fn try_from(value: u8) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(InstructionType::CreateCompressionConfig),
            1 => Ok(InstructionType::UpdateCompressionConfig),
            2 => Ok(InstructionType::DecompressMultiplePdas),
            3 => Ok(InstructionType::CompressMyPdaAccount),
            10 => Ok(InstructionType::CreateDynamicPda),
            11 => Ok(InstructionType::UpdatePda),
            _ => Err(LightSdkError::ConstraintViolation),
        }
    }
}

entrypoint!(process_instruction);

pub fn process_instruction(
    _program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    if instruction_data.is_empty() {
        return Err(ProgramError::InvalidInstructionData);
    }

    let discriminator = InstructionType::try_from(instruction_data[0])
        .map_err(|_| ProgramError::InvalidInstructionData)?;
    let data = &instruction_data[1..];

    match discriminator {
        // Compression config instructions (generated by macro)
        InstructionType::CreateCompressionConfig => {
            let params =
                compression::CreateCompressionConfigData::try_from_slice(data).map_err(|_| {
                    ProgramError::BorshIoError(
                        "Failed to deserialize create config data".to_string(),
                    )
                })?;
            compression::create_compression_config(
                accounts,
                params.compression_delay,
                params.rent_recipient,
                params.address_space,
            )
        }

        InstructionType::UpdateCompressionConfig => {
            let params =
                compression::UpdateCompressionConfigData::try_from_slice(data).map_err(|_| {
                    ProgramError::BorshIoError(
                        "Failed to deserialize update config data".to_string(),
                    )
                })?;
            compression::update_compression_config(
                accounts,
                params.new_compression_delay,
                params.new_rent_recipient,
                params.new_address_space,
                params.new_update_authority,
            )
        }

        InstructionType::DecompressMultiplePdas => {
            let params =
                compression::DecompressMultiplePdasData::try_from_slice(data).map_err(|_| {
                    ProgramError::BorshIoError("Failed to deserialize decompress data".to_string())
                })?;
            compression::decompress_multiple_pdas(
                accounts,
                params.proof,
                params.compressed_accounts,
                params.bumps,
                params.system_accounts_offset,
            )
        }

        InstructionType::CompressMyPdaAccount => {
            let params =
                compression::CompressMyPdaAccountData::try_from_slice(data).map_err(|_| {
                    ProgramError::BorshIoError("Failed to deserialize compress data".to_string())
                })?;
            compression::compress_my_pda_account(
                accounts,
                params.proof,
                params.compressed_account_meta,
            )
        }

        // Custom instructions (still manually implemented)
        InstructionType::CreateDynamicPda => create_dynamic_pda::create_dynamic_pda(accounts, data)
            .map_err(|e| ProgramError::from(e)),

        InstructionType::UpdatePda => {
            update_pda::update_pda::<false>(accounts, data).map_err(|e| ProgramError::from(e))
        }

        _ => Err(ProgramError::InvalidInstructionData),
    }
}

pub const COMPRESSION_DELAY: u64 = 100;

#[derive(
    Default, Clone, Debug, BorshSerialize, BorshDeserialize, LightHasher, LightDiscriminator,
)]
pub struct MyPdaAccount {
    #[skip]
    pub compression_info: CompressionInfo,
    #[hash]
    pub owner: Pubkey,
    pub data: u64,
}

// Implement the HasCompressionInfo trait
impl HasCompressionInfo for MyPdaAccount {
    fn compression_info(&self) -> &CompressionInfo {
        &self.compression_info
    }

    fn compression_info_mut(&mut self) -> &mut CompressionInfo {
        &mut self.compression_info
    }
}
