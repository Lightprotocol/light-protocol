name: Publish Release

on:
  pull_request:
    types: [closed]
    branches:
      - main

jobs:
  publish-release:
    # Only run on merged release PRs
    if: github.event.pull_request.merged == true && contains(github.event.pull_request.labels.*.name, 'release')
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable

      - name: Install cargo-release
        run: cargo install cargo-release

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Detect release type from PR
        id: detect_type
        env:
          PR_BRANCH: ${{ github.event.pull_request.head.ref }}
        run: |
          if [[ "$PR_BRANCH" == release/program-libs-* ]]; then
            echo "type=program-libs" >> "$GITHUB_OUTPUT"
          elif [[ "$PR_BRANCH" == release/sdk-libs-* ]]; then
            echo "type=sdk-libs" >> "$GITHUB_OUTPUT"
          else
            echo "type=unknown" >> "$GITHUB_OUTPUT"
            echo "Error: Could not detect release type from branch: $PR_BRANCH"
            exit 1
          fi

      - name: Publish to crates.io (program-libs)
        if: steps.detect_type.outputs.type == 'program-libs'
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PROGRAM_LIBS=(
            "light-account-checks" "aligned-sized" "light-batched-merkle-tree"
            "light-bloom-filter" "light-compressed-account" "light-concurrent-merkle-tree"
            "light-hash-set" "light-hasher" "light-heap" "light-indexed-array"
            "light-indexed-merkle-tree" "light-macros" "light-merkle-tree-metadata"
            "light-verifier" "light-zero-copy-derive" "light-zero-copy"
          )

          echo "Publishing program-libs crates individually..."
          > /tmp/published_tags.txt

          for pkg in "${PROGRAM_LIBS[@]}"; do
            echo "----------------------------------------"
            echo "Publishing $pkg..."

            # Publish to crates.io and create tag
            if cargo release publish -p "$pkg" --execute --no-confirm; then
              echo "✓ Published $pkg"

              # Get the tag that was just created
              VERSION=$(cargo metadata --format-version 1 --no-deps | jq -r ".packages[] | select(.name == \"$pkg\") | .version")
              TAG="${pkg}-v${VERSION}"

              # Create GitHub release
              echo "Creating GitHub release for $TAG..."
              if gh release create "$TAG" --generate-notes --title "$TAG"; then
                echo "✓ Created release for $TAG"
                echo "$TAG" >> /tmp/published_tags.txt
              else
                echo "Warning: Failed to create release for $TAG"
              fi

              # Rate limiting: wait between publishes
              sleep 10
            else
              echo "Warning: Failed to publish $pkg"
            fi
          done

      - name: Publish to crates.io (sdk-libs)
        if: steps.detect_type.outputs.type == 'sdk-libs'
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          SDK_LIBS=(
            "light-sdk-macros" "light-sdk-types" "light-sdk-pinocchio"
            "light-sdk" "light-client" "photon-api" "light-program-test"
          )

          echo "Publishing sdk-libs crates individually..."
          > /tmp/published_tags.txt

          for pkg in "${SDK_LIBS[@]}"; do
            echo "----------------------------------------"
            echo "Publishing $pkg..."

            # Publish to crates.io and create tag
            if cargo release publish -p "$pkg" --execute --no-confirm; then
              echo "✓ Published $pkg"

              # Get the tag that was just created
              VERSION=$(cargo metadata --format-version 1 --no-deps | jq -r ".packages[] | select(.name == \"$pkg\") | .version")
              TAG="${pkg}-v${VERSION}"

              # Create GitHub release
              echo "Creating GitHub release for $TAG..."
              if gh release create "$TAG" --generate-notes --title "$TAG"; then
                echo "✓ Created release for $TAG"
                echo "$TAG" >> /tmp/published_tags.txt
              else
                echo "Warning: Failed to create release for $TAG"
              fi

              # Rate limiting: wait between publishes
              sleep 10
            else
              echo "Warning: Failed to publish $pkg"
            fi
          done

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let publishedTags = [];

            try {
              publishedTags = fs.readFileSync('/tmp/published_tags.txt', 'utf8').trim().split('\n').filter(t => t);
            } catch (e) {
              console.log('No published tags file found');
            }

            let body = '**Release published successfully!**\n\n';

            if (publishedTags.length > 0) {
              body += '**Published versions:**\n';
              publishedTags.forEach(tag => {
                const crateUrl = `https://crates.io/crates/${tag.split('-v')[0]}`;
                body += `- [\`${tag}\`](https://github.com/${context.repo.owner}/${context.repo.repo}/releases/tag/${tag}) ([crates.io](${crateUrl}))\n`;
              });
            } else {
              body += 'No new versions published (all crates were up to date).\n';
            }

            body += '\n---\n';
            body += '✓ Crates published to crates.io\n';
            body += '✓ Git tags created and pushed\n';
            body += '✓ GitHub releases created\n';

            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });
