use handlebars::Handlebars;
use serde_json::json;

extern crate syn;

use super::utxo_type::UtxoType;
use crate::Instance;
// TODO: make Utxo dynamic with utxo_name, currently it's hardcoded to Utxo with OutUtxo suffix
pub const AUTO_GENERATED_ACCOUNTS_TEMPLATE: &str = "
use anchor_lang::prelude::*;

/**
 * This file is auto-generated by the Light cli.
 * DO NOT EDIT MANUALLY.
 * THE FILE WILL BE OVERWRITTEN EVERY TIME THE LIGHT CLI BUILD IS RUN.
 */
#[allow(non_camel_case_types)]
// helper struct to create anchor idl with u256 type
#[account]
#[derive(Debug, Copy, PartialEq)]
pub struct u256 {
    pub x: [u8; 32],
}

pub const NR_CHECKED_INPUTS: usize = {{nr_checked_inputs}};

#[allow(non_snake_case)]
#[derive(Debug)]
#[account]
pub struct InstructionDataLightInstructionSecond {
    {{#each public_inputs}}
    pub {{this}}: [u8; 32],
    {{/each}}
}

#[allow(non_snake_case)]
#[derive(Debug, Copy, PartialEq)]
#[account]
pub struct UtxoOutUtxo {
    pub amounts: [u64; 2],
    pub spl_asset_index: u64,
    pub verifier_address_index: u64,
    pub blinding: u256,
    pub app_data_hash: u256,
    pub account_shielded_public_key: u256,
    pub account_encryption_public_key: [u8; 32],
    {{#each utxo_inputs}}
    pub {{this}}: u256,
    {{/each}}
}

#[allow(non_snake_case)]
#[account]
#[derive(Debug, Copy, PartialEq)]
pub struct UtxoOutUtxoAppData {
    {{#each utxo_inputs}}
    pub {{this}}: u256,
    {{/each}}
}";

// TODO: support multiple utxo types
// TODO: reflect utxo name in the template
// TODO: reflect whether it's in or out utxo in the template
pub fn generate_accounts_code(instance: &Instance, checked_in_utxos: &Vec<UtxoType>) -> String {
    if checked_in_utxos.len() > 2 {
        // native type plus one custom type
        panic!("Only one Utxo type is supported for now");
    }
    let utxo_data_variable_names = checked_in_utxos[0].fields.clone();

    let public_inputs = instance.public_inputs[2..].to_vec();
    let handlebars = Handlebars::new();
    let data = json!({
        "nr_checked_inputs": instance.public_inputs.len().to_string(),
        "utxo_inputs": utxo_data_variable_names,
        "public_inputs": public_inputs
    });

    handlebars
        .render_template(AUTO_GENERATED_ACCOUNTS_TEMPLATE, &data)
        .unwrap_or_default()
}

#[cfg(test)]
mod auto_generated_accounts_tests {
    use std::{fs::File, io::prelude::*};

    use super::*;
    use crate::utils::assert_syn_eq;
    #[test]
    fn test_functional() {
        let file_path = "./test-files/test-data/auto_generated_accounts.rs";
        let mut file = File::open(file_path).expect("Unable to open the file");

        // Read the file's content
        let mut expected_output = String::new();
        file.read_to_string(&mut expected_output)
            .expect("Unable to read the file");

        let output = generate_accounts_code(
            &Instance {
                public_inputs: vec![
                    String::from("transactionHash"),
                    String::from("publicAppVerifier"),
                    String::from("publicZ"),
                ],
                name: "testDataMain".to_string(),
                template_name: Some(String::from("TestData")),
                template_constants: None,
            },
            &vec![UtxoType {
                fields: vec![String::from("x"), String::from("y")],
                code: "".to_string(),
                name: "".to_string(),
            }],
        );
        assert_syn_eq(output.as_str(), expected_output.as_str());
    }
}
