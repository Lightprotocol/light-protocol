use std::{fs, io::prelude::*};

use crate::errors::MacroCircomError;

pub const DISCLAIMER_STRING: &str = "/**
* This file is auto-generated by the Light cli.
* DO NOT EDIT MANUALLY.
* THE FILE WILL BE OVERWRITTEN EVERY TIME THE LIGHT CLI BUILD IS RUN.
*/";

#[derive(Debug, PartialEq, Clone)]
pub struct Instance {
    pub name: String,
    pub template_name: Option<String>, // currently always None
    pub template_constants: Option<Vec<String>>,
    pub public_inputs: Vec<String>,
}

pub fn generate_circom_main_code(instance: &Instance) -> Result<String, MacroCircomError> {
    let template_constants = &instance.template_constants;
    let public_inputs = instance.public_inputs.to_vec();

    let inputs_str = public_inputs.join(", ");
    let config_str = match template_constants {
        Some(template_constants) => template_constants.join(", "),
        None => String::new(),
    };
    let template_name = match &instance.template_name {
        Some(name) => Ok(name),
        None => Err(MacroCircomError::TemplateNameNotRead),
    }?;
    Ok(format!(
        "{}\npragma circom 2.1.4;\n\
include \"./{}.circom\";\n\
component main {{public [{}]}} =  {}({}{} 22, 4, 4, 6686672797465227418401714772753289406522066866583537086457438811846503839916, 0, 1, 3, 2, 2);",
DISCLAIMER_STRING,template_name, inputs_str, template_name, config_str, if config_str.is_empty() { "" } else { "," }
    ))
}

pub fn generate_circom_main_file(instance: Instance, path_to_parent_dir: &str) {
    let mut output_file =
        fs::File::create([path_to_parent_dir, "/", instance.name.as_str(), ".circom"].concat())
            .unwrap();
    let code = generate_circom_main_code(&instance).unwrap();
    // println!(
    //     "sucessfully created main {}.circom and {}.circom",
    //     instance.template_name.unwrap(),
    //     instance.name
    // );

    write!(&mut output_file, "{}", code).unwrap();
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{lang, utils::describe_error};
    #[test]
    fn test_generate_circom_string_pass() {
        let instance = Instance {
            name: "appTransaction".to_owned(),
            template_name: Some(String::from("AppTransaction")),
            template_constants: Some(vec![String::from("7"), String::from("1")]),
            public_inputs: vec![
                String::from("publicTransactionHash"),
                String::from("publicProgramId"),
            ],
        };

        let expected_string = format!("{}\npragma circom 2.1.4;\n\
            include \"./AppTransaction.circom\";\n\
            component main {{public [publicTransactionHash, publicProgramId]}} =  AppTransaction(7, 1, 22, 4, 4, 6686672797465227418401714772753289406522066866583537086457438811846503839916, 0, 1, 3, 2, 2);", DISCLAIMER_STRING);

        assert_eq!(
            generate_circom_main_code(&instance).unwrap(),
            expected_string
        );
    }

    #[test]
    fn test_generate_circom_string_pass2() {
        let instance = Instance {
            name: "AppTransaction".to_owned(),
            template_name: Some(String::from("AppTransaction")),
            template_constants: Some(vec![
                String::from("7"),
                String::from("1"),
                String::from("3"),
                String::from("2"),
            ]),
            public_inputs: vec![
                String::from("publicTransactionHash"),
                String::from("publicProgramId"),
            ],
        };

        let expected_string = format!("{}\npragma circom 2.1.4;\n\
            include \"./AppTransaction.circom\";\n\
            component main {{public [publicTransactionHash, publicProgramId]}} =  AppTransaction(7, 1, 3, 2, 22, 4, 4, 6686672797465227418401714772753289406522066866583537086457438811846503839916, 0, 1, 3, 2, 2);", DISCLAIMER_STRING);

        assert_eq!(
            generate_circom_main_code(&instance).unwrap(),
            expected_string
        );
    }

    #[test]
    fn test_generate_circom_string_fail() {
        let instance = Instance {
            name: "appTransaction".to_owned(),
            template_name: Some(String::from("AppTransaction")),
            template_constants: Some(vec![String::from("7"), String::from("1")]),
            public_inputs: vec![
                String::from("publicTransactionHash"),
                String::from("publicProgramId"),
            ],
        };

        let incorrect_expected_string = "pragma circom 2.1.4;\n\
            include \"./circuit.circom\";\n\
            component main {public [publicTransactionHash, publicProgramId]} =  appTransaction(7, 2, 22, 4, 4, 6686672797465227418401714772753289406522066866583537086457438811846503839916, 0, 1, 3, 2, 2);";

        assert_ne!(
            generate_circom_main_code(&instance).unwrap(),
            incorrect_expected_string
        );
    }

    #[test]
    fn test_parse_instance() {
        let input = String::from(
            r#"#[instance]
            {
                name: appTransactionMain,
                template_constants:[7, 1, 9, 2],
        }"#,
        );
        let expected = Instance {
            name: "appTransactionMain".to_owned(),
            template_name: None,
            template_constants: Some(vec![
                String::from("7"),
                String::from("1"),
                String::from("9"),
                String::from("2"),
            ]),
            public_inputs: vec![
                String::from("publicTransactionHash"),
                String::from("publicProgramId"),
            ],
        };

        let result = lang::InstanceParser::new().parse(&input);

        match result {
            Ok(result) => assert_eq!(result, expected),
            Err(error) => {
                println!("{}", describe_error(&input, error.clone()));
                panic!("{}", describe_error(&input, error));
            }
        }
    }

    #[test]
    fn test_parse_instance_with_public_input() {
        let input = String::from(
            r#"

        #[instance]
        {
            name: appTransaction,
            template_constants:[7, 1, 9, 2],
            publicInputs: [inputA,inputB],
        }
        template sxasSD() {
            signal input inputA;
        }
    "#,
        );
        let expected = Instance {
            name: "appTransaction".to_owned(),
            template_name: None,
            template_constants: Some(vec![
                String::from("7"),
                String::from("1"),
                String::from("9"),
                String::from("2"),
            ]),
            public_inputs: vec![
                String::from("publicTransactionHash"),
                String::from("publicProgramId"),
                String::from("inputA"),
                String::from("inputB"),
            ],
        };

        let result = lang::ParseInstanceParser::new().parse(&input);

        match result {
            Ok(result) => assert_eq!(result.0.unwrap(), expected),
            Err(error) => {
                panic!("{}", describe_error(&input, error));
            }
        }
    }
}
