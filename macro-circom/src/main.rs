extern crate num_bigint_dig as num_bigint;
extern crate num_traits;
extern crate serde;
extern crate serde_derive;
pub mod code_gen;
pub mod errors;
pub mod preprocess;
pub mod utils;

use std::path::Path;
#[macro_use]
extern crate lalrpop_util;

lalrpop_mod!(pub lang);

use anyhow::Error as AnyhowError;
use clap::{App, Arg};
use code_gen::{
    check_utxo_code::Utxo,
    circom_main_code::Instance,
    utxo_type::{generate_utxo_type_code, get_native_utxo_type, UtxoType},
};
use errors::MacroCircomError;
use heck::ToLowerCamelCase;
use utils::{create_file, describe_error, open_file, write_rust_code_to_file};

use crate::{
    code_gen::{
        accounts_code::generate_accounts_code, check_utxo_code::*,
        circom_code::generate_psp_circom_code, circom_main_code::generate_circom_main_code,
    },
    preprocess::preprocess,
};
fn remove_filename_suffix(input: &str) -> Result<(String, String), &'static str> {
    let path = Path::new(input);

    if path.extension() != Some(std::ffi::OsStr::new("light")) {
        return Err("The file does not have a .light suffix");
    }

    let directory = path
        .parent()
        .map_or(input, |p| p.to_str().unwrap_or(input))
        .to_string();
    let filename_without_suffix = path
        .file_stem()
        .map_or("", |f| f.to_str().unwrap_or(""))
        .to_string();
    Ok((directory, filename_without_suffix))
}

fn main() -> Result<(), AnyhowError> {
    let matches = App::new("macro-circom")
        .version("0.1")
        .arg(
            Arg::with_name("file_path")
                .help("Path to the file")
                .required(true)
                .index(1),
        )
        .arg(
            Arg::with_name("program_name")
                .help("Name of the program")
                .required(true)
                .index(2),
        )
        .arg(
            Arg::with_name("output_accounts_path")
                .long("output_accounts_path")
                .help("Output path of the accounts rust file")
                .takes_value(true),
        )
        .arg(
            Arg::with_name("output_circom_path")
                .long("output_circom_path")
                .help("Output path of the generated circom and main circom files")
                .takes_value(true),
        )
        .get_matches();

    // Get the values of the arguments
    let file_path = matches.value_of("file_path").unwrap();
    let program_name = matches.value_of("program_name").unwrap();
    let output_accounts_path = matches.value_of("output_accounts_path");
    let output_circom_path = matches.value_of("output_circom_path");

    let (path_to_parent_dir, _) = remove_filename_suffix(file_path).unwrap();
    let contents = open_file(file_path)?;

    // parse .light file
    let (instance, mut utxo_type, mut checked_utxos, parsed_circom_code) = parse(contents.clone())?;
    let mut instance = instance[0].clone();
    // start code generation
    let (circom_main_code, circom_code, rust_autogenerated_accounts_code) = generate_code(
        &mut instance,
        &mut utxo_type,
        &mut checked_utxos,
        parsed_circom_code,
    )?;

    // create files
    create_files(
        circom_main_code,
        circom_code,
        rust_autogenerated_accounts_code,
        path_to_parent_dir,
        instance,
        program_name.to_string(),
        output_accounts_path,
        output_circom_path,
    );
    Ok(())
}

fn parse(
    contents: String,
) -> Result<(Vec<Instance>, Vec<UtxoType>, Vec<Utxo>, String), AnyhowError> {
    let parsed_content = match preprocess(contents.as_str(), 0usize, false) {
        Ok(parsed_content) => parsed_content,
        Err(_) => panic!("Preprocess failed"),
    };
    let parsing_res = match crate::lang::ParseInstanceParser::new().parse(&parsed_content) {
        Ok(instance) => instance,
        Err(error) => {
            println!("Parsing check utxo error.");
            panic!(
                "Parse Macros failed {}",
                describe_error(&parsed_content, error)
            );
        }
    };
    let instance = match parsing_res.0 {
        Some(instance) => instance,
        None => {
            println!("Parsing check utxo error.");
            panic!("No instance found.");
        }
    };
    let mut utxo_types = parsing_res.1;
    utxo_types.push(get_native_utxo_type());
    let checked_utxos = parsing_res.2;

    Ok((vec![instance], utxo_types, checked_utxos, parsed_content))
}

fn generate_code(
    instance: &mut Instance,
    utxo_types: &mut Vec<UtxoType>,
    checked_utxos: &mut Vec<Utxo>,
    content: String,
) -> Result<(String, String, String), MacroCircomError> {
    generate_utxo_type_code(utxo_types).unwrap();
    assign_utxo_type(&utxo_types, checked_utxos).unwrap();
    generate_check_utxo_code(checked_utxos).unwrap();
    let rust_autogenerated_accounts_code = generate_accounts_code(instance, &utxo_types);

    let (_verifier_name, circom_code) =
        generate_psp_circom_code(&content, &checked_utxos, instance, utxo_types).unwrap();
    let circom_main_code = generate_circom_main_code(&instance)?;

    Ok((
        circom_main_code,
        circom_code,
        rust_autogenerated_accounts_code,
    ))
}

fn create_files(
    circom_main_code: String,
    circom_code: String,
    rust_autogenerated_accounts_code: String,
    path_to_parent_dir: String,
    instance: Instance,
    program_name: String,
    provided_accounts_path: Option<&str>,
    provided_circom_path: Option<&str>,
) {
    let path_to_parent_dir = provided_circom_path
        .map(|s| s.to_string())
        .unwrap_or(path_to_parent_dir);

    let circuit_main_file_name = format!(
        "{}/{}Main.circom",
        &path_to_parent_dir,
        &instance.name.to_lower_camel_case()
    );
    create_file(&circuit_main_file_name, &circom_main_code).unwrap();

    let circuit_file_name = format!(
        "{}/{}.circom",
        &path_to_parent_dir,
        &instance.template_name.unwrap()
    );
    create_file(&circuit_file_name, &circom_code).unwrap();

    let accounts_path = provided_accounts_path
        .map(|s| format!("{}/auto_generated_accounts.rs", &s))
        .unwrap_or(format!(
            "./programs/{}/src/auto_generated_accounts.rs",
            &program_name
        ));
    write_rust_code_to_file(accounts_path, rust_autogenerated_accounts_code);
}

#[cfg(test)]
mod tests {
    use std::process::Command;

    #[test]
    fn test_main_functional() {
        println!("Running test_main_functional");
        let file_path = "./test-files/test-data/test_data.light";
        let program_name = "test_data";
        let command_output = Command::new("../target/debug/macro-circom")
            .args(&[
                file_path,
                program_name,
                "--output_accounts_path",
                "../target",
                "--output_circom_path",
                "../target",
            ])
            .output()
            .expect("Failed to execute command");
        let stdout = String::from_utf8_lossy(&command_output.stdout);
        println!("Command output (stdout):\n{}", stdout);
        if !command_output.status.success() {
            let stderr = String::from_utf8_lossy(&command_output.stderr);
            println!("Command output (stderr):\n{}", stderr);
            panic!("Command failed");
        }

        let command_output = Command::new("circom")
            .args(&[
                "-l",
                "../circuit-lib/circuit-lib.circom/node_modules/circomlib/circuits/",
                "-l",
                "../circuit-lib/circuit-lib.circom/src/merkle-tree/",
                "../target/testDataMain.circom",
                "-l",
                "../circuit-lib/circuit-lib.circom/src/light-utils/",
            ])
            .output()
            .expect("Failed to execute command");
        if !command_output.status.success() {
            let stderr = String::from_utf8_lossy(&command_output.stderr);
            println!("Command output (stderr):\n{}", stderr);
            panic!("Circom command failed");
        }
    }
}
