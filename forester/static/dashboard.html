<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forester Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f7;
            color: #1d1d1f;
            font-size: 13px;
            line-height: 1.4;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 16px;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            margin-bottom: 16px;
            border-bottom: 1px solid #d2d2d7;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 600;
            color: #1d1d1f;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 13px;
            color: #86868b;
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-badge.healthy { background: #d1fae5; color: #065f46; }
        .status-badge.loading { background: #fef3c7; color: #92400e; }
        .status-badge.error { background: #fee2e2; color: #991b1b; }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }

        /* Cards */
        .card {
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border: 1px solid #e5e5e7;
        }

        /* Summary Row */
        .summary-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 16px;
        }

        .summary-card {
            padding: 16px;
        }

        .summary-card h3 {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #86868b;
            margin-bottom: 12px;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
        }

        .metric {
            text-align: center;
        }

        .metric-value {
            font-size: 24px;
            font-weight: 600;
            color: #1d1d1f;
        }

        .metric-value.small {
            font-size: 18px;
        }

        .metric-label {
            font-size: 11px;
            color: #86868b;
            margin-top: 2px;
        }

        .metric-sub {
            font-size: 10px;
            color: #007aff;
            margin-top: 2px;
        }

        /* Progress bar for epoch */
        .epoch-progress {
            margin-top: 12px;
        }

        .progress-bar-container {
            height: 6px;
            background: #e5e5e7;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            background: #007aff;
            border-radius: 3px;
            transition: width 0.3s;
        }

        .progress-label {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #86868b;
            margin-top: 4px;
        }

        /* Foresters Section */
        .foresters-section {
            margin-bottom: 16px;
        }

        .foresters-card {
            padding: 16px;
        }

        .foresters-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .foresters-header h3 {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #86868b;
        }

        .forester-count {
            font-size: 12px;
            color: #1d1d1f;
            font-weight: 500;
        }

        .foresters-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .forester-column h4 {
            font-size: 12px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #e5e5e7;
        }

        .forester-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .forester-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            background: #f5f5f7;
            border-radius: 4px;
            font-size: 12px;
        }

        .forester-address {
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .forester-color-dot {
            width: 10px;
            height: 10px;
            border-radius: 2px;
            flex-shrink: 0;
        }

        .forester-balance {
            font-weight: 600;
            color: #34c759;
        }

        .forester-balance.low { color: #ff9500; }
        .forester-balance.critical { color: #ff3b30; }

        /* Trees Section - Table Design */
        .trees-section {
            margin-bottom: 16px;
        }

        .trees-card {
            padding: 16px;
            overflow-x: auto;
        }

        .trees-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .trees-header h3 {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #86868b;
        }

        .tree-type-pills {
            display: flex;
            gap: 8px;
        }

        .tree-type-pill {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 10px;
            background: #f5f5f7;
            color: #86868b;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }

        .tree-type-pill:hover {
            background: #e5e5e7;
        }

        .tree-type-pill.active {
            background: #007aff;
            color: white;
        }

        .tree-type-pill.clear-filter {
            background: transparent;
            color: #007aff;
            border: 1px solid #007aff;
        }

        /* Tree Table */
        .tree-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .tree-table th {
            text-align: left;
            padding: 8px 12px;
            background: #f5f5f7;
            font-weight: 600;
            color: #86868b;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #e5e5e7;
            white-space: nowrap;
        }

        .tree-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #f0f0f2;
            vertical-align: middle;
        }

        .tree-table tr:hover {
            background: #fafafa;
        }

        .tree-table tr.rolled-over {
            opacity: 0.5;
            background: #f5f5f7;
        }

        .tree-table tr.rolled-over td {
            color: #86868b;
        }

        .rolled-over-badge {
            display: inline-block;
            font-size: 9px;
            font-weight: 500;
            padding: 1px 5px;
            border-radius: 3px;
            background: #e5e5e7;
            color: #86868b;
            margin-left: 6px;
            vertical-align: middle;
        }

        /* Type badge in table */
        .type-badge {
            display: inline-block;
            font-size: 10px;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 4px;
            color: white;
        }

        .type-badge.state-v1 { background: #5856d6; }
        .type-badge.state-v2 { background: #007aff; }
        .type-badge.address-v1 { background: #ff9500; }
        .type-badge.address-v2 { background: #34c759; }

        /* Monospace addresses */
        .mono {
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 11px;
            color: #1d1d1f;
        }

        /* Fullness bar in table */
        .fullness-cell {
            min-width: 120px;
        }

        .fullness-bar {
            height: 16px;
            background: #e5e5e7;
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .fullness-fill {
            height: 100%;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 6px;
            font-size: 10px;
            font-weight: 600;
            color: white;
            min-width: 35px;
        }

        .fullness-fill.normal { background: #34c759; }
        .fullness-fill.warning { background: #ff9500; }
        .fullness-fill.danger { background: #ff3b30; }

        /* Numeric cells */
        .num {
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 11px;
            text-align: right;
        }

        /* Pending highlight */
        .pending-value {
            font-weight: 600;
        }

        .pending-value.has-pending {
            color: #ff9500;
        }

        .pending-value.zero {
            color: #34c759;
        }

        /* Split pending indicator for StateV2 (output | input) */
        .pending-split {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 11px;
        }

        .pending-split .output {
            color: #ff9500;
            font-weight: 600;
        }

        .pending-split .output.zero {
            color: #34c759;
        }

        .pending-split .separator {
            color: #d1d1d6;
            font-weight: 400;
        }

        .pending-split .input {
            color: #007aff;
            font-weight: 600;
        }

        .pending-split .input.zero {
            color: #34c759;
        }

        .pending-labels {
            font-size: 9px;
            color: #86868b;
            display: inline-flex;
            gap: 2px;
            margin-left: 4px;
        }

        /* Fill progress bar - items toward next ZKP batch */
        .fill-progress-row {
            display: flex;
            gap: 6px;
            margin-top: 4px;
        }

        .fill-progress {
            flex: 1;
        }

        .fill-progress-bar {
            height: 12px;
            background: #e5e5e7;
            border-radius: 3px;
            overflow: hidden;
            position: relative;
            min-width: 60px;
        }

        .fill-progress-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s;
        }

        .fill-progress-fill.output {
            background: linear-gradient(90deg, #ff9500 0%, #ff6b00 100%);
        }

        .fill-progress-fill.input {
            background: linear-gradient(90deg, #007aff 0%, #5856d6 100%);
        }

        .fill-progress-text {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: 600;
            color: #fff;
            text-shadow: 0 0 2px rgba(0,0,0,0.5);
        }

        .fill-progress-label {
            font-size: 8px;
            color: #86868b;
            text-align: center;
            margin-top: 1px;
        }

        /* Schedule Grid */
        .schedule-cell {
            width: 100%;
        }

        .schedule-grid {
            display: flex;
            flex-wrap: nowrap;
            gap: 2px;
            width: 100%;
        }

        .schedule-slot {
            flex: 1;
            min-width: 4px;
            max-width: 20px;
            height: 10px;
            border-radius: 2px;
        }

        .schedule-slot.past {
            opacity: 0.35;
        }

        .schedule-slot.current {
            box-shadow: 0 0 0 1px #1d1d1f;
            transform: scale(1.3);
            z-index: 1;
        }

        .schedule-slot.unassigned {
            background: #d1d1d6;
        }

        /* Empty states */
        .empty-state {
            text-align: center;
            padding: 24px;
            color: #86868b;
            font-size: 13px;
        }

        /* Warning banners */
        .warning-banner {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 13px;
        }

        .warning-banner.critical {
            background: #fee2e2;
            border: 1px solid #fca5a5;
            color: #991b1b;
        }

        .warning-banner.warning {
            background: #fef3c7;
            border: 1px solid #fcd34d;
            color: #92400e;
        }

        .warning-banner-icon {
            font-size: 18px;
            flex-shrink: 0;
        }

        .warning-banner-content {
            flex: 1;
        }

        .warning-banner-title {
            font-weight: 600;
            margin-bottom: 2px;
        }

        .warning-banner-desc {
            font-size: 12px;
            opacity: 0.9;
        }

        /* Error message */
        .error-message {
            background: #fee2e2;
            border: 1px solid #fca5a5;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 16px;
            color: #991b1b;
            font-size: 13px;
        }

        /* Loading */
        .loading {
            text-align: center;
            padding: 40px;
            color: #86868b;
        }

        .spinner {
            width: 24px;
            height: 24px;
            border: 2px solid #e5e5e7;
            border-top-color: #007aff;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 12px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .tree-table {
                font-size: 11px;
            }
            .mono {
                font-size: 10px;
            }
        }

        @media (max-width: 768px) {
            .summary-row {
                grid-template-columns: 1fr;
            }
            .foresters-grid {
                grid-template-columns: 1fr;
            }
            .summary-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Forester Dashboard</h1>
            <div class="header-right">
                <span id="lastUpdated"></span>
                <div id="statusBadge" class="status-badge loading">
                    <span class="status-dot"></span>
                    Loading
                </div>
            </div>
        </div>

        <div id="errorContainer"></div>
        <div id="content">
            <div class="loading">
                <div class="spinner"></div>
                Loading status...
            </div>
        </div>
    </div>

    <script>
        const SLOT_SECONDS = 0.46;

        let lastUpdateTime = null;
        let typeFilter = null; // null = show all, or 'StateV2', 'AddressV2', etc.
        let cachedData = null;

        // Color palette for foresters - distinct, colorblind-friendly colors
        const FORESTER_COLORS = [
            '#007aff', // Blue
            '#34c759', // Green
            '#ff9500', // Orange
            '#af52de', // Purple
            '#ff2d55', // Pink
            '#5856d6', // Indigo
            '#00c7be', // Teal
            '#ff3b30', // Red
            '#ffcc00', // Yellow
            '#8e8e93', // Gray
        ];

        function getForesterColor(index) {
            if (index === null || index === undefined) return '#d1d1d6';
            return FORESTER_COLORS[index % FORESTER_COLORS.length];
        }

        function setTypeFilter(type) {
            typeFilter = (typeFilter === type) ? null : type;
            if (cachedData) {
                displayStatus(cachedData);
            }
        }

        async function fetchStatus() {
            try {
                const response = await fetch('/status');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                if (data.error) {
                    showError(data.error);
                    return;
                }
                cachedData = data;
                displayStatus(data);
                updateStatusBadge('healthy', 'Healthy');
                clearError();
                lastUpdateTime = new Date();
            } catch (error) {
                showError(error.message);
                updateStatusBadge('error', 'Error');
            }
        }

        function updateStatusBadge(status, text) {
            const badge = document.getElementById('statusBadge');
            badge.className = `status-badge ${status}`;
            badge.innerHTML = `<span class="status-dot"></span>${text}`;
        }

        function updateLastUpdatedTime() {
            if (!lastUpdateTime) return;
            const seconds = Math.floor((new Date() - lastUpdateTime) / 1000);
            document.getElementById('lastUpdated').textContent =
                seconds < 60 ? `${seconds}s ago` : `${Math.floor(seconds / 60)}m ago`;
        }

        function showError(message) {
            const container = document.getElementById('errorContainer');
            container.textContent = '';
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = 'Error: ' + message;
            container.appendChild(errorDiv);
        }

        function clearError() {
            document.getElementById('errorContainer').innerHTML = '';
        }

        function formatBalance(balance) {
            if (balance === null || balance === undefined) return '-';
            return balance.toFixed(2) + ' SOL';
        }

        function formatCountdown(hours) {
            if (hours === null || hours === undefined) return '-';
            if (hours === 0) return 'Now';
            if (hours < 1) return '<1h';
            if (hours < 24) return `${hours}h`;
            const days = Math.floor(hours / 24);
            const remainingHours = hours % 24;
            if (remainingHours === 0) return `${days}d`;
            return `${days}d ${remainingHours}h`;
        }

        // Format slots to hours:minutes
        function formatSlotsToTime(slots) {
            if (slots === null || slots === undefined) return '-';
            const totalSeconds = Math.floor(slots * SLOT_SECONDS);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);

            if (hours === 0 && minutes === 0) return 'Now';
            if (hours === 0) return `${minutes}m`;
            if (hours >= 24) {
                const days = Math.floor(hours / 24);
                const remainingHours = hours % 24;
                return `${days}d ${remainingHours}h ${minutes}m`;
            }
            return `${hours}h ${minutes}m`;
        }

        function getBalanceClass(balance) {
            if (balance === null || balance === undefined) return '';
            if (balance < 0.1) return 'critical';
            if (balance < 1) return 'low';
            return '';
        }

        function truncateAddress(addr) {
            if (!addr || addr.length < 12) return addr;
            return addr.slice(0, 6) + '...' + addr.slice(-4);
        }

        function getTypeBadgeClass(type) {
            const t = type.toLowerCase().replace(/\s+/g, '-');
            if (t.includes('state') && t.includes('v1')) return 'state-v1';
            if (t.includes('state') && t.includes('v2')) return 'state-v2';
            if (t.includes('address') && t.includes('v1')) return 'address-v1';
            if (t.includes('address') && t.includes('v2')) return 'address-v2';
            return '';
        }

        function getFullnessClass(percentage) {
            if (percentage >= 80) return 'danger';
            if (percentage >= 60) return 'warning';
            return 'normal';
        }

        function countTreeTypes(trees) {
            const counts = {};
            trees.forEach(t => {
                counts[t.tree_type] = (counts[t.tree_type] || 0) + 1;
            });
            return counts;
        }

        function sortTrees(trees) {
            // Sort by pending descending (trees needing attention first), then by type
            const typeOrder = { 'StateV2': 0, 'AddressV2': 1, 'StateV1': 2, 'AddressV1': 3 };
            return [...trees].sort((a, b) => {
                const isV2A = a.tree_type.includes('V2');
                const isV2B = b.tree_type.includes('V2');
                // For StateV2, sum input + output pending batches
                const pendingA = isV2A
                    ? ((a.v2_queue_info?.input_pending_batches || 0) + (a.v2_queue_info?.output_pending_batches || 0))
                    : (a.queue_length || 0);
                const pendingB = isV2B
                    ? ((b.v2_queue_info?.input_pending_batches || 0) + (b.v2_queue_info?.output_pending_batches || 0))
                    : (b.queue_length || 0);
                // Primary sort: pending descending
                if (pendingB !== pendingA) return pendingB - pendingA;
                // Secondary sort: type order
                const typeA = typeOrder[a.tree_type] ?? 99;
                const typeB = typeOrder[b.tree_type] ?? 99;
                return typeA - typeB;
            });
        }

        function renderScheduleGrid(schedule, currentLightSlot) {
            if (!schedule || schedule.length === 0) {
                return '<span style="color: #86868b;">-</span>';
            }

            // Render all slots as a compact grid
            const slots = schedule.map((foresterIdx, slotIdx) => {
                const color = getForesterColor(foresterIdx);
                const isPast = currentLightSlot !== null && slotIdx < currentLightSlot;
                const isCurrent = currentLightSlot !== null && slotIdx === currentLightSlot;

                let classes = 'schedule-slot';
                if (isPast) classes += ' past';
                if (isCurrent) classes += ' current';
                if (foresterIdx === null) classes += ' unassigned';

                return `<div class="${classes}" style="background: ${color};" title="Slot ${slotIdx}${isCurrent ? ' (current)' : ''}"></div>`;
            }).join('');

            return `<div class="schedule-grid">${slots}</div>`;
        }

        // Render single fill progress bar (for AddressV2 - input only)
        function renderFillProgressSingle(items, batchSize, type) {
            if (items === 0) return '';
            const percentage = Math.min((items / batchSize) * 100, 100);
            return `
                <div class="fill-progress">
                    <div class="fill-progress-bar">
                        <div class="fill-progress-fill ${type}" style="width: ${percentage}%"></div>
                        <div class="fill-progress-text">${items}/${batchSize}</div>
                    </div>
                </div>
            `;
        }

        // Render dual fill progress bars for StateV2 (output + input)
        function renderFillProgressDual(v2QueueInfo) {
            if (!v2QueueInfo) return '';

            const batchSize = v2QueueInfo.zkp_batch_size || 500;
            const outputItems = v2QueueInfo.output_items_in_current_zkp_batch || 0;
            const inputItems = v2QueueInfo.input_items_in_current_zkp_batch || 0;

            // Don't show if both are empty
            if (outputItems === 0 && inputItems === 0) return '';

            const outputPct = Math.min((outputItems / batchSize) * 100, 100);
            const inputPct = Math.min((inputItems / batchSize) * 100, 100);

            return `
                <div class="fill-progress-row">
                    <div class="fill-progress">
                        <div class="fill-progress-bar">
                            <div class="fill-progress-fill output" style="width: ${outputPct}%"></div>
                            <div class="fill-progress-text">${outputItems}/${batchSize}</div>
                        </div>
                        <div class="fill-progress-label">out</div>
                    </div>
                    <div class="fill-progress">
                        <div class="fill-progress-bar">
                            <div class="fill-progress-fill input" style="width: ${inputPct}%"></div>
                            <div class="fill-progress-text">${inputItems}/${batchSize}</div>
                        </div>
                        <div class="fill-progress-label">in</div>
                    </div>
                </div>
            `;
        }

        // Render fill progress for AddressV2 (input only)
        function renderFillProgress(v2QueueInfo) {
            if (!v2QueueInfo) return '';
            const batchSize = v2QueueInfo.zkp_batch_size || 500;
            const inputItems = v2QueueInfo.input_items_in_current_zkp_batch || 0;
            return renderFillProgressSingle(inputItems, batchSize, 'input');
        }

        function renderWarningBanners(data) {
            const activeCount = data.active_epoch_foresters?.length || 0;
            const regCount = data.registration_epoch_foresters?.length || 0;
            const banners = [];

            // Critical: No foresters in active epoch
            if (activeCount === 0) {
                banners.push(`
                    <div class="warning-banner critical">
                        <span class="warning-banner-icon">!!</span>
                        <div class="warning-banner-content">
                            <div class="warning-banner-title">No Foresters in Active Epoch ${data.current_active_epoch}</div>
                            <div class="warning-banner-desc">Trees will not be processed.</div>
                        </div>
                    </div>
                `);
            }

            // Warning: No foresters registered for next epoch (during registration phase)
            // Registration phase is when current_active_epoch != current_registration_epoch
            const inRegistrationPhase = data.current_active_epoch !== data.current_registration_epoch;
            if (regCount === 0 && inRegistrationPhase) {
                banners.push(`
                    <div class="warning-banner warning">
                        <span class="warning-banner-icon">!</span>
                        <div class="warning-banner-content">
                            <div class="warning-banner-title">No Foresters Registered for Epoch ${data.current_registration_epoch}</div>
                            <div class="warning-banner-desc">Registration is open. Register before it closes in ${data.hours_until_next_registration}h.</div>
                        </div>
                    </div>
                `);
            }

            // Warning: Registration phase expired and no foresters for next epoch
            if (regCount === 0 && !inRegistrationPhase && activeCount > 0) {
                banners.push(`
                    <div class="warning-banner warning">
                        <span class="warning-banner-icon">!</span>
                        <div class="warning-banner-content">
                            <div class="warning-banner-title">Registration Closed - No Foresters for Next Epoch</div>
                            <div class="warning-banner-desc">Epoch ${data.current_registration_epoch} will have no foresters. Trees will stop being processed after current epoch ends.</div>
                        </div>
                    </div>
                `);
            }

            return banners.join('');
        }

        function displayStatus(data) {
            const treeCounts = countTreeTypes(data.trees || []);
            const activeCount = data.active_epoch_foresters?.length || 0;
            const regCount = data.registration_epoch_foresters?.length || 0;

            // Apply type filter
            const filteredTrees = typeFilter
                ? (data.trees || []).filter(t => t.tree_type === typeFilter)
                : (data.trees || []);
            const sortedTrees = sortTrees(filteredTrees);

            const warningBanners = renderWarningBanners(data);

            const html = `
                ${warningBanners}
                <!-- Summary Row -->
                <div class="summary-row">
                    <div class="card summary-card">
                        <h3>Epoch Status</h3>
                        <div class="summary-grid">
                            <div class="metric">
                                <div class="metric-value">${data.current_active_epoch}</div>
                                <div class="metric-label">Active Epoch</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value">${data.current_registration_epoch}</div>
                                <div class="metric-label">Reg Epoch</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value small">${data.slot.toLocaleString()}</div>
                                <div class="metric-label">Current Slot</div>
                            </div>
                        </div>
                        <div class="epoch-progress">
                            <div class="progress-bar-container">
                                <div class="progress-bar-fill" style="width: ${data.active_epoch_progress_percentage}%"></div>
                            </div>
                            <div class="progress-label">
                                <span>${data.active_epoch_progress_percentage.toFixed(1)}% complete</span>
                                <span>${data.active_epoch_progress.toLocaleString()} / ${data.active_phase_length.toLocaleString()}</span>
                            </div>
                        </div>
                    </div>
                    <div class="card summary-card">
                        <h3>Timing</h3>
                        <div class="summary-grid">
                            <div class="metric">
                                <div class="metric-value">${data.current_light_slot !== null ? data.current_light_slot : '-'}${data.total_light_slots ? `<span style="font-size: 14px; color: #86868b;">/${data.total_light_slots}</span>` : ''}</div>
                                <div class="metric-label">Light Slot</div>
                                ${data.slots_until_next_light_slot ? `<div class="metric-sub">${(data.slots_until_next_light_slot * SLOT_SECONDS).toFixed(0)}s to next</div>` : ''}
                            </div>
                            <div class="metric">
                                <div class="metric-value">${formatSlotsToTime(data.active_phase_length - data.active_epoch_progress)}</div>
                                <div class="metric-label">Until Epoch ${data.current_active_epoch + 1}</div>
                            </div>
                            ${data.current_active_epoch !== data.current_registration_epoch ? `
                            <div class="metric">
                                <div class="metric-value" style="color: #34c759;">Open</div>
                                <div class="metric-label">Registration Epoch ${data.current_registration_epoch}</div>
                                <div class="metric-sub">Closes in ${formatSlotsToTime(data.slots_until_next_registration)}</div>
                            </div>
                            ` : `
                            <div class="metric">
                                ${data.slots_until_next_registration > 0 ? `
                                <div class="metric-value">${formatSlotsToTime(data.slots_until_next_registration)}</div>
                                <div class="metric-label">Until Registration Opens</div>
                                ` : `
                                <div class="metric-value" style="color: #ff9500;">Opening</div>
                                <div class="metric-label">Registration</div>
                                `}
                            </div>
                            `}
                        </div>
                    </div>
                </div>

                <!-- Foresters Section -->
                <div class="foresters-section">
                    <div class="card foresters-card">
                        <div class="foresters-header">
                            <h3>Foresters</h3>
                            <span class="forester-count">${activeCount} active, ${regCount} registered</span>
                        </div>
                        <div class="foresters-grid">
                            <div class="forester-column">
                                <h4>Active Epoch (${activeCount})</h4>
                                ${activeCount > 0 ? `
                                    <div class="forester-list">
                                        ${data.active_epoch_foresters.map((f, idx) => `
                                            <div class="forester-item">
                                                <span class="forester-address">
                                                    <span class="forester-color-dot" style="background: ${getForesterColor(idx)};"></span>
                                                    ${f.authority}
                                                </span>
                                                <span class="forester-balance ${getBalanceClass(f.balance_sol)}">${formatBalance(f.balance_sol)}</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                ` : '<div class="empty-state">No foresters</div>'}
                            </div>
                            <div class="forester-column">
                                <h4>Registration Epoch (${regCount})</h4>
                                ${regCount > 0 ? `
                                    <div class="forester-list">
                                        ${data.registration_epoch_foresters.map(f => `
                                            <div class="forester-item">
                                                <span class="forester-address">${f.authority}</span>
                                                <span class="forester-balance ${getBalanceClass(f.balance_sol)}">${formatBalance(f.balance_sol)}</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                ` : '<div class="empty-state">No foresters</div>'}
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Trees Section -->
                <div class="trees-section">
                    <div class="card trees-card">
                        <div class="trees-header">
                            <h3>Merkle Trees (${sortedTrees.length}${typeFilter ? ` of ${data.trees?.length || 0}` : ''})</h3>
                            <div class="tree-type-pills">
                                ${typeFilter ? `<span class="tree-type-pill clear-filter" onclick="setTypeFilter(null)">Clear</span>` : ''}
                                ${Object.entries(treeCounts).map(([type, count]) =>
                                    `<span class="tree-type-pill ${typeFilter === type ? 'active' : ''}" onclick="setTypeFilter('${type}')">${type}: ${count}</span>`
                                ).join('')}
                            </div>
                        </div>
                        ${sortedTrees.length > 0 ? `
                            <table class="tree-table">
                                <thead>
                                    <tr>
                                        <th>Type</th>
                                        <th>Tree Address</th>
                                        <th>Fullness</th>
                                        <th>Index</th>
                                        <th>Pending</th>
                                        <th>Schedule</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${sortedTrees.map(tree => {
                                        const isV2 = tree.tree_type.includes('V2');
                                        const isStateV2 = tree.tree_type === 'StateV2';
                                        const isRolledOver = tree.is_rolledover;

                                        // Render pending cell based on tree type
                                        let pendingHtml = '-';
                                        if (!isRolledOver) {
                                            if (isStateV2 && tree.v2_queue_info) {
                                                // StateV2: Show output | input split + dual fill progress
                                                const output = tree.v2_queue_info.output_pending_batches || 0;
                                                const input = tree.v2_queue_info.input_pending_batches || 0;
                                                pendingHtml = `
                                                    <span class="pending-split">
                                                        <span class="output ${output === 0 ? 'zero' : ''}" title="Output queue (nullifiers)">${output}</span>
                                                        <span class="separator">│</span>
                                                        <span class="input ${input === 0 ? 'zero' : ''}" title="Input queue (new items)">${input}</span>
                                                    </span>
                                                    <span class="pending-labels">out│in</span>
                                                    ${renderFillProgressDual(tree.v2_queue_info)}
                                                `;
                                            } else if (isV2) {
                                                // AddressV2: Only input queue + single fill progress
                                                const pending = tree.v2_queue_info?.input_pending_batches || 0;
                                                pendingHtml = `
                                                    <span class="pending-value ${pending > 0 ? 'has-pending' : 'zero'}">${pending}</span>
                                                    <span style="color: #86868b; font-size: 10px;"> batches</span>
                                                    ${renderFillProgress(tree.v2_queue_info)}
                                                `;
                                            } else {
                                                // V1: queue_length
                                                const pending = tree.queue_length || 0;
                                                pendingHtml = `
                                                    <span class="pending-value ${pending > 0 ? 'has-pending' : 'zero'}">${pending}</span>
                                                    <span style="color: #86868b; font-size: 10px;"> items</span>
                                                `;
                                            }
                                        }

                                        return `
                                            <tr class="${isRolledOver ? 'rolled-over' : ''}">
                                                <td>
                                                    <span class="type-badge ${getTypeBadgeClass(tree.tree_type)}">${tree.tree_type}</span>
                                                    ${isRolledOver ? '<span class="rolled-over-badge">INACTIVE</span>' : ''}
                                                </td>
                                                <td class="mono">${tree.merkle_tree}</td>
                                                <td class="fullness-cell">
                                                    <div class="fullness-bar">
                                                        <div class="fullness-fill ${getFullnessClass(tree.fullness_percentage)}"
                                                             style="width: ${Math.max(tree.fullness_percentage, 5)}%">
                                                            ${tree.fullness_percentage.toFixed(1)}%
                                                        </div>
                                                    </div>
                                                </td>
                                                <td class="num">${tree.next_index.toLocaleString()}</td>
                                                <td class="num">${pendingHtml}</td>
                                                <td class="schedule-cell">
                                                    ${isRolledOver ? '<span style="color: #86868b;">-</span>' : renderScheduleGrid(tree.schedule, data.current_light_slot)}
                                                </td>
                                            </tr>
                                        `;
                                    }).join('')}
                                </tbody>
                            </table>
                        ` : '<div class="empty-state">No trees found</div>'}
                    </div>
                </div>

            `;

            document.getElementById('content').innerHTML = html;
        }

        // Smart refresh based on light slot timing
        let refreshTimeout = null;

        function scheduleNextRefresh() {
            if (refreshTimeout) clearTimeout(refreshTimeout);

            // If we have light slot info, refresh when slot changes
            if (cachedData && cachedData.slots_until_next_light_slot) {
                const slotsRemaining = cachedData.slots_until_next_light_slot;
                // Convert slots to milliseconds, refresh slightly after slot change
                const msUntilChange = Math.max(1000, slotsRemaining * SLOT_SECONDS * 1000 + 500);
                // But cap at 10 seconds max
                const refreshIn = Math.min(msUntilChange, 10000);
                refreshTimeout = setTimeout(() => {
                    fetchStatus();
                    scheduleNextRefresh();
                }, refreshIn);
            } else {
                // Fallback to 10 second refresh
                refreshTimeout = setTimeout(() => {
                    fetchStatus();
                    scheduleNextRefresh();
                }, 10000);
            }
        }

        // Initial fetch
        fetchStatus().then(scheduleNextRefresh);

        // Update countdown every second
        setInterval(updateLastUpdatedTime, 1000);
    </script>
</body>
</html>
